paid_only,frequency,progress,stat.question_id,stat.question__article__slug,title,slug,is_hidden,total_accepted,total_submissions,id,stat.is_new_question,difficulty.level,ProblemDescription,num_solutions,num_likes
FALSE,0,0,2714,,Left and Right Sum Differences,left-and-right-sum-differences,FALSE,35989,40611,2574,FALSE,1,"Can you solve this real interview question? Left and Right Sum Differences - Given a 0-indexed integer array nums, find a 0-indexed integer array answer where:

 * answer.length == nums.length.
 * answer[i] = |leftSum[i] - rightSum[i]|.

Where:

 * leftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.
 * rightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.

Return the array answer.

 

Example 1:


Input: nums = [10,4,8,3]
Output: [15,1,11,22]
Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].
The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].


Example 2:


Input: nums = [1]
Output: [0]
Explanation: The array leftSum is [0] and the array rightSum is [0].
The array answer is [|0 - 0|] = [0].


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i] <= 105",Solutions (696),347
FALSE,0,0,2713,,Find the Divisibility Array of a String,find-the-divisibility-array-of-a-string,FALSE,19189,61985,2575,FALSE,2,"Can you solve this real interview question? Find the Divisibility Array of a String - You are given a 0-indexed string word of length n consisting of digits, and a positive integer m.

The divisibility array div of word is an integer array of length n such that:

 * div[i] = 1 if the numeric value of word[0,...,i] is divisible by m, or
 * div[i] = 0 otherwise.

Return the divisibility array of word.

 

Example 1:


Input: word = ""998244353"", m = 3
Output: [1,1,0,0,0,1,1,0,0]
Explanation: There are only 4 prefixes that are divisible by 3: ""9"", ""99"", ""998244"", and ""9982443"".


Example 2:


Input: word = ""1010"", m = 10
Output: [0,1,0,1]
Explanation: There are only 2 prefixes that are divisible by 10: ""10"", and ""1010"".


 

Constraints:

 * 1 <= n <= 105
 * word.length == n
 * word consists of digits from 0 to 9
 * 1 <= m <= 109",Solutions (284),373
FALSE,0,0,2712,,Find the Maximum Number of Marked Indices,find-the-maximum-number-of-marked-indices,FALSE,13611,36348,2576,FALSE,2,"Can you solve this real interview question? Find the Maximum Number of Marked Indices - You are given a 0-indexed integer array nums.

Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:

 * Pick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j.

Return the maximum possible number of marked indices in nums using the above operation any number of times.

 

Example 1:


Input: nums = [3,5,2,4]
Output: 2
Explanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and 1.
It can be shown that there's no other valid operation so the answer is 2.


Example 2:


Input: nums = [9,2,5,4]
Output: 4
Explanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and 0.
In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] <= nums[2]. Then mark index 1 and 2.
Since there is no other operation, the answer is 4.


Example 3:


Input: nums = [7,6,8]
Output: 0
Explanation: There is no valid operation to do, so the answer is 0.



 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109

 ",Solutions (258),394
FALSE,0,0,2711,,Minimum Time to Visit a Cell In a Grid,minimum-time-to-visit-a-cell-in-a-grid,FALSE,6102,17157,2577,FALSE,3,"Can you solve this real interview question? Minimum Time to Visit a Cell In a Grid - You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].

You are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.

Return the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.

 

Example 1:

[https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png]


Input: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
Output: 7
Explanation: One of the paths that we can take is the following:
- at t = 0, we are on the cell (0,0).
- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.
- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.
- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.
- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.
- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.
- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.
- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.
The final time is 7. It can be shown that it is the minimum time possible.


Example 2:

[https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png]


Input: grid = [[0,2,4],[3,2,1],[1,0,4]]
Output: -1
Explanation: There is no path from the top left to the bottom-right cell.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 2 <= m, n <= 1000
 * 4 <= m * n <= 105
 * 0 <= grid[i][j] <= 105
 * grid[0][0] == 0

 ",Solutions (114),336
FALSE,0,0,2710,,Minimum Operations to Reduce an Integer to 0,minimum-operations-to-reduce-an-integer-to-0,FALSE,15032,30312,2571,FALSE,2,"Can you solve this real interview question? Minimum Operations to Reduce an Integer to 0 - You are given a positive integer n, you can do the following operation any number of times:

 * Add or subtract a power of 2 from n.

Return the minimum number of operations to make n equal to 0.

A number x is power of 2 if x == 2i where i >= 0.

 

Example 1:


Input: n = 39
Output: 3
Explanation: We can do the following operations:
- Add 20 = 1 to n, so now n = 40.
- Subtract 23 = 8 from n, so now n = 32.
- Subtract 25 = 32 from n, so now n = 0.
It can be shown that 3 is the minimum number of operations we need to make n equal to 0.


Example 2:


Input: n = 54
Output: 3
Explanation: We can do the following operations:
- Add 21 = 2 to n, so now n = 56.
- Add 23 = 8 to n, so now n = 64.
- Subtract 26 = 64 from n, so now n = 0.
So the minimum number of operations is 3.


 

Constraints:

 * 1 <= n <= 105",Solutions (423),323
FALSE,0,0,2709,,Count the Number of Square-Free Subsets,count-the-number-of-square-free-subsets,FALSE,4711,23178,2572,FALSE,2,"Can you solve this real interview question? Count the Number of Square-Free Subsets - You are given a positive integer 0-indexed array nums.

A subset of the array nums is square-free if the product of its elements is a square-free integer.

A square-free integer is an integer that is divisible by no square number other than 1.

Return the number of square-free non-empty subsets of the array nums. Since the answer may be too large, return it modulo 109 + 7.

A non-empty subset of nums is an array that can be obtained by deleting some (possibly none but not all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.

 

Example 1:


Input: nums = [3,4,4,5]
Output: 3
Explanation: There are 3 square-free subsets in this example:
- The subset consisting of the 0th element [3]. The product of its elements is 3, which is a square-free integer.
- The subset consisting of the 3rd element [5]. The product of its elements is 5, which is a square-free integer.
- The subset consisting of 0th and 3rd elements [3,5]. The product of its elements is 15, which is a square-free integer.
It can be proven that there are no more than 3 square-free subsets in the given array.

Example 2:


Input: nums = [1]
Output: 1
Explanation: There is 1 square-free subset in this example:
- The subset consisting of the 0th element [1]. The product of its elements is 1, which is a square-free integer.
It can be proven that there is no more than 1 square-free subset in the given array.


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i] <= 30",Solutions (89),252
FALSE,0,0,2708,,Find the String with LCP,find-the-string-with-lcp,FALSE,2801,7804,2573,FALSE,3,"Can you solve this real interview question? Find the String with LCP - We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:

 * lcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].

Given an n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.

A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, ""aabd"" is lexicographically smaller than ""aaca"" because the first position they differ is at the third letter, and 'b' comes before 'c'.

 

Example 1:


Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]
Output: ""abab""
Explanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is ""abab"".


Example 2:


Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]
Output: ""aaaa""
Explanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is ""aaaa"". 


Example 3:


Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]
Output: """"
Explanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists.


 

Constraints:

 * 1 <= n == lcp.length == lcp[i].length <= 1000
 * 0 <= lcp[i][j] <= n",Solutions (46),121
FALSE,0,0,2707,,Merge Two 2D Arrays by Summing Values,merge-two-2d-arrays-by-summing-values,FALSE,22313,30488,2570,FALSE,1,"Can you solve this real interview question? Merge Two 2D Arrays by Summing Values - You are given two 2D integer arrays nums1 and nums2.

 * nums1[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
 * nums2[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.

Each array contains unique ids and is sorted in ascending order by id.

Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:

 * Only ids that appear in at least one of the two arrays should be included in the resulting array.
 * Each id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.

Return the resulting array. The returned array must be sorted in ascending order by id.

 

Example 1:


Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
Output: [[1,6],[2,3],[3,2],[4,6]]
Explanation: The resulting array contains the following:
- id = 1, the value of this id is 2 + 4 = 6.
- id = 2, the value of this id is 3.
- id = 3, the value of this id is 2.
- id = 4, the value of this id is 5 + 1 = 6.


Example 2:


Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
Output: [[1,3],[2,4],[3,6],[4,3],[5,5]]
Explanation: There are no common ids, so we just include each id with its value in the resulting list.


 

Constraints:

 * 1 <= nums1.length, nums2.length <= 200
 * nums1[i].length == nums2[j].length == 2
 * 1 <= idi, vali <= 1000
 * Both arrays contain unique ids.
 * Both arrays are in strictly ascending order by id.",Solutions (393),181
FALSE,0,0,2706,,Minimum Score by Changing Two Elements,minimum-score-by-changing-two-elements,FALSE,12618,26514,2567,FALSE,2,"Can you solve this real interview question? Minimum Score by Changing Two Elements - You are given a 0-indexed integer array nums.

 * The low score of nums is the minimum value of |nums[i] - nums[j]| over all 0 <= i < j < nums.length.
 * The high score of nums is the maximum value of |nums[i] - nums[j]| over all 0 <= i < j < nums.length.
 * The score of nums is the sum of the high and low scores of nums.

To minimize the score of nums, we can change the value of at most two elements of nums.

Return the minimum possible score after changing the value of at most two elements of nums.

Note that |x| denotes the absolute value of x.

 

Example 1:


Input: nums = [1,4,3]
Output: 0
Explanation: Change value of nums[1] and nums[2] to 1 so that nums becomes [1,1,1]. Now, the value of |nums[i] - nums[j]| is always equal to 0, so we return 0 + 0 = 0.


Example 2:


Input: nums = [1,4,7,8,5]
Output: 3
Explanation: Change nums[0] and nums[1] to be 6. Now nums becomes [6,6,7,8,5].
Our low score is achieved when i = 0 and j = 1, in which case |nums[i] - nums[j]| = |6 - 6| = 0.
Our high score is achieved when i = 3 and j = 4, in which case |nums[i] - nums[j]| = |8 - 5| = 3.
The sum of our high and low score is 3, which we can prove to be minimal.


 

Constraints:

 * 3 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (185),149
FALSE,0,0,2705,,Minimum Impossible OR,minimum-impossible-or,FALSE,10966,19105,2568,FALSE,2,"Can you solve this real interview question? Minimum Impossible OR - You are given a 0-indexed integer array nums.

We say that an integer x is expressible from nums if there exist some integers 0 <= index1 < index2 < ... < indexk < nums.length for which nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of nums.

Return the minimum positive non-zero integer that is not expressible from nums.

 

Example 1:


Input: nums = [2,1]
Output: 4
Explanation: 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4.


Example 2:


Input: nums = [5,3,2]
Output: 1
Explanation: We can show that 1 is the smallest number that is not expressible.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (172),246
FALSE,0,0,2704,,Maximum Difference by Remapping a Digit,maximum-difference-by-remapping-a-digit,FALSE,17562,29146,2566,FALSE,1,"Can you solve this real interview question? Maximum Difference by Remapping a Digit - You are given an integer num. You know that Danny Mittal will sneakily remap one of the 10 possible digits (0 to 9) to another digit.

Return the difference between the maximum and minimum values Danny can make by remapping exactly one digit in num.

Notes:

 * When Danny remaps a digit d1 to another digit d2, Danny replaces all occurrences of d1 in num with d2.
 * Danny can remap a digit to itself, in which case num does not change.
 * Danny can remap different digits for obtaining minimum and maximum values respectively.
 * The resulting number after remapping can contain leading zeroes.
 * We mentioned ""Danny Mittal"" to congratulate him on being in the top 10 in Weekly Contest 326.

 

Example 1:


Input: num = 11891
Output: 99009
Explanation: 
To achieve the maximum value, Danny can remap the digit 1 to the digit 9 to yield 99899.
To achieve the minimum value, Danny can remap the digit 1 to the digit 0, yielding 890.
The difference between these two numbers is 99009.


Example 2:


Input: num = 90
Output: 99
Explanation:
The maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0).
Thus, we return 99.

 

Constraints:

 * 1 <= num <= 108",Solutions (260),155
FALSE,0,0,2703,,Handling Sum Queries After Update,handling-sum-queries-after-update,FALSE,3139,12122,2569,FALSE,3,"Can you solve this real interview question? Handling Sum Queries After Update - You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries of queries. There are three types of queries:

 1. For a query of type 1, queries[i] = [1, l, r]. Flip the values from 0 to 1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-indexed.
 2. For a query of type 2, queries[i] = [2, p, 0]. For every index 0 <= i < n, set nums2[i] = nums2[i] + nums1[i] * p.
 3. For a query of type 3, queries[i] = [3, 0, 0]. Find the sum of the elements in nums2.

Return an array containing all the answers to the third type queries.

 

Example 1:


Input: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]
Output: [3]
Explanation: After the first query nums1 becomes [1,1,1]. After the second query, nums2 becomes [1,1,1], so the answer to the third query is 3. Thus, [3] is returned.


Example 2:


Input: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]
Output: [5]
Explanation: After the first query, nums2 remains [5], so the answer to the second query is 5. Thus, [5] is returned.


 

Constraints:

 * 1 <= nums1.length,nums2.length <= 105
 * nums1.length = nums2.length
 * 1 <= queries.length <= 105
 * queries[i].length = 3
 * 0 <= l <= r <= nums1.length - 1
 * 0 <= p <= 106
 * 0 <= nums1[i] <= 1
 * 0 <= nums2[i] <= 109",Solutions (71),127
FALSE,0,0,2701,,Subsequence With the Minimum Score,subsequence-with-the-minimum-score,FALSE,4389,13636,2565,FALSE,3,"Can you solve this real interview question? Subsequence With the Minimum Score - You are given two strings s and t.

You are allowed to remove any number of characters from the string t.

The score of the string is 0 if no characters are removed from the string t, otherwise:

 * Let left be the minimum index among all removed characters.
 * Let right be the maximum index among all removed characters.

Then the score of the string is right - left + 1.

Return the minimum possible score to make t a subsequence of s.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ""ace"" is a subsequence of ""abcde"" while ""aec"" is not).

 

Example 1:


Input: s = ""abacaba"", t = ""bzaa""
Output: 1
Explanation: In this example, we remove the character ""z"" at index 1 (0-indexed).
The string t becomes ""baa"" which is a subsequence of the string ""abacaba"" and the score is 1 - 1 + 1 = 1.
It can be proven that 1 is the minimum score that we can achieve.


Example 2:


Input: s = ""cde"", t = ""xyz""
Output: 3
Explanation: In this example, we remove characters ""x"", ""y"" and ""z"" at indices 0, 1, and 2 (0-indexed).
The string t becomes """" which is a subsequence of the string ""cde"" and the score is 2 - 0 + 1 = 3.
It can be proven that 3 is the minimum score that we can achieve.


 

Constraints:

 * 1 <= s.length, t.length <= 105
 * s and t consist of only lowercase English letters.",Solutions (84),275
FALSE,0,0,2700,,Substring XOR Queries,substring-xor-queries,FALSE,9397,28050,2564,FALSE,2,"Can you solve this real interview question? Substring XOR Queries - You are given a binary string s, and a 2D integer array queries where queries[i] = [firsti, secondi].

For the ith query, find the shortest substring of s whose decimal value, val, yields secondi when bitwise XORed with firsti. In other words, val ^ firsti == secondi.

The answer to the ith query is the endpoints (0-indexed) of the substring [lefti, righti] or [-1, -1] if no such substring exists. If there are multiple answers, choose the one with the minimum lefti.

Return an array ans where ans[i] = [lefti, righti] is the answer to the ith query.

A substring is a contiguous non-empty sequence of characters within a string.

 

Example 1:


Input: s = ""101101"", queries = [[0,5],[1,2]]
Output: [[0,2],[2,3]]
Explanation: For the first query the substring in range [0,2] is ""101"" which has a decimal value of 5, and 5 ^ 0 = 5, hence the answer to the first query is [0,2]. In the second query, the substring in range [2,3] is ""11"", and has a decimal value of 3, and 3 ^ 1 = 2. So, [2,3] is returned for the second query. 



Example 2:


Input: s = ""0101"", queries = [[12,8]]
Output: [[-1,-1]]
Explanation: In this example there is no substring that answers the query, hence [-1,-1] is returned.


Example 3:


Input: s = ""1"", queries = [[4,5]]
Output: [[0,0]]
Explanation: For this example, the substring in range [0,0] has a decimal value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].


 

Constraints:

 * 1 <= s.length <= 104
 * s[i] is either '0' or '1'.
 * 1 <= queries.length <= 105
 * 0 <= firsti, secondi <= 109",Solutions (146),279
FALSE,0,0,2699,,Count the Number of Fair Pairs,count-the-number-of-fair-pairs,FALSE,16667,52161,2563,FALSE,2,"Can you solve this real interview question? Count the Number of Fair Pairs - Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.

A pair (i, j) is fair if:

 * 0 <= i < j < n, and
 * lower <= nums[i] + nums[j] <= upper

 

Example 1:


Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6
Output: 6
Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).


Example 2:


Input: nums = [1,7,9,2,5], lower = 11, upper = 11
Output: 1
Explanation: There is a single fair pair: (2,3).


 

Constraints:

 * 1 <= nums.length <= 105
 * nums.length == n
 * -109 <= nums[i] <= 109
 * -109 <= lower <= upper <= 109",Solutions (255),570
FALSE,0,0,2698,,Find the Array Concatenation Value,find-the-array-concatenation-value,FALSE,28406,40690,2562,FALSE,1,"Can you solve this real interview question? Find the Array Concatenation Value - You are given a 0-indexed integer array nums.

The concatenation of two numbers is the number formed by concatenating their numerals.

 * For example, the concatenation of 15, 49 is 1549.

The concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:

 * If there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.
 * If one element exists, add its value to the concatenation value of nums, then delete it.

Return the concatenation value of the nums.

 

Example 1:


Input: nums = [7,52,2,4]
Output: 596
Explanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.
 - In the first operation:
We pick the first element, 7, and the last element, 4.
Their concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.
Then we delete them from nums, so nums becomes equal to [52,2].
 - In the second operation:
We pick the first element, 52, and the last element, 2.
Their concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.
Then we delete them from the nums, so nums becomes empty.
Since the concatenation value is 596 so the answer is 596.


Example 2:


Input: nums = [5,14,13,8,12]
Output: 673
Explanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.
 - In the first operation:
We pick the first element, 5, and the last element, 12.
Their concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.
Then we delete them from the nums, so nums becomes equal to [14,13,8].
 - In the second operation:
We pick the first element, 14, and the last element, 8.
Their concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.
Then we delete them from the nums, so nums becomes equal to [13].
 - In the third operation:
nums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.
Then we delete it from nums, so nums become empty.
Since the concatenation value is 673 so the answer is 673.


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i] <= 104

 ",Solutions (511),213
FALSE,0,0,2696,,The Number of Beautiful Subsets,the-number-of-beautiful-subsets,FALSE,9700,34672,2597,FALSE,2,"Can you solve this real interview question? The Number of Beautiful Subsets - You are given an array nums of positive integers and a positive integer k.

A subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.

Return the number of non-empty beautiful subsets of the array nums.

A subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.

 

Example 1:


Input: nums = [2,4,6], k = 2
Output: 4
Explanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].
It can be proved that there are only 4 beautiful subsets in the array [2,4,6].


Example 2:


Input: nums = [1], k = 1
Output: 1
Explanation: The beautiful subset of the array nums is [1].
It can be proved that there is only 1 beautiful subset in the array [1].


 

Constraints:

 * 1 <= nums.length <= 20
 * 1 <= nums[i], k <= 1000",Solutions (183),314
FALSE,0,0,2695,,Find Score of an Array After Marking All Elements,find-score-of-an-array-after-marking-all-elements,FALSE,10016,19166,2593,FALSE,2,"Can you solve this real interview question? Find Score of an Array After Marking All Elements - You are given an array nums consisting of positive integers.

Starting with score = 0, apply the following algorithm:

 * Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.
 * Add the value of the chosen integer to score.
 * Mark the chosen element and its two adjacent elements if they exist.
 * Repeat until all the array elements are marked.

Return the score you get after applying the above algorithm.

 

Example 1:


Input: nums = [2,1,3,4,5,2]
Output: 7
Explanation: We mark the elements as follows:
- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2].
- 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2].
- 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2].
Our score is 1 + 2 + 4 = 7.


Example 2:


Input: nums = [2,3,5,1,3,2]
Output: 5
Explanation: We mark the elements as follows:
- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2].
- 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2].
- 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2].
Our score is 1 + 2 + 2 = 5.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 106",Solutions (294),210
FALSE,0,0,2692,,Take Gifts From the Richest Pile,take-gifts-from-the-richest-pile,FALSE,26641,40093,2558,FALSE,1,"Can you solve this real interview question? Take Gifts From the Richest Pile - You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:

 * Choose the pile with the maximum number of gifts.
 * If there is more than one pile with the maximum number of gifts, choose any.
 * Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.

Return the number of gifts remaining after k seconds.

 

Example 1:


Input: gifts = [25,64,9,4,100], k = 4
Output: 29
Explanation: 
The gifts are taken in the following way:
- In the first second, the last pile is chosen and 10 gifts are left behind.
- Then the second pile is chosen and 8 gifts are left behind.
- After that the first pile is chosen and 5 gifts are left behind.
- Finally, the last pile is chosen again and 3 gifts are left behind.
The final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.


Example 2:


Input: gifts = [1,1,1,1], k = 4
Output: 4
Explanation: 
In this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. 
That is, you can't take any pile with you. 
So, the total gifts remaining are 4.


 

Constraints:

 * 1 <= gifts.length <= 103
 * 1 <= gifts[i] <= 109
 * 1 <= k <= 103",Solutions (472),215
FALSE,0,0,2691,,Count Vowel Strings in Ranges,count-vowel-strings-in-ranges,FALSE,19740,38472,2559,FALSE,2,"Can you solve this real interview question? Count Vowel Strings in Ranges - You are given a 0-indexed array of strings words and a 2D array of integers queries.

Each query queries[i] = [li, ri] asks us to find the number of strings present in the range li to ri (both inclusive) of words that start and end with a vowel.

Return an array ans of size queries.length, where ans[i] is the answer to the ith query.

Note that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.

 

Example 1:


Input: words = [""aba"",""bcb"",""ece"",""aa"",""e""], queries = [[0,2],[1,4],[1,1]]
Output: [2,3,0]
Explanation: The strings starting and ending with a vowel are ""aba"", ""ece"", ""aa"" and ""e"".
The answer to the query [0,2] is 2 (strings ""aba"" and ""ece"").
to query [1,4] is 3 (strings ""ece"", ""aa"", ""e"").
to query [1,1] is 0.
We return [2,3,0].


Example 2:


Input: words = [""a"",""e"",""i""], queries = [[0,2],[0,1],[2,2]]
Output: [3,2,1]
Explanation: Every string satisfies the conditions, so we return [3,2,1].

 

Constraints:

 * 1 <= words.length <= 105
 * 1 <= words[i].length <= 40
 * words[i] consists only of lowercase English letters.
 * sum(words[i].length) <= 3 * 105
 * 1 <= queries.length <= 105
 * 0 <= li <= ri < words.length",Solutions (388),313
FALSE,0,0,2690,,House Robber IV,house-robber-iv,FALSE,10100,25443,2560,FALSE,2,"Can you solve this real interview question? House Robber IV - There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he refuses to steal from adjacent homes.

The capability of the robber is the maximum amount of money he steals from one house of all the houses he robbed.

You are given an integer array nums representing how much money is stashed in each house. More formally, the ith house from the left has nums[i] dollars.

You are also given an integer k, representing the minimum number of houses the robber will steal from. It is always possible to steal at least k houses.

Return the minimum capability of the robber out of all the possible ways to steal at least k houses.

 

Example 1:


Input: nums = [2,3,5,9], k = 2
Output: 5
Explanation: 
There are three ways to rob at least 2 houses:
- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.
- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.
- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.
Therefore, we return min(5, 9, 9) = 5.


Example 2:


Input: nums = [2,7,9,3,1], k = 2
Output: 2
Explanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109
 * 1 <= k <= (nums.length + 1)/2",Solutions (149),592
FALSE,0,0,2689,,Rearranging Fruits,rearranging-fruits,FALSE,6244,18226,2561,FALSE,3,"Can you solve this real interview question? Rearranging Fruits - You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays basket1 and basket2 representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want:

 * Chose two indices i and j, and swap the ith fruit of basket1 with the jth fruit of basket2.
 * The cost of the swap is min(basket1[i],basket2[j]).

Two baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.

Return the minimum cost to make both the baskets equal or -1 if impossible.

 

Example 1:


Input: basket1 = [4,2,2,2], basket2 = [1,4,1,2]
Output: 1
Explanation: Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal.


Example 2:


Input: basket1 = [2,3,4,1], basket2 = [3,2,5,1]
Output: -1
Explanation: It can be shown that it is impossible to make both the baskets equal.


 

Constraints:

 * basket1.length == bakste2.length
 * 1 <= basket1.length <= 105
 * 1 <= basket1[i],basket2[i] <= 109",Solutions (106),283
FALSE,0,0,2682,,Count Increasing Quadruplets,count-increasing-quadruplets,FALSE,4761,15175,2552,FALSE,3,"Can you solve this real interview question? Count Increasing Quadruplets - Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.

A quadruplet (i, j, k, l) is increasing if:

 * 0 <= i < j < k < l < n, and
 * nums[i] < nums[k] < nums[j] < nums[l].

 

Example 1:


Input: nums = [1,3,2,4,5]
Output: 2
Explanation: 
- When i = 0, j = 1, k = 2, and l = 3, nums[i] < nums[k] < nums[j] < nums[l].
- When i = 0, j = 1, k = 2, and l = 4, nums[i] < nums[k] < nums[j] < nums[l]. 
There are no other quadruplets, so we return 2.


Example 2:


Input: nums = [1,2,3,4]
Output: 0
Explanation: There exists only one quadruplet with i = 0, j = 1, k = 2, l = 3, but since nums[j] < nums[k], we return 0.


 

Constraints:

 * 4 <= nums.length <= 4000
 * 1 <= nums[i] <= nums.length
 * All the integers of nums are unique. nums is a permutation.",Solutions (71),248
FALSE,0,0,2681,put-marbles-in-bags,Put Marbles in Bags,put-marbles-in-bags,FALSE,8691,16445,2551,FALSE,3,"Can you solve this real interview question? Put Marbles in Bags - You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.

Divide the marbles into the k bags according to the following rules:

 * No bag is empty.
 * If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.
 * If a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].

The score after distributing the marbles is the sum of the costs of all the k bags.

Return the difference between the maximum and minimum scores among marble distributions.

 

Example 1:


Input: weights = [1,3,5,1], k = 2
Output: 4
Explanation: 
The distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. 
The distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. 
Thus, we return their difference 10 - 6 = 4.


Example 2:


Input: weights = [1, 3], k = 2
Output: 0
Explanation: The only distribution possible is [1],[3]. 
Since both the maximal and minimal score are the same, we return 0.


 

Constraints:

 * 1 <= k <= weights.length <= 105
 * 1 <= weights[i] <= 109",Solutions (143),485
FALSE,0,0,2680,,Count Collisions of Monkeys on a Polygon,count-collisions-of-monkeys-on-a-polygon,FALSE,14642,55212,2550,FALSE,2,"Can you solve this real interview question? Count Collisions of Monkeys on a Polygon - There is a regular convex polygon with n vertices. The vertices are labeled from 0 to n - 1 in a clockwise direction, and each vertex has exactly one monkey. The following figure shows a convex polygon of 6 vertices.

[https://assets.leetcode.com/uploads/2023/01/22/hexagon.jpg]

Each monkey moves simultaneously to a neighboring vertex. A neighboring vertex for a vertex i can be:

 * the vertex (i + 1) % n in the clockwise direction, or
 * the vertex (i - 1 + n) % n in the counter-clockwise direction.

A collision happens if at least two monkeys reside on the same vertex after the movement or intersect on an edge.

Return the number of ways the monkeys can move so that at least one collision happens. Since the answer may be very large, return it modulo 109 + 7.

Note that each monkey can only move once.

 

Example 1:


Input: n = 3
Output: 6
Explanation: There are 8 total possible movements.
Two ways such that they collide at some point are:
- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.
- Monkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide.
It can be shown 6 total movements result in a collision.


Example 2:


Input: n = 4
Output: 14
Explanation: It can be shown that there are 14 ways for the monkeys to collide.


 

Constraints:

 * 3 <= n <= 109",Solutions (165),139
FALSE,0,0,2679,,Count Distinct Numbers on Board,count-distinct-numbers-on-board,FALSE,26231,43816,2549,FALSE,1,"Can you solve this real interview question? Count Distinct Numbers on Board - You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:

 * For each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.
 * Then, place those numbers on the board.

Return the number of distinct integers present on the board after 109 days have elapsed.

Note:

 * Once a number is placed on the board, it will remain on it until the end.
 * % stands for the modulo operation. For example, 14 % 3 is 2.

 

Example 1:


Input: n = 5
Output: 4
Explanation: Initially, 5 is present on the board. 
The next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. 
After that day, 3 will be added to the board because 4 % 3 == 1. 
At the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. 


Example 2:


Input: n = 3
Output: 2
Explanation: 
Since 3 % 2 == 1, 2 will be added to the board. 
After a billion days, the only two distinct numbers on the board are 2 and 3. 


 

Constraints:

 * 1 <= n <= 100",Solutions (341),157
FALSE,0,0,2673,,Maximize Win From Two Segments,maximize-win-from-two-segments,FALSE,6404,21187,2555,FALSE,2,"Can you solve this real interview question? Maximize Win From Two Segments - There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the ith prize. There could be different prizes at the same position on the line. You are also given an integer k.

You are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.

 * For example if k = 2, you can choose segments [1, 3] and [2, 4], and you will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or 2 <= prizePositions[i] <= 4.

Return the maximum number of prizes you can win if you choose the two segments optimally.

 

Example 1:


Input: prizePositions = [1,1,2,2,3,3,5], k = 2
Output: 7
Explanation: In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].


Example 2:


Input: prizePositions = [1,2,3,4], k = 0
Output: 2
Explanation: For this example, one choice for the segments is [3, 3] and [4, 4], and you will be able to get 2 prizes. 


 

Constraints:

 * 1 <= prizePositions.length <= 105
 * 1 <= prizePositions[i] <= 109
 * 0 <= k <= 109
 * prizePositions is sorted in non-decreasing order.

 ",Solutions (123),384
FALSE,0,0,2665,,Minimum Time to Repair Cars,minimum-time-to-repair-cars,FALSE,7218,16604,2594,FALSE,2,"Can you solve this real interview question? Minimum Time to Repair Cars - You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes.

You are also given an integer cars representing the total number of cars waiting in the garage to be repaired.

Return the minimum time taken to repair all the cars.

Note: All the mechanics can repair the cars simultaneously.

 

Example 1:


Input: ranks = [4,2,3,1], cars = 10
Output: 16
Explanation: 
- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.
- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.
- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.
- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​


Example 2:


Input: ranks = [5,1,8], cars = 6
Output: 16
Explanation: 
- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.
- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​


 

Constraints:

 * 1 <= ranks.length <= 105
 * 1 <= ranks[i] <= 100
 * 1 <= cars <= 106",Solutions (198),304
FALSE,0,0,2664,,Maximize Greatness of an Array,maximize-greatness-of-an-array,FALSE,12178,22067,2592,FALSE,2,"Can you solve this real interview question? Maximize Greatness of an Array - You are given a 0-indexed integer array nums. You are allowed to permute nums into a new array perm of your choosing.

We define the greatness of nums be the number of indices 0 <= i < nums.length for which perm[i] > nums[i].

Return the maximum possible greatness you can achieve after permuting nums.

 

Example 1:


Input: nums = [1,3,5,2,1,3,1]
Output: 4
Explanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].
At indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we return 4.

Example 2:


Input: nums = [1,2,3,4]
Output: 3
Explanation: We can prove the optimal perm is [2,3,4,1].
At indices = 0, 1, and 2, perm[i] > nums[i]. Hence, we return 3.


 

Constraints:

 * 1 <= nums.length <= 105
 * 0 <= nums[i] <= 109",Solutions (257),233
FALSE,0,0,2663,,Distribute Money to Maximum Children,distribute-money-to-maximum-children,FALSE,13539,75207,2591,FALSE,1,"Can you solve this real interview question? Distribute Money to Maximum Children - You are given an integer money denoting the amount of money (in dollars) that you have and another integer children denoting the number of children that you must distribute the money to.

You have to distribute the money according to the following rules:

 * All money must be distributed.
 * Everyone must receive at least 1 dollar.
 * Nobody receives 4 dollars.

Return the maximum number of children who may receive exactly 8 dollars if you distribute the money according to the aforementioned rules. If there is no way to distribute the money, return -1.

 

Example 1:


Input: money = 20, children = 3
Output: 1
Explanation: 
The maximum number of children with 8 dollars will be 1. One of the ways to distribute the money is:
- 8 dollars to the first child.
- 9 dollars to the second child. 
- 3 dollars to the third child.
It can be proven that no distribution exists such that number of children getting 8 dollars is greater than 1.


Example 2:


Input: money = 16, children = 2
Output: 2
Explanation: Each child can be given 8 dollars.


 

Constraints:

 * 1 <= money <= 200
 * 2 <= children <= 30",Solutions (224),116
FALSE,0,0,2662,,Check Knight Tour Configuration,check-knight-tour-configuration,FALSE,14955,24533,2596,FALSE,2,"Can you solve this real interview question? Check Knight Tour Configuration - There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.

You are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.

Return true if grid represents a valid configuration of the knight's movements or false otherwise.

Note that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.

[https://assets.leetcode.com/uploads/2018/10/12/knight.png]

 

Example 1:

[https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-5.png]


Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
Output: true
Explanation: The above diagram represents the grid. It can be shown that it is a valid configuration.


Example 2:

[https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-6.png]


Input: grid = [[0,3,6],[5,8,1],[2,7,4]]
Output: false
Explanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.


 

Constraints:

 * n == grid.length == grid[i].length
 * 3 <= n <= 7
 * 0 <= grid[row][col] < n * n
 * All integers in grid are unique.",Solutions (352),193
FALSE,0,0,2661,,Smallest Missing Non-negative Integer After Operations,smallest-missing-non-negative-integer-after-operations,FALSE,8047,21160,2598,FALSE,2,"Can you solve this real interview question? Smallest Missing Non-negative Integer After Operations - You are given a 0-indexed integer array nums and an integer value.

In one operation, you can add or subtract value from any element of nums.

 * For example, if nums = [1,2,3] and value = 2, you can choose to subtract value from nums[0] to make nums = [-1,2,3].

The MEX (minimum excluded) of an array is the smallest missing non-negative integer in it.

 * For example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.

Return the maximum MEX of nums after applying the mentioned operation any number of times.

 

Example 1:


Input: nums = [1,-10,7,13,6,8], value = 5
Output: 4
Explanation: One can achieve this result by applying the following operations:
- Add value to nums[1] twice to make nums = [1,0,7,13,6,8]
- Subtract value from nums[2] once to make nums = [1,0,2,13,6,8]
- Subtract value from nums[3] twice to make nums = [1,0,2,3,6,8]
The MEX of nums is 4. It can be shown that 4 is the maximum MEX we can achieve.


Example 2:


Input: nums = [1,-10,7,13,6,8], value = 7
Output: 2
Explanation: One can achieve this result by applying the following operation:
- subtract value from nums[2] once to make nums = [1,-10,0,13,6,8]
The MEX of nums is 2. It can be shown that 2 is the maximum MEX we can achieve.


 

Constraints:

 * 1 <= nums.length, value <= 105
 * -109 <= nums[i] <= 109",Solutions (196),225
FALSE,0,0,2659,,Number of Even and Odd Bits,number-of-even-and-odd-bits,FALSE,20784,29944,2595,FALSE,1,"Can you solve this real interview question? Number of Even and Odd Bits - You are given a positive integer n.

Let even denote the number of even indices in the binary representation of n (0-indexed) with value 1.

Let odd denote the number of odd indices in the binary representation of n (0-indexed) with value 1.

Return an integer array answer where answer = [even, odd].

 

Example 1:


Input: n = 17
Output: [2,0]
Explanation: The binary representation of 17 is 10001. 
It contains 1 on the 0th and 4th indices. 
There are 2 even and 0 odd indices.


Example 2:


Input: n = 2
Output: [0,1]
Explanation: The binary representation of 2 is 10.
It contains 1 on the 1st index. 
There are 0 even and 1 odd indices.


 

Constraints:

 * 1 <= n <= 1000",Solutions (352),127
FALSE,0,0,2657,,Minimum Time to Complete All Tasks,minimum-time-to-complete-all-tasks,FALSE,5232,14413,2589,FALSE,3,"Can you solve this real interview question? Minimum Time to Complete All Tasks - There is a computer that can run an unlimited number of tasks at the same time. You are given a 2D integer array tasks where tasks[i] = [starti, endi, durationi] indicates that the ith task should run for a total of durationi seconds (not necessarily continuous) within the inclusive time range [starti, endi].

You may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.

Return the minimum time during which the computer should be turned on to complete all tasks.

 

Example 1:


Input: tasks = [[2,3,1],[4,5,1],[1,5,2]]
Output: 2
Explanation: 
- The first task can be run in the inclusive time range [2, 2].
- The second task can be run in the inclusive time range [5, 5].
- The third task can be run in the two inclusive time ranges [2, 2] and [5, 5].
The computer will be on for a total of 2 seconds.


Example 2:


Input: tasks = [[1,3,2],[2,5,3],[5,6,2]]
Output: 4
Explanation: 
- The first task can be run in the inclusive time range [2, 3].
- The second task can be run in the inclusive time ranges [2, 3] and [5, 5].
- The third task can be run in the two inclusive time range [5, 6].
The computer will be on for a total of 4 seconds.


 

Constraints:

 * 1 <= tasks.length <= 2000
 * tasks[i].length == 3
 * 1 <= starti, endi <= 2000
 * 1 <= durationi <= endi - starti + 1",Solutions (85),297
FALSE,0,0,2656,,Count the Number of Beautiful Subarrays,count-the-number-of-beautiful-subarrays,FALSE,11638,23631,2588,FALSE,2,"Can you solve this real interview question? Count the Number of Beautiful Subarrays - You are given a 0-indexed integer array nums. In one operation, you can:

 * Choose two different indices i and j such that 0 <= i, j < nums.length.
 * Choose a non-negative integer k such that the kth bit (0-indexed) in the binary representation of nums[i] and nums[j] is 1.
 * Subtract 2k from nums[i] and nums[j].

A subarray is beautiful if it is possible to make all of its elements equal to 0 after applying the above operation any number of times.

Return the number of beautiful subarrays in the array nums.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: nums = [4,3,1,2,4]
Output: 2
Explanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and [4,3,1,2,4].
- We can make all elements in the subarray [3,1,2] equal to 0 in the following way:
  - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers. The subarray becomes [1, 1, 0].
  - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 0, 0].
- We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the following way:
  - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both numbers. The subarray becomes [0, 3, 1, 2, 0].
  - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 2, 0, 2, 0].
  - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both numbers. The subarray becomes [0, 0, 0, 0, 0].


Example 2:


Input: nums = [1,10,4]
Output: 0
Explanation: There are no beautiful subarrays in nums.


 

Constraints:

 * 1 <= nums.length <= 105
 * 0 <= nums[i] <= 106",Solutions (171),319
FALSE,0,0,2655,,Rearrange Array to Maximize Prefix Score,rearrange-array-to-maximize-prefix-score,FALSE,20280,51494,2587,FALSE,2,"Can you solve this real interview question? Rearrange Array to Maximize Prefix Score - You are given a 0-indexed integer array nums. You can rearrange the elements of nums to any order (including the given order).

Let prefix be the array containing the prefix sums of nums after rearranging it. In other words, prefix[i] is the sum of the elements from 0 to i in nums after rearranging it. The score of nums is the number of positive integers in the array prefix.

Return the maximum score you can achieve.

 

Example 1:


Input: nums = [2,-1,0,1,-3,3,-3]
Output: 6
Explanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].
prefix = [2,5,6,5,2,2,-1], so the score is 6.
It can be shown that 6 is the maximum score we can obtain.


Example 2:


Input: nums = [-2,-3,0]
Output: 0
Explanation: Any rearrangement of the array will result in a score of 0.


 

Constraints:

 * 1 <= nums.length <= 105
 * -106 <= nums[i] <= 106",Solutions (333),188
FALSE,0,0,2654,,Count the Number of Vowel Strings in Range,count-the-number-of-vowel-strings-in-range,FALSE,25081,32092,2586,FALSE,1,"Can you solve this real interview question? Count the Number of Vowel Strings in Range - You are given a 0-indexed array of string words and two integers left and right.

A string is called a vowel string if it starts with a vowel character and ends with a vowel character where vowel characters are 'a', 'e', 'i', 'o', and 'u'.

Return the number of vowel strings words[i] where i belongs to the inclusive range [left, right].

 

Example 1:


Input: words = [""are"",""amy"",""u""], left = 0, right = 2
Output: 2
Explanation: 
- ""are"" is a vowel string because it starts with 'a' and ends with 'e'.
- ""amy"" is not a vowel string because it does not end with a vowel.
- ""u"" is a vowel string because it starts with 'u' and ends with 'u'.
The number of vowel strings in the mentioned range is 2.


Example 2:


Input: words = [""hey"",""aeo"",""mu"",""ooo"",""artro""], left = 1, right = 4
Output: 3
Explanation: 
- ""aeo"" is a vowel string because it starts with 'a' and ends with 'o'.
- ""mu"" is not a vowel string because it does not start with a vowel.
- ""ooo"" is a vowel string because it starts with 'o' and ends with 'o'.
- ""artro"" is a vowel string because it starts with 'a' and ends with 'o'.
The number of vowel strings in the mentioned range is 3.


 

Constraints:

 * 1 <= words.length <= 1000
 * 1 <= words[i].length <= 10
 * words[i] consists of only lowercase English letters.
 * 0 <= left <= right < words.length",Solutions (452),163
FALSE,0,0,2652,,Count Number of Possible Root Nodes,count-number-of-possible-root-nodes,FALSE,3226,6699,2581,FALSE,3,"Can you solve this real interview question? Count Number of Possible Root Nodes - Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

Alice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:

 * Chooses two distinct integers u and v such that there exists an edge [u, v] in the tree.
 * He tells Alice that u is the parent of v in the tree.

Bob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.

Alice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.

Given the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/12/19/ex-1.png]


Input: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3
Output: 3
Explanation: 
Root = 0, correct guesses = [1,3], [0,1], [2,4]
Root = 1, correct guesses = [1,3], [1,0], [2,4]
Root = 2, correct guesses = [1,3], [1,0], [2,4]
Root = 3, correct guesses = [1,0], [2,4]
Root = 4, correct guesses = [1,3], [1,0]
Considering 0, 1, or 2 as root node leads to 3 correct guesses.



Example 2:

[https://assets.leetcode.com/uploads/2022/12/19/ex-2.png]


Input: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1
Output: 5
Explanation: 
Root = 0, correct guesses = [3,4]
Root = 1, correct guesses = [1,0], [3,4]
Root = 2, correct guesses = [1,0], [2,1], [3,4]
Root = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]
Root = 4, correct guesses = [1,0], [2,1], [3,2]
Considering any node as root will give at least 1 correct guess. 



 

Constraints:

 * edges.length == n - 1
 * 2 <= n <= 105
 * 1 <= guesses.length <= 105
 * 0 <= ai, bi, uj, vj <= n - 1
 * ai != bi
 * uj != vj
 * edges represents a valid tree.
 * guesses[j] is an edge of the tree.
 * guesses is unique.
 * 0 <= k <= guesses.length",Solutions (89),189
FALSE,0,0,2651,,Count Ways to Group Overlapping Ranges,count-ways-to-group-overlapping-ranges,FALSE,11010,31688,2580,FALSE,2,"Can you solve this real interview question? Count Ways to Group Overlapping Ranges - You are given a 2D integer array ranges where ranges[i] = [starti, endi] denotes that all integers between starti and endi (both inclusive) are contained in the ith range.

You are to split ranges into two (possibly empty) groups such that:

 * Each range belongs to exactly one group.
 * Any two overlapping ranges must belong to the same group.

Two ranges are said to be overlapping if there exists at least one integer that is present in both ranges.

 * For example, [1, 3] and [2, 5] are overlapping because 2 and 3 occur in both ranges.

Return the total number of ways to split ranges into two groups. Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:


Input: ranges = [[6,10],[5,15]]
Output: 2
Explanation: 
The two ranges are overlapping, so they must be in the same group.
Thus, there are two possible ways:
- Put both the ranges together in group 1.
- Put both the ranges together in group 2.


Example 2:


Input: ranges = [[1,3],[10,20],[2,5],[4,8]]
Output: 4
Explanation: 
Ranges [1,3], and [2,5] are overlapping. So, they must be in the same group.
Again, ranges [2,5] and [4,8] are also overlapping. So, they must also be in the same group. 
Thus, there are four possible ways to group them:
- All the ranges in group 1.
- All the ranges in group 2.
- Ranges [1,3], [2,5], and [4,8] in group 1 and [10,20] in group 2.
- Ranges [1,3], [2,5], and [4,8] in group 2 and [10,20] in group 1.


 

Constraints:

 * 1 <= ranges.length <= 105
 * ranges[i].length == 2
 * 0 <= starti <= endi <= 109",Solutions (194),220
FALSE,0,0,2650,,Split With Minimum Sum,split-with-minimum-sum,FALSE,18133,26051,2578,FALSE,1,"Can you solve this real interview question? Split With Minimum Sum - Given a positive integer num, split it into two non-negative integers num1 and num2 such that:

 * The concatenation of num1 and num2 is a permutation of num.
   * In other words, the sum of the number of occurrences of each digit in num1 and num2 is equal to the number of occurrences of that digit in num.
 * num1 and num2 can contain leading zeros.

Return the minimum possible sum of num1 and num2.

Notes:

 * It is guaranteed that num does not contain any leading zeros.
 * The order of occurrence of the digits in num1 and num2 may differ from the order of occurrence of num.

 

Example 1:


Input: num = 4325
Output: 59
Explanation: We can split 4325 so that num1 is 24 and num2 is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.


Example 2:


Input: num = 687
Output: 75
Explanation: We can split 687 so that num1 is 68 and num2 is 7, which would give an optimal sum of 75.


 

Constraints:

 * 10 <= num <= 109",Solutions (351),178
FALSE,0,0,2649,,Count Total Number of Colored Cells,count-total-number-of-colored-cells,FALSE,17731,31001,2579,FALSE,2,"Can you solve this real interview question? Count Total Number of Colored Cells - There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes:

 * At the first minute, color any arbitrary unit cell blue.
 * Every minute thereafter, color blue every uncolored cell that touches a blue cell.

Below is a pictorial representation of the state of the grid after minutes 1, 2, and 3.

[https://assets.leetcode.com/uploads/2023/01/10/example-copy-2.png]

Return the number of colored cells at the end of n minutes.

 

Example 1:


Input: n = 1
Output: 1
Explanation: After 1 minute, there is only 1 blue cell, so we return 1.


Example 2:


Input: n = 2
Output: 5
Explanation: After 2 minutes, there are 4 colored cells on the boundary and 1 in the center, so we return 5. 


 

Constraints:

 * 1 <= n <= 105",Solutions (433),190
FALSE,0,0,2648,,Number of Ways to Earn Points,number-of-ways-to-earn-points,FALSE,9135,15261,2585,FALSE,3,"Can you solve this real interview question? Number of Ways to Earn Points - There is a test that has n types of questions. You are given an integer target and a 0-indexed 2D integer array types where types[i] = [counti, marksi] indicates that there are counti questions of the ith type, and each one of them is worth marksi points.

Return the number of ways you can earn exactly target points in the exam. Since the answer may be too large, return it modulo 109 + 7.

Note that questions of the same type are indistinguishable.

 * For example, if there are 3 questions of the same type, then solving the 1st and 2nd questions is the same as solving the 1st and 3rd questions, or the 2nd and 3rd questions.

 

Example 1:


Input: target = 6, types = [[6,1],[3,2],[2,3]]
Output: 7
Explanation: You can earn 6 points in one of the seven ways:
- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6
- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6
- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6
- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6
- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6
- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6
- Solve 2 questions of the 2nd type: 3 + 3 = 6


Example 2:


Input: target = 5, types = [[50,1],[50,2],[50,5]]
Output: 4
Explanation: You can earn 5 points in one of the four ways:
- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5
- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5
- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5
- Solve 1 question of the 2nd type: 5


Example 3:


Input: target = 18, types = [[6,1],[3,2],[2,3]]
Output: 1
Explanation: You can only earn 18 points by answering all questions.


 

Constraints:

 * 1 <= target <= 1000
 * n == types.length
 * 1 <= n <= 50
 * types[i].length == 2
 * 1 <= counti, marksi <= 50",Solutions (147),279
FALSE,0,0,2647,,Split the Array to Make Coprime Products,split-the-array-to-make-coprime-products,FALSE,8233,37527,2584,FALSE,3,"Can you solve this real interview question? Split the Array to Make Coprime Products - You are given a 0-indexed integer array nums of length n.

A split at an index i where 0 <= i <= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.

 * For example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime. A split at the index i = 2 is not valid because i == n - 1.

Return the smallest index i at which the array can be split validly or -1 if there is no such split.

Two values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/12/14/second.PNG]


Input: nums = [4,7,8,15,3,5]
Output: 2
Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.
The only valid split is at index 2.


Example 2:

[https://assets.leetcode.com/uploads/2022/12/14/capture.PNG]


Input: nums = [4,7,15,8,3,5]
Output: -1
Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.
There is no valid split.


 

Constraints:

 * n == nums.length
 * 1 <= n <= 104
 * 1 <= nums[i] <= 106",Solutions (143),240
FALSE,0,0,2646,,Kth Largest Sum in a Binary Tree,kth-largest-sum-in-a-binary-tree,FALSE,18560,39777,2583,FALSE,2,"Can you solve this real interview question? Kth Largest Sum in a Binary Tree - You are given the root of a binary tree and a positive integer k.

The level sum in the tree is the sum of the values of the nodes that are on the same level.

Return the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.

Note that two nodes are on the same level if they have the same distance from the root.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png]


Input: root = [5,8,9,2,1,3,7,4,6], k = 2
Output: 13
Explanation: The level sums are the following:
- Level 1: 5.
- Level 2: 8 + 9 = 17.
- Level 3: 2 + 1 + 3 + 7 = 13.
- Level 4: 4 + 6 = 10.
The 2nd largest level sum is 13.


Example 2:

[https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png]


Input: root = [1,2,null,3], k = 1
Output: 3
Explanation: The largest level sum is 3.


 

Constraints:

 * The number of nodes in the tree is n.
 * 2 <= n <= 105
 * 1 <= Node.val <= 106
 * 1 <= k <= n",Solutions (392),225
FALSE,0,0,2645,,Pass the Pillow,pass-the-pillow,FALSE,22827,49310,2582,FALSE,1,"Can you solve this real interview question? Pass the Pillow - There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.

 * For example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.

Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.

 

Example 1:


Input: n = 4, time = 5
Output: 2
Explanation: People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.
Afer five seconds, the pillow is given to the 2nd person.


Example 2:


Input: n = 3, time = 2
Output: 3
Explanation: People pass the pillow in the following way: 1 -> 2 -> 3.
Afer two seconds, the pillow is given to the 3rd person.


 

Constraints:

 * 2 <= n <= 1000
 * 1 <= time <= 1000",Solutions (425),249
FALSE,0,0,2642,,Time to Cross a Bridge,time-to-cross-a-bridge,FALSE,2979,5554,2532,FALSE,3,"Can you solve this real interview question? Time to Cross a Bridge - There are k workers who want to move n boxes from an old warehouse to a new one. You are given the two integers n and k, and a 2D integer array time of size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].

The warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all k workers are waiting on the left side of the bridge. To move the boxes, the ith worker (0-indexed) can :

 * Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in leftToRighti minutes.
 * Pick a box from the old warehouse and return to the bridge in pickOldi minutes. Different workers can pick up their boxes simultaneously.
 * Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in rightToLefti minutes.
 * Put the box in the new warehouse and return to the bridge in putNewi minutes. Different workers can put their boxes simultaneously.

A worker i is less efficient than a worker j if either condition is met:

 * leftToRighti + rightToLefti > leftToRightj + rightToLeftj
 * leftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j

The following rules regulate the movement of the workers through the bridge :

 * If a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.
 * If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.
 * If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.

Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.

 

Example 1:


Input: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]
Output: 6
Explanation: 
From 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.
From 1 to 2: worker 2 picks up a box from the old warehouse.
From 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.
From 6 to 7: worker 2 puts a box at the new warehouse.
The whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.


Example 2:


Input: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]
Output: 50
Explanation: 
From 0  to 10: worker 1 crosses the bridge from the left bank to the right bank.
From 10 to 20: worker 1 picks up a box from the old warehouse.
From 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.
From 11 to 20: worker 0 picks up a box from the old warehouse.
From 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.
From 30 to 40: worker 1 puts a box at the new warehouse.
From 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.
From 31 to 39: worker 0 puts a box at the new warehouse.
From 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.
From 40 to 49: worker 0 picks up a box from the old warehouse.
From 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.
From 50 to 58: worker 0 puts a box at the new warehouse.
The whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.


 

Constraints:

 * 1 <= n, k <= 104
 * time.length == k
 * time[i].length == 4
 * 1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000",Solutions (91),86
FALSE,0,0,2641,,Disconnect Path in a Binary Matrix by at Most One Flip,disconnect-path-in-a-binary-matrix-by-at-most-one-flip,FALSE,8320,29228,2556,FALSE,2,"Can you solve this real interview question? Disconnect Path in a Binary Matrix by at Most One Flip - You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1. The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).

You can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).

Return true if it is possible to make the matrix disconnect or false otherwise.

Note that flipping a cell changes its value from 0 to 1 or from 1 to 0.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/12/07/yetgrid2drawio.png]


Input: grid = [[1,1,1],[1,0,0],[1,1,1]]
Output: true
Explanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.


Example 2:

[https://assets.leetcode.com/uploads/2022/12/07/yetgrid3drawio.png]


Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
Output: false
Explanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 1000
 * 1 <= m * n <= 105
 * grid[i][j] is either 0 or 1.
 * grid[0][0] == grid[m - 1][n - 1] == 1",Solutions (124),365
FALSE,0,0,2640,,Maximum Number of Integers to Choose From a Range I,maximum-number-of-integers-to-choose-from-a-range-i,FALSE,21035,40096,2554,FALSE,2,"Can you solve this real interview question? Maximum Number of Integers to Choose From a Range I - You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:

 * The chosen integers have to be in the range [1, n].
 * Each integer can be chosen at most once.
 * The chosen integers should not be in the array banned.
 * The sum of the chosen integers should not exceed maxSum.

Return the maximum number of integers you can choose following the mentioned rules.

 

Example 1:


Input: banned = [1,6,5], n = 5, maxSum = 6
Output: 2
Explanation: You can choose the integers 2 and 4.
2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.


Example 2:


Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1
Output: 0
Explanation: You cannot choose any integer while following the mentioned conditions.


Example 3:


Input: banned = [11], n = 7, maxSum = 50
Output: 7
Explanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7.
They are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum.


 

Constraints:

 * 1 <= banned.length <= 104
 * 1 <= banned[i], n <= 104
 * 1 <= maxSum <= 109",Solutions (346),197
FALSE,0,0,2639,,Separate the Digits in an Array,separate-the-digits-in-an-array,FALSE,31848,40042,2553,FALSE,1,"Can you solve this real interview question? Separate the Digits in an Array - Given an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums.

To separate the digits of an integer is to get all the digits it has in the same order.

 * For example, for the integer 10921, the separation of its digits is [1,0,9,2,1].

 

Example 1:


Input: nums = [13,25,83,77]
Output: [1,3,2,5,8,3,7,7]
Explanation: 
- The separation of 13 is [1,3].
- The separation of 25 is [2,5].
- The separation of 83 is [8,3].
- The separation of 77 is [7,7].
answer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order.


Example 2:


Input: nums = [7,1,3,9]
Output: [7,1,3,9]
Explanation: The separation of each integer in nums is itself.
answer = [7,1,3,9].


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i] <= 105",Solutions (601),260
FALSE,0,0,2636,,Maximum Subsequence Score,maximum-subsequence-score,FALSE,7820,20548,2542,FALSE,2,"Can you solve this real interview question? Maximum Subsequence Score - You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.

For chosen indices i0, i1, ..., ik - 1, your score is defined as:

 * The sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.
 * It can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).

Return the maximum possible score.

A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.

 

Example 1:


Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
Output: 12
Explanation: 
The four possible subsequence scores are:
- We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.
- We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. 
- We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. 
- We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.
Therefore, we return the max score, which is 12.


Example 2:


Input: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1
Output: 30
Explanation: 
Choosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.


 

Constraints:

 * n == nums1.length == nums2.length
 * 1 <= n <= 105
 * 0 <= nums1[i], nums2[j] <= 105
 * 1 <= k <= n",Solutions (146),447
FALSE,0,0,2635,,Check if Point Is Reachable,check-if-point-is-reachable,FALSE,4615,10883,2543,FALSE,3,"Can you solve this real interview question? Check if Point Is Reachable - There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.

In one step, you can move from point (x, y) to any one of the following points:

 * (x, y - x)
 * (x - y, y)
 * (2 * x, y)
 * (x, 2 * y)

Given two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.

 

Example 1:


Input: targetX = 6, targetY = 9
Output: false
Explanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.


Example 2:


Input: targetX = 4, targetY = 7
Output: true
Explanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7).


 

Constraints:

 * 1 <= targetX, targetY <= 109",Solutions (96),180
FALSE,0,0,2634,,Minimum Common Value,minimum-common-value,FALSE,30390,59018,2540,FALSE,1,"Can you solve this real interview question? Minimum Common Value - Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.

Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.

 

Example 1:


Input: nums1 = [1,2,3], nums2 = [2,4]
Output: 2
Explanation: The smallest element common to both arrays is 2, so we return 2.


Example 2:


Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
Output: 2
Explanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.


 

Constraints:

 * 1 <= nums1.length, nums2.length <= 105
 * 1 <= nums1[i], nums2[j] <= 109
 * Both nums1 and nums2 are sorted in non-decreasing order.",Solutions (551),298
FALSE,0,0,2633,,Minimum Cost to Split an Array,minimum-cost-to-split-an-array,FALSE,8406,21578,2547,FALSE,3,"Can you solve this real interview question? Minimum Cost to Split an Array - You are given an integer array nums and an integer k.

Split the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.

Let trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.

 * For example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].

The importance value of a subarray is k + trimmed(subarray).length.

 * For example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.

Return the minimum possible cost of a split of nums.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: nums = [1,2,1,2,1,3,3], k = 2
Output: 8
Explanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].
The importance value of [1,2] is 2 + (0) = 2.
The importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.
The cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.


Example 2:


Input: nums = [1,2,1,2,1], k = 2
Output: 6
Explanation: We split nums to have two subarrays: [1,2], [1,2,1].
The importance value of [1,2] is 2 + (0) = 2.
The importance value of [1,2,1] is 2 + (2) = 4.
The cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.


Example 3:


Input: nums = [1,2,1,2,1], k = 5
Output: 10
Explanation: We split nums to have one subarray: [1,2,1,2,1].
The importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.
The cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.


 

Constraints:

 * 1 <= nums.length <= 1000
 * 0 <= nums[i] < nums.length
 * 1 <= k <= 109

 ",Solutions (132),333
FALSE,0,0,2632,,Apply Bitwise Operations to Make Strings Equal,apply-bitwise-operations-to-make-strings-equal,FALSE,15090,37159,2546,FALSE,2,"Can you solve this real interview question? Apply Bitwise Operations to Make Strings Equal - You are given two 0-indexed binary strings s and target of the same length n. You can do the following operation on s any number of times:

 * Choose two different indices i and j where 0 <= i, j < n.
 * Simultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR s[j]).

For example, if s = ""0110"", you can choose i = 0 and j = 2, then simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = ""1110"".

Return true if you can make the string s equal to target, or false otherwise.

 

Example 1:


Input: s = ""1010"", target = ""0110""
Output: true
Explanation: We can do the following operations:
- Choose i = 2 and j = 0. We have now s = ""0010"".
- Choose i = 2 and j = 1. We have now s = ""0110"".
Since we can make s equal to target, we return true.


Example 2:


Input: s = ""11"", target = ""00""
Output: false
Explanation: It is not possible to make s equal to target with any number of operations.


 

Constraints:

 * n == s.length == target.length
 * 2 <= n <= 105
 * s and target consist of only the digits 0 and 1.",Solutions (239),191
FALSE,0,0,2631,,Sort the Students by Their Kth Score,sort-the-students-by-their-kth-score,FALSE,28831,33600,2545,FALSE,2,"Can you solve this real interview question? Sort the Students by Their Kth Score - There is a class with m students and n exams. You are given a 0-indexed m x n integer matrix score, where each row represents one student and score[i][j] denotes the score the ith student got in the jth exam. The matrix score contains distinct integers only.

You are also given an integer k. Sort the students (i.e., the rows of the matrix) by their scores in the kth (0-indexed) exam from the highest to the lowest.

Return the matrix after sorting it.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/11/30/example1.png]


Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
Explanation: In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.
- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.
- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.


Example 2:

[https://assets.leetcode.com/uploads/2022/11/30/example2.png]


Input: score = [[3,4],[5,6]], k = 0
Output: [[5,6],[3,4]]
Explanation: In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.
- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.


 

Constraints:

 * m == score.length
 * n == score[i].length
 * 1 <= m, n <= 250
 * 1 <= score[i][j] <= 105
 * score consists of distinct integers.
 * 0 <= k < n",Solutions (694),337
FALSE,0,0,2630,,Alternating Digit Sum,alternating-digit-sum,FALSE,32122,46161,2544,FALSE,1,"Can you solve this real interview question? Alternating Digit Sum - You are given a positive integer n. Each digit of n has a sign according to the following rules:

 * The most significant digit is assigned a positive sign.
 * Each other digit has an opposite sign to its adjacent digits.

Return the sum of all digits with their corresponding sign.

 

Example 1:


Input: n = 521
Output: 4
Explanation: (+5) + (-2) + (+1) = 4.


Example 2:


Input: n = 111
Output: 1
Explanation: (+1) + (-1) + (+1) = 1.


Example 3:


Input: n = 886996
Output: 0
Explanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.


 

Constraints:

 * 1 <= n <= 109

 ",Solutions (750),221
FALSE,0,0,2628,,Minimize the Maximum of Two Arrays,minimize-the-maximum-of-two-arrays,FALSE,4481,16850,2513,FALSE,2,"Can you solve this real interview question? Minimize the Maximum of Two Arrays - We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions:

 * arr1 contains uniqueCnt1 distinct positive integers, each of which is not divisible by divisor1.
 * arr2 contains uniqueCnt2 distinct positive integers, each of which is not divisible by divisor2.
 * No integer is present in both arr1 and arr2.

Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.

 

Example 1:


Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3
Output: 4
Explanation: 
We can distribute the first 4 natural numbers into arr1 and arr2.
arr1 = [1] and arr2 = [2,3,4].
We can see that both arrays satisfy all the conditions.
Since the maximum value is 4, we return it.


Example 2:


Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1
Output: 3
Explanation: 
Here arr1 = [1,2], and arr2 = [3] satisfy all conditions.
Since the maximum value is 3, we return it.

Example 3:


Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2
Output: 15
Explanation: 
Here, the final possible arrays can be arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6].
It can be shown that it is not possible to obtain a lower maximum satisfying all conditions. 


 

Constraints:

 * 2 <= divisor1, divisor2 <= 105
 * 1 <= uniqueCnt1, uniqueCnt2 < 109
 * 2 <= uniqueCnt1 + uniqueCnt2 <= 109",Solutions (92),253
FALSE,0,0,2627,,Difference Between Maximum and Minimum Price Sum,difference-between-maximum-and-minimum-price-sum,FALSE,5004,14310,2538,FALSE,3,"Can you solve this real interview question? Difference Between Maximum and Minimum Price Sum - There exists an undirected and initially unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

Each node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.

The price sum of a given path is the sum of the prices of all nodes lying on that path.

The tree can be rooted at any node root of your choice. The incurred cost after choosing root is the difference between the maximum and minimum price sum amongst all paths starting at root.

Return the maximum possible cost amongst all possible root choices.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/12/01/example14.png]


Input: n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]
Output: 24
Explanation: The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.
- The first path contains nodes [2,1,3,4]: the prices are [7,8,6,10], and the sum of the prices is 31.
- The second path contains the node [2] with the price [7].
The difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.


Example 2:

[https://assets.leetcode.com/uploads/2022/11/24/p1_example2.png]


Input: n = 3, edges = [[0,1],[1,2]], price = [1,1,1]
Output: 2
Explanation: The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.
- The first path contains nodes [0,1,2]: the prices are [1,1,1], and the sum of the prices is 3.
- The second path contains node [0] with a price [1].
The difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.


 

Constraints:

 * 1 <= n <= 105
 * edges.length == n - 1
 * 0 <= ai, bi <= n - 1
 * edges represents a valid tree.
 * price.length == n
 * 1 <= price[i] <= 105",Solutions (96),279
FALSE,0,0,2626,,Count the Number of Good Subarrays,count-the-number-of-good-subarrays,FALSE,11861,24705,2537,FALSE,2,"Can you solve this real interview question? Count the Number of Good Subarrays - Given an integer array nums and an integer k, return the number of good subarrays of nums.

A subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: nums = [1,1,1,1,1], k = 10
Output: 1
Explanation: The only good subarray is the array nums itself.


Example 2:


Input: nums = [3,1,4,3,2,2,4], k = 2
Output: 4
Explanation: There are 4 different good subarrays:
- [3,1,4,3,2,2] that has 2 pairs.
- [3,1,4,3,2,2,4] that has 3 pairs.
- [1,4,3,2,2,4] that has 2 pairs.
- [4,3,2,2,4] that has 2 pairs.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i], k <= 109",Solutions (217),539
FALSE,0,0,2625,,Increment Submatrices by One,increment-submatrices-by-one,FALSE,16562,34271,2536,FALSE,2,"Can you solve this real interview question? Increment Submatrices by One - You are given a positive integer n, indicating that we initially have an n x n 0-indexed integer matrix mat filled with zeroes.

You are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation:

 * Add 1 to every element in the submatrix with the top left corner (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1 to mat[x][y] for all row1i <= x <= row2i and col1i <= y <= col2i.

Return the matrix mat after performing every query.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/11/24/p2example11.png]


Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]
Output: [[1,1,0],[1,2,1],[0,1,1]]
Explanation: The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.
- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).
- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).


Example 2:

[https://assets.leetcode.com/uploads/2022/11/24/p2example22.png]


Input: n = 2, queries = [[0,0,1,1]]
Output: [[1,1],[1,1]]
Explanation: The diagram above shows the initial matrix and the matrix after the first query.
- In the first query we add 1 to every element in the matrix.


 

Constraints:

 * 1 <= n <= 500
 * 1 <= queries.length <= 104
 * 0 <= row1i <= row2i < n
 * 0 <= col1i <= col2i < n",Solutions (274),374
FALSE,0,0,2624,,Difference Between Element Sum and Digit Sum of an Array,difference-between-element-sum-and-digit-sum-of-an-array,FALSE,53047,62102,2535,FALSE,1,"Can you solve this real interview question? Difference Between Element Sum and Digit Sum of an Array - You are given a positive integer array nums.

 * The element sum is the sum of all the elements in nums.
 * The digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.

Return the absolute difference between the element sum and digit sum of nums.

Note that the absolute difference between two integers x and y is defined as |x - y|.

 

Example 1:


Input: nums = [1,15,6,3]
Output: 9
Explanation: 
The element sum of nums is 1 + 15 + 6 + 3 = 25.
The digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.
The absolute difference between the element sum and digit sum is |25 - 16| = 9.


Example 2:


Input: nums = [1,2,3,4]
Output: 0
Explanation:
The element sum of nums is 1 + 2 + 3 + 4 = 10.
The digit sum of nums is 1 + 2 + 3 + 4 = 10.
The absolute difference between the element sum and digit sum is |10 - 10| = 0.


 

Constraints:

 * 1 <= nums.length <= 2000
 * 1 <= nums[i] <= 2000",Solutions (989),359
FALSE,0,0,2621,,Find Xor-Beauty of Array,find-xor-beauty-of-array,FALSE,13637,19410,2527,FALSE,2,"Can you solve this real interview question? Find Xor-Beauty of Array - You are given a 0-indexed integer array nums.

The effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).

The xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.

Return the xor-beauty of nums.

Note that:

 * val1 | val2 is bitwise OR of val1 and val2.
 * val1 & val2 is bitwise AND of val1 and val2.

 

Example 1:


Input: nums = [1,4]
Output: 5
Explanation: 
The triplets and their corresponding effective values are listed below:
- (0,0,0) with effective value ((1 | 1) & 1) = 1
- (0,0,1) with effective value ((1 | 1) & 4) = 0
- (0,1,0) with effective value ((1 | 4) & 1) = 1
- (0,1,1) with effective value ((1 | 4) & 4) = 4
- (1,0,0) with effective value ((4 | 1) & 1) = 1
- (1,0,1) with effective value ((4 | 1) & 4) = 4
- (1,1,0) with effective value ((4 | 4) & 1) = 0
- (1,1,1) with effective value ((4 | 4) & 4) = 4 
Xor-beauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.

Example 2:


Input: nums = [15,45,20,2,34,35,5,44,32,30]
Output: 34
Explanation: The xor-beauty of the given array is 34.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (203),248
FALSE,0,0,2620,,Find Consecutive Integers from a Data Stream,find-consecutive-integers-from-a-data-stream,FALSE,15978,35334,2526,FALSE,2,"Can you solve this real interview question? Find Consecutive Integers from a Data Stream - For a stream of integers, implement a data structure that checks if the last k integers parsed in the stream are equal to value.

Implement the DataStream class:

 * DataStream(int value, int k) Initializes the object with an empty integer stream and the two integers value and k.
 * boolean consec(int num) Adds num to the stream of integers. Returns true if the last k integers are equal to value, and false otherwise. If there are less than k integers, the condition does not hold true, so returns false.

 

Example 1:


Input
[""DataStream"", ""consec"", ""consec"", ""consec"", ""consec""]
[[4, 3], [4], [4], [4], [3]]
Output
[null, false, false, true, false]

Explanation
DataStream dataStream = new DataStream(4, 3); //value = 4, k = 3 
dataStream.consec(4); // Only 1 integer is parsed, so returns False. 
dataStream.consec(4); // Only 2 integers are parsed.
                      // Since 2 is less than k, returns False. 
dataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True. 
dataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].
                      // Since 3 is not equal to value, it returns False.


 

Constraints:

 * 1 <= value, num <= 109
 * 1 <= k <= 105
 * At most 105 calls will be made to consec.",Solutions (244),188
FALSE,0,0,2619,,Categorize Box According to Criteria,categorize-box-according-to-criteria,FALSE,21685,63744,2525,FALSE,1,"Can you solve this real interview question? Categorize Box According to Criteria - Given four integers length, width, height, and mass, representing the dimensions and mass of a box, respectively, return a string representing the category of the box.

 * The box is ""Bulky"" if:
   * Any of the dimensions of the box is greater or equal to 104.
   * Or, the volume of the box is greater or equal to 109.
 * If the mass of the box is greater or equal to 100, it is ""Heavy"".
 * If the box is both ""Bulky"" and ""Heavy"", then its category is ""Both"".
 * If the box is neither ""Bulky"" nor ""Heavy"", then its category is ""Neither"".
 * If the box is ""Bulky"" but not ""Heavy"", then its category is ""Bulky"".
 * If the box is ""Heavy"" but not ""Bulky"", then its category is ""Heavy"".

Note that the volume of the box is the product of its length, width and height.

 

Example 1:


Input: length = 1000, width = 35, height = 700, mass = 300
Output: ""Heavy""
Explanation: 
None of the dimensions of the box is greater or equal to 104. 
Its volume = 24500000 <= 109. So it cannot be categorized as ""Bulky"".
However mass >= 100, so the box is ""Heavy"".
Since the box is not ""Bulky"" but ""Heavy"", we return ""Heavy"".

Example 2:


Input: length = 200, width = 50, height = 800, mass = 50
Output: ""Neither""
Explanation: 
None of the dimensions of the box is greater or equal to 104.
Its volume = 8 * 106 <= 109. So it cannot be categorized as ""Bulky"".
Its mass is also less than 100, so it cannot be categorized as ""Heavy"" either. 
Since its neither of the two above categories, we return ""Neither"".

 

Constraints:

 * 1 <= length, width, height <= 105
 * 1 <= mass <= 103",Solutions (335),134
FALSE,0,0,2618,,Maximize the Minimum Powered City,maximize-the-minimum-powered-city,FALSE,4334,13477,2528,FALSE,3,"Can you solve this real interview question? Maximize the Minimum Powered City - You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.

Each power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.

 * Note that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.

The power of a city is the total number of power stations it is being provided power from.

The government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.

Given the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.

Note that you can build the k power stations in multiple cities.

 

Example 1:


Input: stations = [1,2,4,5,0], r = 1, k = 2
Output: 5
Explanation: 
One of the optimal ways is to install both the power stations at city 1. 
So stations will become [1,4,4,5,0].
- City 0 is provided by 1 + 4 = 5 power stations.
- City 1 is provided by 1 + 4 + 4 = 9 power stations.
- City 2 is provided by 4 + 4 + 5 = 13 power stations.
- City 3 is provided by 5 + 4 = 9 power stations.
- City 4 is provided by 5 + 0 = 5 power stations.
So the minimum power of a city is 5.
Since it is not possible to obtain a larger power, we return 5.


Example 2:


Input: stations = [4,4,4,4], r = 0, k = 3
Output: 4
Explanation: 
It can be proved that we cannot make the minimum power of a city greater than 4.


 

Constraints:

 * n == stations.length
 * 1 <= n <= 105
 * 0 <= stations[i] <= 105
 * 0 <= r <= n - 1
 * 0 <= k <= 109",Solutions (91),353
FALSE,0,0,2616,,Maximal Score After Applying K Operations,maximal-score-after-applying-k-operations,FALSE,20924,48286,2530,FALSE,2,"Can you solve this real interview question? Maximal Score After Applying K Operations - You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.

In one operation:

 1. choose an index i such that 0 <= i < nums.length,
 2. increase your score by nums[i], and
 3. replace nums[i] with ceil(nums[i] / 3).

Return the maximum possible score you can attain after applying exactly k operations.

The ceiling function ceil(val) is the least integer greater than or equal to val.

 

Example 1:


Input: nums = [10,10,10,10,10], k = 5
Output: 50
Explanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.


Example 2:


Input: nums = [1,10,3,3,3], k = 3
Output: 17
Explanation: You can do the following operations:
Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.
Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.
Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3.
The final score is 10 + 4 + 3 = 17.


 

Constraints:

 * 1 <= nums.length, k <= 105
 * 1 <= nums[i] <= 109",Solutions (424),280
FALSE,0,0,2615,,Make Number of Distinct Characters Equal,make-number-of-distinct-characters-equal,FALSE,13390,52492,2531,FALSE,2,"Can you solve this real interview question? Make Number of Distinct Characters Equal - You are given two 0-indexed strings word1 and word2.

A move consists of choosing two indices i and j such that 0 <= i < word1.length and 0 <= j < word2.length and swapping word1[i] with word2[j].

Return true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.

 

Example 1:


Input: word1 = ""ac"", word2 = ""b""
Output: false
Explanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string.


Example 2:


Input: word1 = ""abcc"", word2 = ""aab""
Output: true
Explanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = ""abac"" and word2 = ""cab"", which both have 3 distinct characters.


Example 3:


Input: word1 = ""abcde"", word2 = ""fghij""
Output: true
Explanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap.


 

Constraints:

 * 1 <= word1.length, word2.length <= 105
 * word1 and word2 consist of only lowercase English letters.",Solutions (274),402
FALSE,0,0,2614,,Maximum Count of Positive Integer and Negative Integer,maximum-count-of-positive-integer-and-negative-integer,FALSE,44591,59553,2529,FALSE,1,"Can you solve this real interview question? Maximum Count of Positive Integer and Negative Integer - Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.

 * In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.

Note that 0 is neither positive nor negative.

 

Example 1:


Input: nums = [-2,-1,-1,1,2,3]
Output: 3
Explanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3.


Example 2:


Input: nums = [-3,-2,-1,0,0,1,2]
Output: 3
Explanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3.


Example 3:


Input: nums = [5,20,66,1314]
Output: 4
Explanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4.


 

Constraints:

 * 1 <= nums.length <= 2000
 * -2000 <= nums[i] <= 2000
 * nums is sorted in a non-decreasing order.

 

Follow up: Can you solve the problem in O(log(n)) time complexity?",Solutions (769),376
FALSE,0,0,2610,,Closest Prime Numbers in Range,closest-prime-numbers-in-range,FALSE,15533,41991,2523,FALSE,2,"Can you solve this real interview question? Closest Prime Numbers in Range - Given two positive integers left and right, find the two integers num1 and num2 such that:

 * left <= nums1 < nums2 <= right .
 * nums1 and nums2 are both prime numbers.
 * nums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.

Return the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.

A number greater than 1 is called prime if it is only divisible by 1 and itself.

 

Example 1:


Input: left = 10, right = 19
Output: [11,13]
Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.
The closest gap between any pair is 2, which can be achieved by [11,13] or [17,19].
Since 11 is smaller than 17, we return the first pair.


Example 2:


Input: left = 4, right = 6
Output: [-1,-1]
Explanation: There exists only one prime number in the given range, so the conditions cannot be satisfied.


 

Constraints:

 * 1 <= left <= right <= 106

 ",Solutions (332),276
FALSE,0,0,2609,,Distinct Prime Factors of Product of Array,distinct-prime-factors-of-product-of-array,FALSE,19683,39330,2521,FALSE,2,"Can you solve this real interview question? Distinct Prime Factors of Product of Array - Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.

Note that:

 * A number greater than 1 is called prime if it is divisible by only 1 and itself.
 * An integer val1 is a factor of another integer val2 if val2 / val1 is an integer.

 

Example 1:


Input: nums = [2,4,3,7,10,6]
Output: 4
Explanation:
The product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7.
There are 4 distinct prime factors so we return 4.


Example 2:


Input: nums = [2,4,8,16]
Output: 1
Explanation:
The product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210.
There is 1 distinct prime factor so we return 1.


 

Constraints:

 * 1 <= nums.length <= 104
 * 2 <= nums[i] <= 1000",Solutions (345),292
FALSE,0,0,2608,,Count the Digits That Divide a Number,count-the-digits-that-divide-a-number,FALSE,36756,43261,2520,FALSE,1,"Can you solve this real interview question? Count the Digits That Divide a Number - Given an integer num, return the number of digits in num that divide num.

An integer val divides nums if nums % val == 0.

 

Example 1:


Input: num = 7
Output: 1
Explanation: 7 divides itself, hence the answer is 1.


Example 2:


Input: num = 121
Output: 2
Explanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2.


Example 3:


Input: num = 1248
Output: 4
Explanation: 1248 is divisible by all of its digits, hence the answer is 4.


 

Constraints:

 * 1 <= num <= 109
 * num does not contain 0 as one of its digits.",Solutions (836),261
FALSE,0,0,2606,,Difference Between Ones and Zeros in Row and Column,difference-between-ones-and-zeros-in-row-and-column,FALSE,16794,21055,2482,FALSE,2,"Can you solve this real interview question? Difference Between Ones and Zeros in Row and Column - You are given a 0-indexed m x n binary matrix grid.

A 0-indexed m x n difference matrix diff is created with the following procedure:

 * Let the number of ones in the ith row be onesRowi.
 * Let the number of ones in the jth column be onesColj.
 * Let the number of zeros in the ith row be zerosRowi.
 * Let the number of zeros in the jth column be zerosColj.
 * diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj

Return the difference matrix diff.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/11/06/image-20221106171729-5.png]


Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
Output: [[0,0,4],[0,0,4],[-2,-2,2]]
Explanation:
- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2
- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2
- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2


Example 2:

[https://assets.leetcode.com/uploads/2022/11/06/image-20221106171747-6.png]


Input: grid = [[1,1,1],[1,1,1]]
Output: [[5,5,5],[5,5,5]]
Explanation:
- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5
- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5
- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5
- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5
- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5
- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 105
 * 1 <= m * n <= 105
 * grid[i][j] is either 0 or 1.",Solutions (414),258
FALSE,0,0,2605,,Count Anagrams,count-anagrams,FALSE,5626,16449,2514,FALSE,3,"Can you solve this real interview question? Count Anagrams - You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.

A string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.

 * For example, ""acb dfe"" is an anagram of ""abc def"", but ""def cab"" and ""adc bef"" are not.

Return the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:


Input: s = ""too hot""
Output: 18
Explanation: Some of the anagrams of the given string are ""too hot"", ""oot hot"", ""oto toh"", ""too toh"", and ""too oht"".


Example 2:


Input: s = ""aa""
Output: 1
Explanation: There is only one anagram possible for the given string.

 

Constraints:

 * 1 <= s.length <= 105
 * s consists of lowercase English letters and spaces ' '.
 * There is single space between consecutive words.",Solutions (111),228
FALSE,0,0,2604,,Minimum Operations to Make Array Equal II,minimum-operations-to-make-array-equal-ii,FALSE,16750,54276,2541,FALSE,2,"Can you solve this real interview question? Minimum Operations to Make Array Equal II - You are given two integer arrays nums1 and nums2 of equal length n and an integer k. You can perform the following operation on nums1:

 * Choose two indexes i and j and increment nums1[i] by k and decrement nums1[j] by k. In other words, nums1[i] = nums1[i] + k and nums1[j] = nums1[j] - k.

nums1 is said to be equal to nums2 if for all indices i such that 0 <= i < n, nums1[i] == nums2[i].

Return the minimum number of operations required to make nums1 equal to nums2. If it is impossible to make them equal, return -1.

 

Example 1:


Input: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3
Output: 2
Explanation: In 2 operations, we can transform nums1 to nums2.
1st operation: i = 2, j = 0. After applying the operation, nums1 = [1,3,4,4].
2nd operation: i = 2, j = 3. After applying the operation, nums1 = [1,3,7,1].
One can prove that it is impossible to make arrays equal in fewer operations.

Example 2:


Input: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1
Output: -1
Explanation: It can be proved that it is impossible to make the two arrays equal.


 

Constraints:

 * n == nums1.length == nums2.length
 * 2 <= n <= 105
 * 0 <= nums1[i], nums2[j] <= 109
 * 0 <= k <= 105",Solutions (275),294
FALSE,0,0,2603,,Reward Top K Students,reward-top-k-students,FALSE,12414,26728,2512,FALSE,2,"Can you solve this real interview question? Reward Top K Students - You are given two string arrays positive_feedback and negative_feedback, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative.

Initially every student has 0 points. Each positive word in a feedback report increases the points of a student by 3, whereas each negative word decreases the points by 1.

You are given n feedback reports, represented by a 0-indexed string array report and a 0-indexed integer array student_id, where student_id[i] represents the ID of the student who has received the feedback report report[i]. The ID of each student is unique.

Given an integer k, return the top k students after ranking them in non-increasing order by their points. In case more than one student has the same points, the one with the lower ID ranks higher.

 

Example 1:


Input: positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is studious"",""the student is smart""], student_id = [1,2], k = 2
Output: [1,2]
Explanation: 
Both the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher.


Example 2:


Input: positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is not studious"",""the student is smart""], student_id = [1,2], k = 2
Output: [2,1]
Explanation: 
- The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points. 
- The student with ID 2 has 1 positive feedback, so he has 3 points. 
Since student 2 has more points, [2,1] is returned.


 

Constraints:

 * 1 <= positive_feedback.length, negative_feedback.length <= 104
 * 1 <= positive_feedback[i].length, negative_feedback[j].length <= 100
 * Both positive_feedback[i] and negative_feedback[j] consists of lowercase English letters.
 * No word is present in both positive_feedback and negative_feedback.
 * n == report.length == student_id.length
 * 1 <= n <= 104
 * report[i] consists of lowercase English letters and spaces ' '.
 * There is a single space between consecutive words of report[i].
 * 1 <= report[i].length <= 100
 * 1 <= student_id[i] <= 109
 * All the values of student_id[i] are unique.
 * 1 <= k <= n",Solutions (279),202
FALSE,0,0,2602,,Maximum Enemy Forts That Can Be Captured,maximum-enemy-forts-that-can-be-captured,FALSE,15192,40611,2511,FALSE,1,"Can you solve this real interview question? Maximum Enemy Forts That Can Be Captured - You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where:

 * -1 represents there is no fort at the ith position.
 * 0 indicates there is an enemy fort at the ith position.
 * 1 indicates the fort at the ith the position is under your command.

Now you have decided to move your army from one of your forts at position i to an empty position j such that:

 * 0 <= i, j <= n - 1
 * The army travels over enemy forts only. Formally, for all k where min(i,j) < k < max(i,j), forts[k] == 0.

While moving the army, all the enemy forts that come in the way are captured.

Return the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.

 

Example 1:


Input: forts = [1,0,0,-1,0,0,0,0,1]
Output: 4
Explanation:
- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.
- Moving the army from position 8 to position 3 captures 4 enemy forts.
Since 4 is the maximum number of enemy forts that can be captured, we return 4.


Example 2:


Input: forts = [0,0,1,-1]
Output: 0
Explanation: Since no enemy fort can be captured, 0 is returned.


 

Constraints:

 * 1 <= forts.length <= 1000
 * -1 <= forts[i] <= 1",Solutions (301),173
FALSE,0,0,2601,,Number of Great Partitions,number-of-great-partitions,FALSE,5162,15664,2518,FALSE,3,"Can you solve this real interview question? Number of Great Partitions - You are given an array nums consisting of positive integers and an integer k.

Partition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.

Return the number of distinct great partitions. Since the answer may be too large, return it modulo 109 + 7.

Two partitions are considered distinct if some element nums[i] is in different groups in the two partitions.

 

Example 1:


Input: nums = [1,2,3,4], k = 4
Output: 6
Explanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).


Example 2:


Input: nums = [3,3,3], k = 4
Output: 0
Explanation: There are no great partitions for this array.


Example 3:


Input: nums = [6,6], k = 2
Output: 2
Explanation: We can either put nums[0] in the first partition or in the second partition.
The great partitions will be ([6], [6]) and ([6], [6]).


 

Constraints:

 * 1 <= nums.length, k <= 1000
 * 1 <= nums[i] <= 109",Solutions (73),289
FALSE,0,0,2600,,Maximum Tastiness of Candy Basket,maximum-tastiness-of-candy-basket,FALSE,10205,15773,2517,FALSE,2,"Can you solve this real interview question? Maximum Tastiness of Candy Basket - You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.

The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.

Return the maximum tastiness of a candy basket.

 

Example 1:


Input: price = [13,5,1,8,21,2], k = 3
Output: 8
Explanation: Choose the candies with the prices [13,5,21].
The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.
It can be proven that 8 is the maximum tastiness that can be achieved.


Example 2:


Input: price = [1,3,1], k = 2
Output: 2
Explanation: Choose the candies with the prices [1,3].
The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.
It can be proven that 2 is the maximum tastiness that can be achieved.


Example 3:


Input: price = [7,7,7,7], k = 2
Output: 0
Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0.


 

Constraints:

 * 2 <= k <= price.length <= 105
 * 1 <= price[i] <= 109",Solutions (156),533
FALSE,0,0,2599,,Take K of Each Character From Left and Right,take-k-of-each-character-from-left-and-right,FALSE,10545,31036,2516,FALSE,2,"Can you solve this real interview question? Take K of Each Character From Left and Right - You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.

Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.

 

Example 1:


Input: s = ""aabaaaacaabc"", k = 2
Output: 8
Explanation: 
Take three characters from the left of s. You now have two 'a' characters, and one 'b' character.
Take five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.
A total of 3 + 5 = 8 minutes is needed.
It can be proven that 8 is the minimum number of minutes needed.


Example 2:


Input: s = ""a"", k = 1
Output: -1
Explanation: It is not possible to take one 'b' or 'c' so return -1.


 

Constraints:

 * 1 <= s.length <= 105
 * s consists of only the letters 'a', 'b', and 'c'.
 * 0 <= k <= s.length",Solutions (216),521
FALSE,0,0,2598,,Shortest Distance to Target String in a Circular Array,shortest-distance-to-target-string-in-a-circular-array,FALSE,19858,40684,2515,FALSE,1,"Can you solve this real interview question? Shortest Distance to Target String in a Circular Array - You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.

 * Formally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.

Starting from startIndex, you can move to either the next word or the previous word with 1 step at a time.

Return the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.

 

Example 1:


Input: words = [""hello"",""i"",""am"",""leetcode"",""hello""], target = ""hello"", startIndex = 1
Output: 1
Explanation: We start from index 1 and can reach ""hello"" by
- moving 3 units to the right to reach index 4.
- moving 2 units to the left to reach index 4.
- moving 4 units to the right to reach index 0.
- moving 1 unit to the left to reach index 0.
The shortest distance to reach ""hello"" is 1.


Example 2:


Input: words = [""a"",""b"",""leetcode""], target = ""leetcode"", startIndex = 0
Output: 1
Explanation: We start from index 0 and can reach ""leetcode"" by
- moving 2 units to the right to reach index 3.
- moving 1 unit to the left to reach index 3.
The shortest distance to reach ""leetcode"" is 1.

Example 3:


Input: words = [""i"",""eat"",""leetcode""], target = ""ate"", startIndex = 0
Output: -1
Explanation: Since ""ate"" does not exist in words, we return -1.


 

Constraints:

 * 1 <= words.length <= 100
 * 1 <= words[i].length <= 100
 * words[i] and target consist of only lowercase English letters.
 * 0 <= startIndex < words.length",Solutions (363),251
FALSE,0,0,2597,,Cycle Length Queries in a Tree,cycle-length-queries-in-a-tree,FALSE,8360,14678,2509,FALSE,3,"Can you solve this real interview question? Cycle Length Queries in a Tree - You are given an integer n. There is a complete binary tree with 2n - 1 nodes. The root of that tree is the node with the value 1, and every node with a value val in the range [1, 2n - 1 - 1] has two children where:

 * The left node has the value 2 * val, and
 * The right node has the value 2 * val + 1.

You are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, solve the following problem:

 1. Add an edge between the nodes with values ai and bi.
 2. Find the length of the cycle in the graph.
 3. Remove the added edge between nodes with values ai and bi.

Note that:

 * A cycle is a path that starts and ends at the same node, and each edge in the path is visited only once.
 * The length of a cycle is the number of edges visited in the cycle.
 * There could be multiple edges between two nodes in the tree after adding the edge of the query.

Return an array answer of length m where answer[i] is the answer to the ith query.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/10/25/bexample1.png]


Input: n = 3, queries = [[5,3],[4,7],[2,3]]
Output: [4,5,3]
Explanation: The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.
- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes [5,2,1,3]. Thus answer to the first query is 4. We delete the added edge and process the next query.
- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes [4,2,1,3,7]. Thus answer to the second query is 5. We delete the added edge and process the next query.
- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes [2,1,3]. Thus answer to the third query is 3. We delete the added edge.


Example 2:

[https://assets.leetcode.com/uploads/2022/10/25/aexample2.png]


Input: n = 2, queries = [[1,2]]
Output: [2]
Explanation: The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.
- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes [2,1]. Thus answer for the first query is 2. We delete the added edge.


 

Constraints:

 * 2 <= n <= 30
 * m == queries.length
 * 1 <= m <= 105
 * queries[i].length == 2
 * 1 <= ai, bi <= 2n - 1
 * ai != bi",Solutions (218),237
FALSE,0,0,2596,,Add Edges to Make Degrees of All Nodes Even,add-edges-to-make-degrees-of-all-nodes-even,FALSE,8970,27736,2508,FALSE,3,"Can you solve this real interview question? Add Edges to Make Degrees of All Nodes Even - There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.

You can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.

Return true if it is possible to make the degree of each node in the graph even, otherwise return false.

The degree of a node is the number of edges connected to it.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/10/26/agraphdrawio.png]


Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]
Output: true
Explanation: The above diagram shows a valid way of adding an edge.
Every node in the resulting graph is connected to an even number of edges.


Example 2:

[https://assets.leetcode.com/uploads/2022/10/26/aagraphdrawio.png]


Input: n = 4, edges = [[1,2],[3,4]]
Output: true
Explanation: The above diagram shows a valid way of adding two edges.

Example 3:

[https://assets.leetcode.com/uploads/2022/10/26/aaagraphdrawio.png]


Input: n = 4, edges = [[1,2],[1,3],[1,4]]
Output: false
Explanation: It is not possible to obtain a valid graph with adding at most 2 edges.

 

Constraints:

 * 3 <= n <= 105
 * 2 <= edges.length <= 105
 * edges[i].length == 2
 * 1 <= ai, bi <= n
 * ai != bi
 * There are no repeated edges.",Solutions (155),261
FALSE,0,0,2595,,Smallest Value After Replacing With Sum of Prime Factors,smallest-value-after-replacing-with-sum-of-prime-factors,FALSE,15994,32827,2507,FALSE,2,"Can you solve this real interview question? Smallest Value After Replacing With Sum of Prime Factors - You are given a positive integer n.

Continuously replace n with the sum of its prime factors.

 * Note that if a prime factor divides n multiple times, it should be included in the sum as many times as it divides n.

Return the smallest value n will take on.

 

Example 1:


Input: n = 15
Output: 5
Explanation: Initially, n = 15.
15 = 3 * 5, so replace n with 3 + 5 = 8.
8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.
6 = 2 * 3, so replace n with 2 + 3 = 5.
5 is the smallest value n will take on.


Example 2:


Input: n = 3
Output: 3
Explanation: Initially, n = 3.
3 is the smallest value n will take on.


 

Constraints:

 * 2 <= n <= 105",Solutions (277),274
FALSE,0,0,2594,,Count Pairs Of Similar Strings,count-pairs-of-similar-strings,FALSE,25221,35779,2506,FALSE,1,"Can you solve this real interview question? Count Pairs Of Similar Strings - You are given a 0-indexed string array words.

Two strings are similar if they consist of the same characters.

 * For example, ""abca"" and ""cba"" are similar since both consist of characters 'a', 'b', and 'c'.
 * However, ""abacba"" and ""bcfd"" are not similar since they do not consist of the same characters.

Return the number of pairs (i, j) such that 0 <= i < j <= word.length - 1 and the two strings words[i] and words[j] are similar.

 

Example 1:


Input: words = [""aba"",""aabb"",""abcd"",""bac"",""aabc""]
Output: 2
Explanation: There are 2 pairs that satisfy the conditions:
- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. 
- i = 3 and j = 4 : both words[3] and words[4] only consist of characters 'a', 'b', and 'c'. 


Example 2:


Input: words = [""aabb"",""ab"",""ba""]
Output: 3
Explanation: There are 3 pairs that satisfy the conditions:
- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. 
- i = 0 and j = 2 : both words[0] and words[2] only consist of characters 'a' and 'b'.
- i = 1 and j = 2 : both words[1] and words[2] only consist of characters 'a' and 'b'.


Example 3:


Input: words = [""nba"",""cba"",""dba""]
Output: 0
Explanation: Since there does not exist any pair that satisfies the conditions, we return 0.

 

Constraints:

 * 1 <= words.length <= 100
 * 1 <= words[i].length <= 100
 * words[i] consist of only lowercase English letters.",Solutions (540),310
FALSE,0,0,2592,,Minimum Total Cost to Make Arrays Unequal,minimum-total-cost-to-make-arrays-unequal,FALSE,2703,6130,2499,FALSE,3,"Can you solve this real interview question? Minimum Total Cost to Make Arrays Unequal - You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.

In one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.

Find the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.

Return the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.

 

Example 1:


Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]
Output: 10
Explanation: 
One of the ways we can perform the operations is:
- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]
- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].
- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].
We can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.
Note that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.


Example 2:


Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]
Output: 10
Explanation: 
One of the ways we can perform the operations is:
- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].
- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].
The total cost needed here is 10, which is the minimum possible.


Example 3:


Input: nums1 = [1,2,2], nums2 = [1,2,2]
Output: -1
Explanation: 
It can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.
Hence, we return -1.


 

Constraints:

 * n == nums1.length == nums2.length
 * 1 <= n <= 105
 * 1 <= nums1[i], nums2[i] <= n",Solutions (41),169
FALSE,0,0,2591,,Frog Jump II,frog-jump-ii,FALSE,11087,18114,2498,FALSE,2,"Can you solve this real interview question? Frog Jump II - You are given a 0-indexed integer array stones sorted in strictly increasing order representing the positions of stones in a river.

A frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone at most once.

The length of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.

 * More formally, if the frog is at stones[i] and is jumping to stones[j], the length of the jump is |stones[i] - stones[j]|.

The cost of a path is the maximum length of a jump among all jumps in the path.

Return the minimum cost of a path for the frog.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/11/14/example-1.png]


Input: stones = [0,2,5,6,7]
Output: 5
Explanation: The above figure represents one of the optimal paths the frog can take.
The cost of this path is 5, which is the maximum length of a jump.
Since it is not possible to achieve a cost of less than 5, we return it.


Example 2:

[https://assets.leetcode.com/uploads/2022/11/14/example-2.png]


Input: stones = [0,3,9]
Output: 9
Explanation: 
The frog can jump directly to the last stone and come back to the first stone. 
In this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.
It can be shown that this is the minimum achievable cost.


 

Constraints:

 * 2 <= stones.length <= 105
 * 0 <= stones[i] <= 109
 * stones[0] == 0
 * stones is sorted in a strictly increasing order.",Solutions (199),352
FALSE,0,0,2590,,Maximum Star Sum of a Graph,maximum-star-sum-of-a-graph,FALSE,11727,30499,2497,FALSE,2,"Can you solve this real interview question? Maximum Star Sum of a Graph - There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.

You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.

A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.

The image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.

[https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-descdrawio.png]

The star sum is the sum of the values of all the nodes present in the star graph.

Given an integer k, return the maximum star sum of a star graph containing at most k edges.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-example1drawio.png]


Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2
Output: 16
Explanation: The above diagram represents the input graph.
The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.
It can be shown it is not possible to get a star graph with a sum greater than 16.


Example 2:


Input: vals = [-5], edges = [], k = 0
Output: -5
Explanation: There is only one possible star graph, which is node 0 itself.
Hence, we return -5.


 

Constraints:

 * n == vals.length
 * 1 <= n <= 105
 * -104 <= vals[i] <= 104
 * 0 <= edges.length <= min(n * (n - 1) / 2, 105)
 * edges[i].length == 2
 * 0 <= ai, bi <= n - 1
 * ai != bi
 * 0 <= k <= n - 1",Solutions (234),236
FALSE,0,0,2589,,Maximum Value of a String in an Array,maximum-value-of-a-string-in-an-array,FALSE,23314,32341,2496,FALSE,1,"Can you solve this real interview question? Maximum Value of a String in an Array - The value of an alphanumeric string can be defined as:

 * The numeric representation of the string in base 10, if it comprises of digits only.
 * The length of the string, otherwise.

Given an array strs of alphanumeric strings, return the maximum value of any string in strs.

 

Example 1:


Input: strs = [""alic3"",""bob"",""3"",""4"",""00000""]
Output: 5
Explanation: 
- ""alic3"" consists of both letters and digits, so its value is its length, i.e. 5.
- ""bob"" consists only of letters, so its value is also its length, i.e. 3.
- ""3"" consists only of digits, so its value is its numeric equivalent, i.e. 3.
- ""4"" also consists only of digits, so its value is 4.
- ""00000"" consists only of digits, so its value is 0.
Hence, the maximum value is 5, of ""alic3"".


Example 2:


Input: strs = [""1"",""01"",""001"",""0001""]
Output: 1
Explanation: 
Each string in the array has value 1. Hence, we return 1.


 

Constraints:

 * 1 <= strs.length <= 100
 * 1 <= strs[i].length <= 9
 * strs[i] consists of only lowercase English letters and digits.",Solutions (574),252
FALSE,0,0,2588,,Maximum Number of Points From Grid Queries,maximum-number-of-points-from-grid-queries,FALSE,6205,16763,2503,FALSE,3,"Can you solve this real interview question? Maximum Number of Points From Grid Queries - You are given an m x n integer matrix grid and an array queries of size k.

Find an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:

 * If queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.
 * Otherwise, you do not get any points, and you end this process.

After the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.

Return the resulting array answer.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/10/19/yetgriddrawio.png]


Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]
Output: [5,8,1]
Explanation: The diagrams above show which cells we visit to get points for each query.

Example 2:

[https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png]


Input: grid = [[5,2,1],[1,1,2]], queries = [3]
Output: [0]
Explanation: We can not get any points because the value of the top left cell is already greater than or equal to 3.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 2 <= m, n <= 1000
 * 4 <= m * n <= 105
 * k == queries.length
 * 1 <= k <= 104
 * 1 <= grid[i][j], queries[i] <= 106",Solutions (182),360
FALSE,0,0,2587,,Design Memory Allocator,design-memory-allocator,FALSE,10875,20841,2502,FALSE,2,"Can you solve this real interview question? Design Memory Allocator - You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.

You have a memory allocator with the following functionalities:

 1. Allocate a block of size consecutive free memory units and assign it the id mID.
 2. Free all memory units with the given id mID.

Note that:

 * Multiple blocks can be allocated to the same mID.
 * You should free all the memory units with mID, even if they were allocated in different blocks.

Implement the Allocator class:

 * Allocator(int n) Initializes an Allocator object with a memory array of size n.
 * int allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist, return -1.
 * int free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed.

 

Example 1:


Input
[""Allocator"", ""allocate"", ""allocate"", ""allocate"", ""free"", ""allocate"", ""allocate"", ""allocate"", ""free"", ""allocate"", ""free""]
[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]
Output
[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]

Explanation
Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.
loc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.
loc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.
loc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.
loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.
loc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.
loc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.
loc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.
loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.
loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.
loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.


 

Constraints:

 * 1 <= n, size, mID <= 1000
 * At most 1000 calls will be made to allocate and free.",Solutions (218),204
FALSE,0,0,2586,,Longest Square Streak in an Array,longest-square-streak-in-an-array,FALSE,19135,48408,2501,FALSE,2,"Can you solve this real interview question? Longest Square Streak in an Array - You are given an integer array nums. A subsequence of nums is called a square streak if:

 * The length of the subsequence is at least 2, and
 * after sorting the subsequence, each element (except the first element) is the square of the previous number.

Return the length of the longest square streak in nums, or return -1 if there is no square streak.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:


Input: nums = [4,3,6,16,8,2]
Output: 3
Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].
- 4 = 2 * 2.
- 16 = 4 * 4.
Therefore, [4,16,2] is a square streak.
It can be shown that every subsequence of length 4 is not a square streak.


Example 2:


Input: nums = [2,3,5,6,7]
Output: -1
Explanation: There is no square streak in nums so return -1.


 

Constraints:

 * 2 <= nums.length <= 105
 * 2 <= nums[i] <= 105",Solutions (444),351
FALSE,0,0,2585,,Delete Greatest Value in Each Row,delete-greatest-value-in-each-row,FALSE,28998,35795,2500,FALSE,1,"Can you solve this real interview question? Delete Greatest Value in Each Row - You are given an m x n matrix grid consisting of positive integers.

Perform the following operation until grid becomes empty:

 * Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them.
 * Add the maximum of deleted elements to the answer.

Note that the number of columns decreases by one after each operation.

Return the answer after performing the operations described above.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/10/19/q1ex1.jpg]


Input: grid = [[1,2,4],[3,3,1]]
Output: 8
Explanation: The diagram above shows the removed values in each step.
- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.
- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.
- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.
The final answer = 4 + 3 + 1 = 8.


Example 2:

[https://assets.leetcode.com/uploads/2022/10/19/q1ex2.jpg]


Input: grid = [[10]]
Output: 10
Explanation: The diagram above shows the removed values in each step.
- In the first operation, we remove 10 from the first row. We add 10 to the answer.
The final answer = 10.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 50
 * 1 <= grid[i][j] <= 100",Solutions (564),347
FALSE,0,0,2583,,Divide Nodes Into the Maximum Number of Groups,divide-nodes-into-the-maximum-number-of-groups,FALSE,4919,13265,2493,FALSE,3,"Can you solve this real interview question? Divide Nodes Into the Maximum Number of Groups - You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.

You are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.

Divide the nodes of the graph into m groups (1-indexed) such that:

 * Each node in the graph belongs to exactly one group.
 * For every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1.

Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/10/13/example1.png]


Input: n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]
Output: 4
Explanation: As shown in the image we:
- Add node 5 to the first group.
- Add node 1 to the second group.
- Add nodes 2 and 4 to the third group.
- Add nodes 3 and 6 to the fourth group.
We can see that every edge is satisfied.
It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.


Example 2:


Input: n = 3, edges = [[1,2],[2,3],[3,1]]
Output: -1
Explanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.
It can be shown that no grouping is possible.


 

Constraints:

 * 1 <= n <= 500
 * 1 <= edges.length <= 104
 * edges[i].length == 2
 * 1 <= ai, bi <= n
 * ai != bi
 * There is at most one edge between any pair of vertices.",Solutions (96),271
FALSE,0,0,2582,minimum-score-of-a-path-between-two-cities,Minimum Score of a Path Between Two Cities,minimum-score-of-a-path-between-two-cities,FALSE,61432,105235,2492,FALSE,2,"Can you solve this real interview question? Minimum Score of a Path Between Two Cities - You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.

The score of a path between two cities is defined as the minimum distance of a road in this path.

Return the minimum possible score of a path between cities 1 and n.

Note:

 * A path is a sequence of roads between two cities.
 * It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.
 * The test cases are generated such that there is at least one path between 1 and n.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/10/12/graph11.png]


Input: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]
Output: 5
Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.
It can be shown that no other path has less score.


Example 2:

[https://assets.leetcode.com/uploads/2022/10/12/graph22.png]


Input: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]
Output: 2
Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.


 

Constraints:

 * 2 <= n <= 105
 * 1 <= roads.length <= 105
 * roads[i].length == 3
 * 1 <= ai, bi <= n
 * ai != bi
 * 1 <= distancei <= 104
 * There are no repeated edges.
 * There is at least one path between 1 and n.",Solutions (969),1.5K
FALSE,0,0,2581,,Divide Players Into Teams of Equal Skill,divide-players-into-teams-of-equal-skill,FALSE,22812,38722,2491,FALSE,2,"Can you solve this real interview question? Divide Players Into Teams of Equal Skill - You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.

The chemistry of a team is equal to the product of the skills of the players on that team.

Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.

 

Example 1:


Input: skill = [3,2,5,1,3,4]
Output: 22
Explanation: 
Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.
The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.


Example 2:


Input: skill = [3,4]
Output: 12
Explanation: 
The two players form a team with a total skill of 7.
The chemistry of the team is 3 * 4 = 12.


Example 3:


Input: skill = [1,1,2,3]
Output: -1
Explanation: 
There is no way to divide the players into teams such that the total skill of each team is equal.


 

Constraints:

 * 2 <= skill.length <= 105
 * skill.length is even.
 * 1 <= skill[i] <= 1000",Solutions (486),310
FALSE,0,0,2580,,Circular Sentence,circular-sentence,FALSE,26480,41133,2490,FALSE,1,"Can you solve this real interview question? Circular Sentence - A sentence is a list of words that are separated by a single space with no leading or trailing spaces.

 * For example, ""Hello World"", ""HELLO"", ""hello world hello world"" are all sentences.

Words consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.

A sentence is circular if:

 * The last character of a word is equal to the first character of the next word.
 * The last character of the last word is equal to the first character of the first word.

For example, ""leetcode exercises sound delightful"", ""eetcode"", ""leetcode eats soul"" are all circular sentences. However, ""Leetcode is cool"", ""happy Leetcode"", ""Leetcode"" and ""I like Leetcode"" are not circular sentences.

Given a string sentence, return true if it is circular. Otherwise, return false.

 

Example 1:


Input: sentence = ""leetcode exercises sound delightful""
Output: true
Explanation: The words in sentence are [""leetcode"", ""exercises"", ""sound"", ""delightful""].
- leetcode's last character is equal to exercises's first character.
- exercises's last character is equal to sound's first character.
- sound's last character is equal to delightful's first character.
- delightful's last character is equal to leetcode's first character.
The sentence is circular.

Example 2:


Input: sentence = ""eetcode""
Output: true
Explanation: The words in sentence are [""eetcode""].
- eetcode's last character is equal to eetcode's first character.
The sentence is circular.

Example 3:


Input: sentence = ""Leetcode is cool""
Output: false
Explanation: The words in sentence are [""Leetcode"", ""is"", ""cool""].
- Leetcode's last character is not equal to is's first character.
The sentence is not circular.

 

Constraints:

 * 1 <= sentence.length <= 500
 * sentence consist of only lowercase and uppercase English letters and spaces.
 * The words in sentence are separated by a single space.
 * There are no leading or trailing spaces.",Solutions (532),237
FALSE,0,0,2577,,Count Palindromic Subsequences,count-palindromic-subsequences,FALSE,4863,14711,2484,FALSE,3,"Can you solve this real interview question? Count Palindromic Subsequences - Given a string of digits s, return the number of palindromic subsequences of s having length 5. Since the answer may be very large, return it modulo 109 + 7.

Note:

 * A string is palindromic if it reads the same forward and backward.
 * A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

 

Example 1:


Input: s = ""103301""
Output: 2
Explanation: 
There are 6 possible subsequences of length 5: ""10330"",""10331"",""10301"",""10301"",""13301"",""03301"". 
Two of them (both equal to ""10301"") are palindromic.


Example 2:


Input: s = ""0000000""
Output: 21
Explanation: All 21 subsequences are ""00000"", which is palindromic.


Example 3:


Input: s = ""9999900000""
Output: 2
Explanation: The only two palindromic subsequences are ""99999"" and ""00000"".


 

Constraints:

 * 1 <= s.length <= 104
 * s consists of digits.",Solutions (111),285
FALSE,0,0,2576,,Minimum Penalty for a Shop,minimum-penalty-for-a-shop,FALSE,12633,22697,2483,FALSE,2,"Can you solve this real interview question? Minimum Penalty for a Shop - You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y':

 * if the ith character is 'Y', it means that customers come at the ith hour
 * whereas 'N' indicates that no customers come at the ith hour.

If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows:

 * For every hour when the shop is open and no customers come, the penalty increases by 1.
 * For every hour when the shop is closed and customers come, the penalty increases by 1.

Return the earliest hour at which the shop must be closed to incur a minimum penalty.

Note that if a shop closes at the jth hour, it means the shop is closed at the hour j.

 

Example 1:


Input: customers = ""YYNY""
Output: 2
Explanation: 
- Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty.
- Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty.
- Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty.
- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.
- Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty.
Closing the shop at 2nd or 4th hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.


Example 2:


Input: customers = ""NNNNN""
Output: 0
Explanation: It is best to close the shop at the 0th hour as no customers arrive.

Example 3:


Input: customers = ""YYYY""
Output: 4
Explanation: It is best to close the shop at the 4th hour as customers arrive at each hour.


 

Constraints:

 * 1 <= customers.length <= 105
 * customers consists only of characters 'Y' and 'N'.",Solutions (315),260
FALSE,0,0,2575,,Minimum Cuts to Divide a Circle,minimum-cuts-to-divide-a-circle,FALSE,20112,38277,2481,FALSE,1,"Can you solve this real interview question? Minimum Cuts to Divide a Circle - A valid cut in a circle can be:

 * A cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or
 * A cut that is represented by a straight line that touches one point on the edge of the circle and its center.

Some valid and invalid cuts are shown in the figures below.

[https://assets.leetcode.com/uploads/2022/10/29/alldrawio.png]

Given the integer n, return the minimum number of cuts needed to divide a circle into n equal slices.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/10/24/11drawio.png]


Input: n = 4
Output: 2
Explanation: 
The above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.


Example 2:

[https://assets.leetcode.com/uploads/2022/10/24/22drawio.png]


Input: n = 3
Output: 3
Explanation:
At least 3 cuts are needed to divide the circle into 3 equal slices. 
It can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.
Also note that the first cut will not divide the circle into distinct parts.


 

Constraints:

 * 1 <= n <= 100",Solutions (374),138
FALSE,0,0,2574,,Count Subarrays With Median K,count-subarrays-with-median-k,FALSE,8366,19451,2488,FALSE,3,"Can you solve this real interview question? Count Subarrays With Median K - You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.

Return the number of non-empty subarrays in nums that have a median equal to k.

Note:

 * The median of an array is the middle element after sorting the array in ascending order. If the array is of even length, the median is the left middle element.
   * For example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1] is 4.
 * A subarray is a contiguous part of an array.

 

Example 1:


Input: nums = [3,2,1,4,5], k = 4
Output: 3
Explanation: The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5].


Example 2:


Input: nums = [2,3,1], k = 3
Output: 1
Explanation: [3] is the only subarray that has a median equal to 3.


 

Constraints:

 * n == nums.length
 * 1 <= n <= 105
 * 1 <= nums[i], k <= n
 * The integers in nums are distinct.",Solutions (152),416
FALSE,0,0,2573,,Remove Nodes From Linked List,remove-nodes-from-linked-list,FALSE,25965,37916,2487,FALSE,2,"Can you solve this real interview question? Remove Nodes From Linked List - You are given the head of a linked list.

Remove every node which has a node with a strictly greater value anywhere to the right side of it.

Return the head of the modified linked list.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/10/02/drawio.png]


Input: head = [5,2,13,3,8]
Output: [13,8]
Explanation: The nodes that should be removed are 5, 2 and 3.
- Node 13 is to the right of node 5.
- Node 13 is to the right of node 2.
- Node 8 is to the right of node 3.


Example 2:


Input: head = [1,1,1,1]
Output: [1,1,1,1]
Explanation: Every node has value 1, so no nodes are removed.


 

Constraints:

 * The number of the nodes in the given list is in the range [1, 105].
 * 1 <= Node.val <= 105",Solutions (620),685
FALSE,0,0,2572,,Append Characters to String to Make Subsequence,append-characters-to-string-to-make-subsequence,FALSE,19749,30908,2486,FALSE,2,"Can you solve this real interview question? Append Characters to String to Make Subsequence - You are given two strings s and t consisting of only lowercase English letters.

Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

 

Example 1:


Input: s = ""coaching"", t = ""coding""
Output: 4
Explanation: Append the characters ""ding"" to the end of s so that s = ""coachingding"".
Now, t is a subsequence of s (""coachingding"").
It can be shown that appending any 3 characters to the end of s will never make t a subsequence.


Example 2:


Input: s = ""abcde"", t = ""a""
Output: 0
Explanation: t is already a subsequence of s (""abcde"").


Example 3:


Input: s = ""z"", t = ""abcde""
Output: 5
Explanation: Append the characters ""abcde"" to the end of s so that s = ""zabcde"".
Now, t is a subsequence of s (""zabcde"").
It can be shown that appending any 4 characters to the end of s will never make t a subsequence.


 

Constraints:

 * 1 <= s.length, t.length <= 105
 * s and t consist only of lowercase English letters.",Solutions (395),278
FALSE,0,0,2571,,Find the Pivot Integer,find-the-pivot-integer,FALSE,32369,40441,2485,FALSE,1,"Can you solve this real interview question? Find the Pivot Integer - Given a positive integer n, find the pivot integer x such that:

 * The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.

Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.

 

Example 1:


Input: n = 8
Output: 6
Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.


Example 2:


Input: n = 1
Output: 1
Explanation: 1 is the pivot integer since: 1 = 1.


Example 3:


Input: n = 4
Output: -1
Explanation: It can be proved that no such integer exist.


 

Constraints:

 * 1 <= n <= 1000",Solutions (709),366
FALSE,0,0,2569,,Number of Beautiful Partitions,number-of-beautiful-partitions,FALSE,7283,23647,2478,FALSE,3,"Can you solve this real interview question? Number of Beautiful Partitions - You are given a string s that consists of the digits '1' to '9' and two integers k and minLength.

A partition of s is called beautiful if:

 * s is partitioned into k non-intersecting substrings.
 * Each substring has a length of at least minLength.
 * Each substring starts with a prime digit and ends with a non-prime digit. Prime digits are '2', '3', '5', and '7', and the rest of the digits are non-prime.

Return the number of beautiful partitions of s. Since the answer may be very large, return it modulo 109 + 7.

A substring is a contiguous sequence of characters within a string.

 

Example 1:


Input: s = ""23542185131"", k = 3, minLength = 2
Output: 3
Explanation: There exists three ways to create a beautiful partition:
""2354 | 218 | 5131""
""2354 | 21851 | 31""
""2354218 | 51 | 31""


Example 2:


Input: s = ""23542185131"", k = 3, minLength = 3
Output: 1
Explanation: There exists one way to create a beautiful partition: ""2354 | 218 | 5131"".


Example 3:


Input: s = ""3312958"", k = 3, minLength = 1
Output: 1
Explanation: There exists one way to create a beautiful partition: ""331 | 29 | 58"".


 

Constraints:

 * 1 <= k, minLength <= s.length <= 1000
 * s consists of the digits '1' to '9'.",Solutions (139),264
FALSE,0,0,2568,minimum-fuel-cost-to-report-to-the-capital,Minimum Fuel Cost to Report to the Capital,minimum-fuel-cost-to-report-to-the-capital,FALSE,53674,79251,2477,FALSE,2,"Can you solve this real interview question? Minimum Fuel Cost to Report to the Capital - There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.

There is a meeting for the representatives of each city. The meeting is in the capital city.

There is a car in each city. You are given an integer seats that indicates the number of seats in each car.

A representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.

Return the minimum number of liters of fuel to reach the capital city.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/09/22/a4c380025e3ff0c379525e96a7d63a3.png]


Input: roads = [[0,1],[0,2],[0,3]], seats = 5
Output: 3
Explanation: 
- Representative1 goes directly to the capital with 1 liter of fuel.
- Representative2 goes directly to the capital with 1 liter of fuel.
- Representative3 goes directly to the capital with 1 liter of fuel.
It costs 3 liters of fuel at minimum. 
It can be proven that 3 is the minimum number of liters of fuel needed.


Example 2:

[https://assets.leetcode.com/uploads/2022/11/16/2.png]


Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
Output: 7
Explanation: 
- Representative2 goes directly to city 3 with 1 liter of fuel.
- Representative2 and representative3 go together to city 1 with 1 liter of fuel.
- Representative2 and representative3 go together to the capital with 1 liter of fuel.
- Representative1 goes directly to the capital with 1 liter of fuel.
- Representative5 goes directly to the capital with 1 liter of fuel.
- Representative6 goes directly to city 4 with 1 liter of fuel.
- Representative4 and representative6 go together to the capital with 1 liter of fuel.
It costs 7 liters of fuel at minimum. 
It can be proven that 7 is the minimum number of liters of fuel needed.


Example 3:

[https://assets.leetcode.com/uploads/2022/09/27/efcf7f7be6830b8763639cfd01b690a.png]


Input: roads = [], seats = 1
Output: 0
Explanation: No representatives need to travel to the capital city.


 

Constraints:

 * 1 <= n <= 105
 * roads.length == n - 1
 * roads[i].length == 2
 * 0 <= ai, bi < n
 * ai != bi
 * roads represents a valid tree.
 * 1 <= seats <= 105",Solutions (608),1.8K
FALSE,0,0,2567,,Closest Nodes Queries in a Binary Search Tree,closest-nodes-queries-in-a-binary-search-tree,FALSE,14846,36402,2476,FALSE,2,"Can you solve this real interview question? Closest Nodes Queries in a Binary Search Tree - You are given the root of a binary search tree and an array queries of size n consisting of positive integers.

Find a 2D array answer of size n where answer[i] = [mini, maxi]:

 * mini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.
 * maxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.

Return the array answer.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png]


Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]
Output: [[2,2],[4,6],[15,-1]]
Explanation: We answer the queries in the following way:
- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].
- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].
- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].


Example 2:

[https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png]


Input: root = [4,null,9], queries = [3]
Output: [[-1,4]]
Explanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].


 

Constraints:

 * The number of nodes in the tree is in the range [2, 105].
 * 1 <= Node.val <= 106
 * n == queries.length
 * 1 <= n <= 105
 * 1 <= queries[i] <= 106",Solutions (342),293
FALSE,0,0,2566,,Number of Unequal Triplets in Array,number-of-unequal-triplets-in-array,FALSE,25444,35912,2475,FALSE,1,"Can you solve this real interview question? Number of Unequal Triplets in Array - You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:

 * 0 <= i < j < k < nums.length
 * nums[i], nums[j], and nums[k] are pairwise distinct.
   * In other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].

Return the number of triplets that meet the conditions.

 

Example 1:


Input: nums = [4,4,2,4,3]
Output: 3
Explanation: The following triplets meet the conditions:
- (0, 2, 4) because 4 != 2 != 3
- (1, 2, 4) because 4 != 2 != 3
- (2, 3, 4) because 2 != 4 != 3
Since there are 3 triplets, we return 3.
Note that (2, 0, 4) is not a valid triplet because 2 > 0.


Example 2:


Input: nums = [1,1,1,1,1]
Output: 0
Explanation: No triplets meet the conditions so we return 0.


 

Constraints:

 * 3 <= nums.length <= 100
 * 1 <= nums[i] <= 1000",Solutions (287),255
FALSE,0,0,2564,,Most Profitable Path in a Tree,most-profitable-path-in-a-tree,FALSE,6939,14382,2467,FALSE,2,"Can you solve this real interview question? Most Profitable Path in a Tree - There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:

 * the price needed to open the gate at node i, if amount[i] is negative, or,
 * the cash reward obtained on opening the gate at node i, otherwise.

The game goes on as follows:

 * Initially, Alice is at node 0 and Bob is at node bob.
 * At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.
 * For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:
   * If the gate is already open, no price will be required, nor will there be any cash reward.
   * If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each.
 * If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other.

Return the maximum net income Alice can have if she travels towards the optimal leaf node.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/10/29/eg1.png]


Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
Output: 6
Explanation: 
The above diagram represents the given tree. The game goes as follows:
- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.
  Alice's net income is now -2.
- Both Alice and Bob move to node 1. 
  Since they reach here simultaneously, they open the gate together and share the reward.
  Alice's net income becomes -2 + (4 / 2) = 0.
- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.
  Bob moves on to node 0, and stops moving.
- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.
Now, neither Alice nor Bob can make any further moves, and the game ends.
It is not possible for Alice to get a higher net income.


Example 2:

[https://assets.leetcode.com/uploads/2022/10/29/eg2.png]


Input: edges = [[0,1]], bob = 1, amount = [-7280,2350]
Output: -7280
Explanation: 
Alice follows the path 0->1 whereas Bob follows the path 1->0.
Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280. 


 

Constraints:

 * 2 <= n <= 105
 * edges.length == n - 1
 * edges[i].length == 2
 * 0 <= ai, bi < n
 * ai != bi
 * edges represents a valid tree.
 * 1 <= bob < n
 * amount.length == n
 * amount[i] is an even integer in the range [-104, 104].",Solutions (172),430
FALSE,0,0,2563,,Split Message Based on Limit,split-message-based-on-limit,FALSE,3702,8000,2468,FALSE,3,"Can you solve this real interview question? Split Message Based on Limit - You are given a string, message, and a positive integer, limit.

You must split message into one or more parts based on limit. Each resulting part should have the suffix ""<a/b>"", where ""b"" is to be replaced with the total number of parts and ""a"" is to be replaced with the index of the part, starting from 1 and going up to b. Additionally, the length of each resulting part (including its suffix) should be equal to limit, except for the last part whose length can be at most limit.

The resulting parts should be formed such that when their suffixes are removed and they are all concatenated in order, they should be equal to message. Also, the result should contain as few parts as possible.

Return the parts message would be split into as an array of strings. If it is impossible to split message as required, return an empty array.

 

Example 1:


Input: message = ""this is really a very awesome message"", limit = 9
Output: [""thi<1/14>"",""s i<2/14>"",""s r<3/14>"",""eal<4/14>"",""ly <5/14>"",""a v<6/14>"",""ery<7/14>"","" aw<8/14>"",""eso<9/14>"",""me<10/14>"","" m<11/14>"",""es<12/14>"",""sa<13/14>"",""ge<14/14>""]
Explanation:
The first 9 parts take 3 characters each from the beginning of message.
The next 5 parts take 2 characters each to finish splitting message. 
In this example, each part, including the last, has length 9. 
It can be shown it is not possible to split message into less than 14 parts.


Example 2:


Input: message = ""short message"", limit = 15
Output: [""short mess<1/2>"",""age<2/2>""]
Explanation:
Under the given constraints, the string can be split into two parts: 
- The first part comprises of the first 10 characters, and has a length 15.
- The next part comprises of the last 3 characters, and has a length 8.


 

Constraints:

 * 1 <= message.length <= 104
 * message consists only of lowercase English letters and ' '.
 * 1 <= limit <= 104",Solutions (100),80
FALSE,0,0,2562,,Count Ways To Build Good Strings,count-ways-to-build-good-strings,FALSE,11251,26723,2466,FALSE,2,"Can you solve this real interview question? Count Ways To Build Good Strings - Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:

 * Append the character '0' zero times.
 * Append the character '1' one times.

This can be performed any number of times.

A good string is a string constructed by the above process having a length between low and high (inclusive).

Return the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.

 

Example 1:


Input: low = 3, high = 3, zero = 1, one = 1
Output: 8
Explanation: 
One possible valid good string is ""011"". 
It can be constructed as follows: """" -> ""0"" -> ""01"" -> ""011"". 
All binary strings from ""000"" to ""111"" are good strings in this example.


Example 2:


Input: low = 2, high = 3, zero = 1, one = 2
Output: 5
Explanation: The good strings are ""00"", ""11"", ""000"", ""110"", and ""011"".


 

Constraints:

 * 1 <= low <= high <= 105
 * 1 <= zero, one <= low",Solutions (191),338
FALSE,0,0,2561,,Number of Distinct Averages,number-of-distinct-averages,FALSE,25590,43908,2465,FALSE,1,"Can you solve this real interview question? Number of Distinct Averages - You are given a 0-indexed integer array nums of even length.

As long as nums is not empty, you must repetitively:

 * Find the minimum number in nums and remove it.
 * Find the maximum number in nums and remove it.
 * Calculate the average of the two removed numbers.

The average of two numbers a and b is (a + b) / 2.

 * For example, the average of 2 and 3 is (2 + 3) / 2 = 2.5.

Return the number of distinct averages calculated using the above process.

Note that when there is a tie for a minimum or maximum number, any can be removed.

 

Example 1:


Input: nums = [4,1,4,0,3,5]
Output: 2
Explanation:
1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3].
2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3].
3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.
Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.


Example 2:


Input: nums = [1,100]
Output: 1
Explanation:
There is only one average to be calculated after removing 1 and 100, so we return 1.


 

Constraints:

 * 2 <= nums.length <= 100
 * nums.length is even.
 * 0 <= nums[i] <= 100",Solutions (535),258
FALSE,0,0,2559,,Maximum Number of Non-overlapping Palindrome Substrings,maximum-number-of-non-overlapping-palindrome-substrings,FALSE,9195,24153,2472,FALSE,3,"Can you solve this real interview question? Maximum Number of Non-overlapping Palindrome Substrings - You are given a string s and a positive integer k.

Select a set of non-overlapping substrings from the string s that satisfy the following conditions:

 * The length of each substring is at least k.
 * Each substring is a palindrome.

Return the maximum number of substrings in an optimal selection.

A substring is a contiguous sequence of characters within a string.

 

Example 1:


Input: s = ""abaccdbbd"", k = 3
Output: 2
Explanation: We can select the substrings underlined in s = ""abaccdbbd"". Both ""aba"" and ""dbbd"" are palindromes and have a length of at least k = 3.
It can be shown that we cannot find a selection with more than two valid substrings.


Example 2:


Input: s = ""adbcda"", k = 2
Output: 0
Explanation: There is no palindrome substring of length at least 2 in the string.


 

Constraints:

 * 1 <= k <= s.length <= 2000
 * s consists of lowercase English letters.",Solutions (199),318
FALSE,0,0,2558,,Minimum Number of Operations to Sort a Binary Tree by Level,minimum-number-of-operations-to-sort-a-binary-tree-by-level,FALSE,15345,24606,2471,FALSE,2,"Can you solve this real interview question? Minimum Number of Operations to Sort a Binary Tree by Level - You are given the root of a binary tree with unique values.

In one operation, you can choose any two nodes at the same level and swap their values.

Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.

The level of a node is the number of edges along the path between it and the root node.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png]


Input: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]
Output: 3
Explanation:
- Swap 4 and 3. The 2nd level becomes [3,4].
- Swap 7 and 5. The 3rd level becomes [5,6,8,7].
- Swap 8 and 7. The 3rd level becomes [5,6,7,8].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.


Example 2:

[https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png]


Input: root = [1,3,2,7,6,5,4]
Output: 3
Explanation:
- Swap 3 and 2. The 2nd level becomes [2,3].
- Swap 7 and 4. The 3rd level becomes [4,6,5,7].
- Swap 6 and 5. The 3rd level becomes [4,5,6,7].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.


Example 3:

[https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png]


Input: root = [1,2,3,4,5,6]
Output: 0
Explanation: Each level is already sorted in increasing order so return 0.


 

Constraints:

 * The number of nodes in the tree is in the range [1, 105].
 * 1 <= Node.val <= 105
 * All the values of the tree are unique.",Solutions (263),454
FALSE,0,0,2557,,Number of Subarrays With LCM Equal to K,number-of-subarrays-with-lcm-equal-to-k,FALSE,17907,46676,2470,FALSE,2,"Can you solve this real interview question? Number of Subarrays With LCM Equal to K - Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray's elements is k.

A subarray is a contiguous non-empty sequence of elements within an array.

The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.

 

Example 1:


Input: nums = [3,6,2,7,1], k = 6
Output: 4
Explanation: The subarrays of nums where 6 is the least common multiple of all the subarray's elements are:
- [3,6,2,7,1]
- [3,6,2,7,1]
- [3,6,2,7,1]
- [3,6,2,7,1]


Example 2:


Input: nums = [3], k = 2
Output: 0
Explanation: There are no subarrays of nums where 2 is the least common multiple of all the subarray's elements.


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i], k <= 1000",Solutions (202),284
FALSE,0,0,2556,,Convert the Temperature,convert-the-temperature,FALSE,70154,78748,2469,FALSE,1,"Can you solve this real interview question? Convert the Temperature - You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.

You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].

Return the array ans. Answers within 10-5 of the actual answer will be accepted.

Note that:

 * Kelvin = Celsius + 273.15
 * Fahrenheit = Celsius * 1.80 + 32.00

 

Example 1:


Input: celsius = 36.50
Output: [309.65000,97.70000]
Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.


Example 2:


Input: celsius = 122.11
Output: [395.26000,251.79800]
Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798.


 

Constraints:

 * 0 <= celsius <= 1000",Solutions (850),327
FALSE,0,0,2554,,Minimum Total Distance Traveled,minimum-total-distance-traveled,FALSE,5913,14547,2463,FALSE,3,"Can you solve this real interview question? Minimum Total Distance Traveled - There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.

The positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.

All the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.

At any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.

Return the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.

Note that

 * All robots move at the same speed.
 * If two robots move in the same direction, they will never collide.
 * If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.
 * If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.
 * If the robot moved from a position x to a position y, the distance it moved is |y - x|.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/09/15/example1.jpg]


Input: robot = [0,4,6], factory = [[2,2],[6,2]]
Output: 4
Explanation: As shown in the figure:
- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.
- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.
- The third robot at position 6 will be repaired at the second factory. It does not need to move.
The limit of the first factory is 2, and it fixed 2 robots.
The limit of the second factory is 2, and it fixed 1 robot.
The total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.


Example 2:

[https://assets.leetcode.com/uploads/2022/09/15/example-2.jpg]


Input: robot = [1,-1], factory = [[-2,1],[2,1]]
Output: 2
Explanation: As shown in the figure:
- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.
- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.
The limit of the first factory is 1, and it fixed 1 robot.
The limit of the second factory is 1, and it fixed 1 robot.
The total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.


 

Constraints:

 * 1 <= robot.length, factory.length <= 100
 * factory[j].length == 2
 * -109 <= robot[i], positionj <= 109
 * 0 <= limitj <= robot.length
 * The input will be generated such that it is always possible to repair every robot.",Solutions (116),363
FALSE,0,0,2553,,Total Cost to Hire K Workers,total-cost-to-hire-k-workers,FALSE,13984,37241,2462,FALSE,2,"Can you solve this real interview question? Total Cost to Hire K Workers - You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.

You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:

 * You will run k sessions and hire exactly one worker in each session.
 * In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.
   * For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].
   * In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.
 * If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.
 * A worker can only be chosen once.

Return the total cost to hire exactly k workers.

 

Example 1:


Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4
Output: 11
Explanation: We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.
- In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.
- In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.
The total hiring cost is 11.


Example 2:


Input: costs = [1,2,4,1], k = 3, candidates = 3
Output: 4
Explanation: We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.
- In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.
- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.
The total hiring cost is 4.


 

Constraints:

 * 1 <= costs.length <= 105
 * 1 <= costs[i] <= 105
 * 1 <= k, candidates <= costs.length",Solutions (338),421
FALSE,0,0,2552,,Maximum Sum of Distinct Subarrays With Length K,maximum-sum-of-distinct-subarrays-with-length-k,FALSE,22774,66474,2461,FALSE,2,"Can you solve this real interview question? Maximum Sum of Distinct Subarrays With Length K - You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:

 * The length of the subarray is k, and
 * All the elements of the subarray are distinct.

Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: nums = [1,5,4,2,9,9,9], k = 3
Output: 15
Explanation: The subarrays of nums with length 3 are:
- [1,5,4] which meets the requirements and has a sum of 10.
- [5,4,2] which meets the requirements and has a sum of 11.
- [4,2,9] which meets the requirements and has a sum of 15.
- [2,9,9] which does not meet the requirements because the element 9 is repeated.
- [9,9,9] which does not meet the requirements because the element 9 is repeated.
We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions


Example 2:


Input: nums = [4,4,4], k = 3
Output: 0
Explanation: The subarrays of nums with length 3 are:
- [4,4,4] which does not meet the requirements because the element 4 is repeated.
We return 0 because no subarrays meet the conditions.


 

Constraints:

 * 1 <= k <= nums.length <= 105
 * 1 <= nums[i] <= 105",Solutions (477),627
FALSE,0,0,2551,,Apply Operations to an Array,apply-operations-to-an-array,FALSE,34801,51876,2460,FALSE,1,"Can you solve this real interview question? Apply Operations to an Array - You are given a 0-indexed array nums of size n consisting of non-negative integers.

You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:

 * If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.

After performing all the operations, shift all the 0's to the end of the array.

 * For example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].

Return the resulting array.

Note that the operations are applied sequentially, not all at once.

 

Example 1:


Input: nums = [1,2,2,1,1,0]
Output: [1,4,2,0,0,0]
Explanation: We do the following operations:
- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.
- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].
- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.
- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].
- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].
After that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].


Example 2:


Input: nums = [0,1]
Output: [1,0]
Explanation: No operation can be applied, we just shift the 0 to the end.


 

Constraints:

 * 2 <= nums.length <= 2000
 * 0 <= nums[i] <= 1000",Solutions (632),331
FALSE,0,0,2550,,Words Within Two Edits of Dictionary,words-within-two-edits-of-dictionary,FALSE,15540,25738,2452,FALSE,2,"Can you solve this real interview question? Words Within Two Edits of Dictionary - You are given two string arrays, queries and dictionary. All words in each array comprise of lowercase English letters and have the same length.

In one edit you can take a word from queries, and change any letter in it to any other letter. Find all words from queries that, after a maximum of two edits, equal some word from dictionary.

Return a list of all words from queries, that match with some word from dictionary after a maximum of two edits. Return the words in the same order they appear in queries.

 

Example 1:


Input: queries = [""word"",""note"",""ants"",""wood""], dictionary = [""wood"",""joke"",""moat""]
Output: [""word"",""note"",""wood""]
Explanation:
- Changing the 'r' in ""word"" to 'o' allows it to equal the dictionary word ""wood"".
- Changing the 'n' to 'j' and the 't' to 'k' in ""note"" changes it to ""joke"".
- It would take more than 2 edits for ""ants"" to equal a dictionary word.
- ""wood"" can remain unchanged (0 edits) and match the corresponding dictionary word.
Thus, we return [""word"",""note"",""wood""].


Example 2:


Input: queries = [""yes""], dictionary = [""not""]
Output: []
Explanation:
Applying any two edits to ""yes"" cannot make it equal to ""not"". Thus, we return an empty array.


 

Constraints:

 * 1 <= queries.length, dictionary.length <= 100
 * n == queries[i].length == dictionary[j].length
 * 1 <= n <= 100
 * All queries[i] and dictionary[j] are composed of lowercase English letters.",Solutions (304),218
FALSE,0,0,2549,,Next Greater Element IV,next-greater-element-iv,FALSE,6390,16051,2454,FALSE,3,"Can you solve this real interview question? Next Greater Element IV - You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.

The second greater integer of nums[i] is nums[j] such that:

 * j > i
 * nums[j] > nums[i]
 * There exists exactly one index k such that nums[k] > nums[i] and i < k < j.

If there is no such nums[j], the second greater integer is considered to be -1.

 * For example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3, and that of 3 and 4 is -1.

Return an integer array answer, where answer[i] is the second greater integer of nums[i].

 

Example 1:


Input: nums = [2,4,0,9,6]
Output: [9,6,6,-1,-1]
Explanation:
0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.
1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.
2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.
3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.
4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.
Thus, we return [9,6,6,-1,-1].


Example 2:


Input: nums = [3,3]
Output: [-1,-1]
Explanation:
We return [-1,-1] since neither integer has any integer greater than it.


 

Constraints:

 * 1 <= nums.length <= 105
 * 0 <= nums[i] <= 109",Solutions (129),446
FALSE,0,0,2548,,Destroy Sequential Targets,destroy-sequential-targets,FALSE,11404,30212,2453,FALSE,2,"Can you solve this real interview question? Destroy Sequential Targets - You are given a 0-indexed array nums consisting of positive integers, representing targets on a number line. You are also given an integer space.

You have a machine which can destroy targets. Seeding the machine with some nums[i] allows it to destroy all targets with values that can be represented as nums[i] + c * space, where c is any non-negative integer. You want to destroy the maximum number of targets in nums.

Return the minimum value of nums[i] you can seed the machine with to destroy the maximum number of targets.

 

Example 1:


Input: nums = [3,7,8,1,1,5], space = 2
Output: 1
Explanation: If we seed the machine with nums[3], then we destroy all targets equal to 1,3,5,7,9,... 
In this case, we would destroy 5 total targets (all except for nums[2]). 
It is impossible to destroy more than 5 targets, so we return nums[3].


Example 2:


Input: nums = [1,3,5,2,4,6], space = 2
Output: 1
Explanation: Seeding the machine with nums[0], or nums[3] destroys 3 targets. 
It is not possible to destroy more than 3 targets.
Since nums[0] is the minimal integer that can destroy 3 targets, we return 1.


Example 3:


Input: nums = [6,2,5], space = 100
Output: 2
Explanation: Whatever initial seed we select, we can only destroy 1 target. The minimal seed is nums[1].


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109
 * 1 <= space <= 109",Solutions (216),361
FALSE,0,0,2547,,Odd String Difference,odd-string-difference,FALSE,20057,33393,2451,FALSE,1,"Can you solve this real interview question? Odd String Difference - You are given an array of equal-length strings words. Assume that the length of each string is n.

Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25.

 * For example, for the string ""acb"", the difference integer array is [2 - 0, 1 - 2] = [2, -1].

All the strings in words have the same difference integer array, except one. You should find that string.

Return the string in words that has different difference integer array.

 

Example 1:


Input: words = [""adc"",""wzy"",""abc""]
Output: ""abc""
Explanation: 
- The difference integer array of ""adc"" is [3 - 0, 2 - 3] = [3, -1].
- The difference integer array of ""wzy"" is [25 - 22, 24 - 25]= [3, -1].
- The difference integer array of ""abc"" is [1 - 0, 2 - 1] = [1, 1]. 
The odd array out is [1, 1], so we return the corresponding string, ""abc"".


Example 2:


Input: words = [""aaa"",""bob"",""ccc"",""ddd""]
Output: ""bob""
Explanation: All the integer arrays are [0, 0] except for ""bob"", which corresponds to [13, -13].


 

Constraints:

 * 3 <= words.length <= 100
 * n == words[i].length
 * 2 <= n <= 20
 * words[i] consists of lowercase English letters.",Solutions (421),280
FALSE,0,0,2546,,Number of Subarrays With GCD Equal to K,number-of-subarrays-with-gcd-equal-to-k,FALSE,19108,39283,2447,FALSE,2,"Can you solve this real interview question? Number of Subarrays With GCD Equal to K - Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray's elements is k.

A subarray is a contiguous non-empty sequence of elements within an array.

The greatest common divisor of an array is the largest integer that evenly divides all the array elements.

 

Example 1:


Input: nums = [9,3,1,2,6,3], k = 3
Output: 4
Explanation: The subarrays of nums where 3 is the greatest common divisor of all the subarray's elements are:
- [9,3,1,2,6,3]
- [9,3,1,2,6,3]
- [9,3,1,2,6,3]
- [9,3,1,2,6,3]


Example 2:


Input: nums = [4], k = 7
Output: 0
Explanation: There are no subarrays of nums where 7 is the greatest common divisor of all the subarray's elements.


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i], k <= 109",Solutions (239),343
FALSE,0,0,2545,,Height of Binary Tree After Subtree Removal Queries,height-of-binary-tree-after-subtree-removal-queries,FALSE,8482,22911,2458,FALSE,3,"Can you solve this real interview question? Height of Binary Tree After Subtree Removal Queries - You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m.

You have to perform m independent queries on the tree where in the ith query you do the following:

 * Remove the subtree rooted at the node with the value queries[i] from the tree. It is guaranteed that queries[i] will not be equal to the value of the root.

Return an array answer of size m where answer[i] is the height of the tree after performing the ith query.

Note:

 * The queries are independent, so the tree returns to its initial state after each query.
 * The height of a tree is the number of edges in the longest simple path from the root to some node in the tree.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png]


Input: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]
Output: [2]
Explanation: The diagram above shows the tree after removing the subtree rooted at node with value 4.
The height of the tree is 2 (The path 1 -> 3 -> 2).


Example 2:

[https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png]


Input: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]
Output: [3,2,3,2]
Explanation: We have the following queries:
- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).
- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1).
- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).
- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3).


 

Constraints:

 * The number of nodes in the tree is n.
 * 2 <= n <= 105
 * 1 <= Node.val <= n
 * All the values in the tree are unique.
 * m == queries.length
 * 1 <= m <= min(n, 104)
 * 1 <= queries[i] <= n
 * queries[i] != root.val",Solutions (189),445
FALSE,0,0,2544,,Minimum Addition to Make Integer Beautiful,minimum-addition-to-make-integer-beautiful,FALSE,15256,41207,2457,FALSE,2,"Can you solve this real interview question? Minimum Addition to Make Integer Beautiful - You are given two positive integers n and target.

An integer is considered beautiful if the sum of its digits is less than or equal to target.

Return the minimum non-negative integer x such that n + x is beautiful. The input will be generated such that it is always possible to make n beautiful.

 

Example 1:


Input: n = 16, target = 6
Output: 4
Explanation: Initially n is 16 and its digit sum is 1 + 6 = 7. After adding 4, n becomes 20 and digit sum becomes 2 + 0 = 2. It can be shown that we can not make n beautiful with adding non-negative integer less than 4.


Example 2:


Input: n = 467, target = 6
Output: 33
Explanation: Initially n is 467 and its digit sum is 4 + 6 + 7 = 17. After adding 33, n becomes 500 and digit sum becomes 5 + 0 + 0 = 5. It can be shown that we can not make n beautiful with adding non-negative integer less than 33.


Example 3:


Input: n = 1, target = 1
Output: 0
Explanation: Initially n is 1 and its digit sum is 1, which is already smaller than or equal to target.


 

Constraints:

 * 1 <= n <= 1012
 * 1 <= target <= 150
 * The input will be generated such that it is always possible to make n beautiful.",Solutions (364),421
FALSE,0,0,2543,,Most Popular Video Creator,most-popular-video-creator,FALSE,17676,40339,2456,FALSE,2,"Can you solve this real interview question? Most Popular Video Creator - You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creator[i], has an id of ids[i], and has views[i] views.

The popularity of a creator is the sum of the number of views on all of the creator's videos. Find the creator with the highest popularity and the id of their most viewed video.

 * If multiple creators have the highest popularity, find all of them.
 * If multiple videos have the highest view count for a creator, find the lexicographically smallest id.

Return a 2D array of strings answer where answer[i] = [creatori, idi] means that creatori has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order.

 

Example 1:


Input: creators = [""alice"",""bob"",""alice"",""chris""], ids = [""one"",""two"",""three"",""four""], views = [5,10,5,4]
Output: [[""alice"",""one""],[""bob"",""two""]]
Explanation:
The popularity of alice is 5 + 5 = 10.
The popularity of bob is 10.
The popularity of chris is 4.
alice and bob are the most popular creators.
For bob, the video with the highest view count is ""two"".
For alice, the videos with the highest view count are ""one"" and ""three"". Since ""one"" is lexicographically smaller than ""three"", it is included in the answer.


Example 2:


Input: creators = [""alice"",""alice"",""alice""], ids = [""a"",""b"",""c""], views = [1,2,2]
Output: [[""alice"",""b""]]
Explanation:
The videos with id ""b"" and ""c"" have the highest view count.
Since ""b"" is lexicographically smaller than ""c"", it is included in the answer.


 

Constraints:

 * n == creators.length == ids.length == views.length
 * 1 <= n <= 105
 * 1 <= creators[i].length, ids[i].length <= 5
 * creators[i] and ids[i] consist only of lowercase English letters.
 * 0 <= views[i] <= 105",Solutions (365),201
FALSE,0,0,2542,,Average Value of Even Numbers That Are Divisible by Three,average-value-of-even-numbers-that-are-divisible-by-three,FALSE,34633,58602,2455,FALSE,1,"Can you solve this real interview question? Average Value of Even Numbers That Are Divisible by Three - Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.

Note that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.

 

Example 1:


Input: nums = [1,3,6,10,12,15]
Output: 9
Explanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.


Example 2:


Input: nums = [1,2,4,7,10]
Output: 0
Explanation: There is no single number that satisfies the requirement, so return 0.


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i] <= 1000",Solutions (536),223
FALSE,0,0,2541,,Sum of Number and Its Reverse,sum-of-number-and-its-reverse,FALSE,27721,60569,2443,FALSE,2,"Can you solve this real interview question? Sum of Number and Its Reverse - Given a non-negative integer num, return true if num can be expressed as the sum of any non-negative integer and its reverse, or false otherwise.

 

Example 1:


Input: num = 443
Output: true
Explanation: 172 + 271 = 443 so we return true.


Example 2:


Input: num = 63
Output: false
Explanation: 63 cannot be expressed as the sum of a non-negative integer and its reverse so we return false.


Example 3:


Input: num = 181
Output: true
Explanation: 140 + 041 = 181 so we return true. Note that when a number is reversed, there may be leading zeros.


 

Constraints:

 * 0 <= num <= 105",Solutions (489),204
FALSE,0,0,2539,,Minimum Number of Operations to Make Arrays Similar,minimum-number-of-operations-to-make-arrays-similar,FALSE,8977,14045,2449,FALSE,3,"Can you solve this real interview question? Minimum Number of Operations to Make Arrays Similar - You are given two positive integer arrays nums and target, of the same length.

In one operation, you can choose any two distinct indices i and j where 0 <= i, j < nums.length and:

 * set nums[i] = nums[i] + 2 and
 * set nums[j] = nums[j] - 2.

Two arrays are considered to be similar if the frequency of each element is the same.

Return the minimum number of operations required to make nums similar to target. The test cases are generated such that nums can always be similar to target.

 

Example 1:


Input: nums = [8,12,6], target = [2,14,10]
Output: 2
Explanation: It is possible to make nums similar to target in two operations:
- Choose i = 0 and j = 2, nums = [10,12,4].
- Choose i = 1 and j = 2, nums = [10,14,2].
It can be shown that 2 is the minimum number of operations needed.


Example 2:


Input: nums = [1,2,5], target = [4,1,3]
Output: 1
Explanation: We can make nums similar to target in one operation:
- Choose i = 1 and j = 2, nums = [1,4,3].


Example 3:


Input: nums = [1,1,1,1,1], target = [1,1,1,1,1]
Output: 0
Explanation: The array nums is already similiar to target.


 

Constraints:

 * n == nums.length == target.length
 * 1 <= n <= 105
 * 1 <= nums[i], target[i] <= 106
 * It is possible to make nums similar to target.",Solutions (175),319
FALSE,0,0,2538,minimum-cost-to-make-array-equal,Minimum Cost to Make Array Equal,minimum-cost-to-make-array-equal,FALSE,12012,34555,2448,FALSE,3,"Can you solve this real interview question? Minimum Cost to Make Array Equal - You are given two 0-indexed arrays nums and cost consisting each of n positive integers.

You can do the following operation any number of times:

 * Increase or decrease any element of the array nums by 1.

The cost of doing one operation on the ith element is cost[i].

Return the minimum total cost such that all the elements of the array nums become equal.

 

Example 1:


Input: nums = [1,3,5,2], cost = [2,3,1,14]
Output: 8
Explanation: We can make all the elements equal to 2 in the following way:
- Increase the 0th element one time. The cost is 2.
- Decrease the 1st element one time. The cost is 3.
- Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3.
The total cost is 2 + 3 + 3 = 8.
It can be shown that we cannot make the array equal with a smaller cost.


Example 2:


Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3]
Output: 0
Explanation: All the elements are already equal, so no operations are needed.


 

Constraints:

 * n == nums.length == cost.length
 * 1 <= n <= 105
 * 1 <= nums[i], cost[i] <= 106",Solutions (243),571
FALSE,0,0,2536,,Determine if Two Events Have Conflict,determine-if-two-events-have-conflict,FALSE,27494,55060,2446,FALSE,1,"Can you solve this real interview question? Determine if Two Events Have Conflict - You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where:

 * event1 = [startTime1, endTime1] and
 * event2 = [startTime2, endTime2].

Event times are valid 24 hours format in the form of HH:MM.

A conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events).

Return true if there is a conflict between two events. Otherwise, return false.

 

Example 1:


Input: event1 = [""01:15"",""02:00""], event2 = [""02:00"",""03:00""]
Output: true
Explanation: The two events intersect at time 2:00.


Example 2:


Input: event1 = [""01:00"",""02:00""], event2 = [""01:20"",""03:00""]
Output: true
Explanation: The two events intersect starting from 01:20 to 02:00.


Example 3:


Input: event1 = [""10:00"",""11:00""], event2 = [""14:00"",""15:00""]
Output: false
Explanation: The two events do not intersect.


 

Constraints:

 * evnet1.length == event2.length == 2.
 * event1[i].length == event2[i].length == 5
 * startTime1 <= endTime1
 * startTime2 <= endTime2
 * All the event times follow the HH:MM format.",Solutions (392),292
FALSE,0,0,2533,,Bitwise XOR of All Pairings,bitwise-xor-of-all-pairings,FALSE,14160,24182,2425,FALSE,2,"Can you solve this real interview question? Bitwise XOR of All Pairings - You are given two 0-indexed arrays, nums1 and nums2, consisting of non-negative integers. There exists another array, nums3, which contains the bitwise XOR of all pairings of integers between nums1 and nums2 (every integer in nums1 is paired with every integer in nums2 exactly once).

Return the bitwise XOR of all integers in nums3.

 

Example 1:


Input: nums1 = [2,1,3], nums2 = [10,2,5,0]
Output: 13
Explanation:
A possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3].
The bitwise XOR of all these numbers is 13, so we return 13.


Example 2:


Input: nums1 = [1,2], nums2 = [3,4]
Output: 0
Explanation:
All possible pairs of bitwise XORs are nums1[0] ^ nums2[0], nums1[0] ^ nums2[1], nums1[1] ^ nums2[0],
and nums1[1] ^ nums2[1].
Thus, one possible nums3 array is [2,5,1,6].
2 ^ 5 ^ 1 ^ 6 = 0, so we return 0.


 

Constraints:

 * 1 <= nums1.length, nums2.length <= 105
 * 0 <= nums1[i], nums2[j] <= 109",Solutions (362),301
FALSE,0,0,2532,,Remove Letter To Equalize Frequency,remove-letter-to-equalize-frequency,FALSE,24551,136647,2423,FALSE,1,"Can you solve this real interview question? Remove Letter To Equalize Frequency - You are given a 0-indexed string word, consisting of lowercase English letters. You need to select one index and remove the letter at that index from word so that the frequency of every letter present in word is equal.

Return true if it is possible to remove one letter so that the frequency of all letters in word are equal, and false otherwise.

Note:

 * The frequency of a letter x is the number of times it occurs in the string.
 * You must remove exactly one letter and cannot chose to do nothing.

 

Example 1:


Input: word = ""abcc""
Output: true
Explanation: Select index 3 and delete it: word becomes ""abc"" and each character has a frequency of 1.


Example 2:


Input: word = ""aazz""
Output: false
Explanation: We must delete a character, so either the frequency of ""a"" is 1 and the frequency of ""z"" is 2, or vice versa. It is impossible to make all present letters have equal frequency.


 

Constraints:

 * 2 <= word.length <= 100
 * word consists of lowercase English letters only.",Solutions (628),377
FALSE,0,0,2531,,Create Components With Same Value,create-components-with-same-value,FALSE,4195,7687,2440,FALSE,3,"Can you solve this real interview question? Create Components With Same Value - There is an undirected tree with n nodes labeled from 0 to n - 1.

You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

You are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.

Return the maximum number of edges you can delete, such that every connected component in the tree has the same value.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/08/26/diagramdrawio.png]


Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] 
Output: 2 
Explanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.


Example 2:


Input: nums = [2], edges = []
Output: 0
Explanation: There are no edges to be deleted.


 

Constraints:

 * 1 <= n <= 2 * 104
 * nums.length == n
 * 1 <= nums[i] <= 50
 * edges.length == n - 1
 * edges[i].length == 2
 * 0 <= edges[i][0], edges[i][1] <= n - 1
 * edges represents a valid tree.",Solutions (81),283
FALSE,0,0,2530,minimize-maximum-of-array,Minimize Maximum of Array,minimize-maximum-of-array,FALSE,10983,31869,2439,FALSE,2,"Can you solve this real interview question? Minimize Maximum of Array - You are given a 0-indexed array nums comprising of n non-negative integers.

In one operation, you must:

 * Choose an integer i such that 1 <= i < n and nums[i] > 0.
 * Decrease nums[i] by 1.
 * Increase nums[i - 1] by 1.

Return the minimum possible value of the maximum integer of nums after performing any number of operations.

 

Example 1:


Input: nums = [3,7,1,6]
Output: 5
Explanation:
One set of optimal operations is as follows:
1. Choose i = 1, and nums becomes [4,6,1,6].
2. Choose i = 3, and nums becomes [4,6,2,5].
3. Choose i = 1, and nums becomes [5,5,2,5].
The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5.
Therefore, we return 5.


Example 2:


Input: nums = [10,1]
Output: 10
Explanation:
It is optimal to leave nums as is, and since 10 is the maximum value, we return 10.


 

Constraints:

 * n == nums.length
 * 2 <= n <= 105
 * 0 <= nums[i] <= 109",Solutions (183),482
FALSE,0,0,2529,,Range Product Queries of Powers,range-product-queries-of-powers,FALSE,13072,33598,2438,FALSE,2,"Can you solve this real interview question? Range Product Queries of Powers - Given a positive integer n, there exists a 0-indexed array called powers, composed of the minimum number of powers of 2 that sum to n. The array is sorted in non-decreasing order, and there is only one way to form the array.

You are also given a 0-indexed 2D integer array queries, where queries[i] = [lefti, righti]. Each queries[i] represents a query where you have to find the product of all powers[j] with lefti <= j <= righti.

Return an array answers, equal in length to queries, where answers[i] is the answer to the ith query. Since the answer to the ith query may be too large, each answers[i] should be returned modulo 109 + 7.

 

Example 1:


Input: n = 15, queries = [[0,1],[2,2],[0,3]]
Output: [2,4,64]
Explanation:
For n = 15, powers = [1,2,4,8]. It can be shown that powers cannot be a smaller size.
Answer to 1st query: powers[0] * powers[1] = 1 * 2 = 2.
Answer to 2nd query: powers[2] = 4.
Answer to 3rd query: powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64.
Each answer modulo 109 + 7 yields the same answer, so [2,4,64] is returned.


Example 2:


Input: n = 2, queries = [[0,0]]
Output: [2]
Explanation:
For n = 2, powers = [2].
The answer to the only query is powers[0] = 2. The answer modulo 109 + 7 is the same, so [2] is returned.


 

Constraints:

 * 1 <= n <= 109
 * 1 <= queries.length <= 105
 * 0 <= starti <= endi < powers.length",Solutions (264),239
FALSE,0,0,2528,,Number of Valid Clock Times,number-of-valid-clock-times,FALSE,17898,41504,2437,FALSE,1,"Can you solve this real interview question? Number of Valid Clock Times - You are given a string of length 5 called time, representing the current time on a digital clock in the format ""hh:mm"". The earliest possible time is ""00:00"" and the latest possible time is ""23:59"".

In the string time, the digits represented by the ? symbol are unknown, and must be replaced with a digit from 0 to 9.

Return an integer answer, the number of valid clock times that can be created by replacing every ? with a digit from 0 to 9.

 

Example 1:


Input: time = ""?5:00""
Output: 2
Explanation: We can replace the ? with either a 0 or 1, producing ""05:00"" or ""15:00"". Note that we cannot replace it with a 2, since the time ""25:00"" is invalid. In total, we have two choices.


Example 2:


Input: time = ""0?:0?""
Output: 100
Explanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.


Example 3:


Input: time = ""??:??""
Output: 1440
Explanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 * 60 = 1440 choices.


 

Constraints:

 * time is a valid string of length 5 in the format ""hh:mm"".
 * ""00"" <= hh <= ""23""
 * ""00"" <= mm <= ""59""
 * Some of the digits might be replaced with '?' and need to be replaced with digits from 0 to 9.",Solutions (383),181
FALSE,0,0,2527,count-subarrays-with-fixed-bounds,Count Subarrays With Fixed Bounds,count-subarrays-with-fixed-bounds,FALSE,55135,88899,2444,FALSE,3,"Can you solve this real interview question? Count Subarrays With Fixed Bounds - You are given an integer array nums and two integers minK and maxK.

A fixed-bound subarray of nums is a subarray that satisfies the following conditions:

 * The minimum value in the subarray is equal to minK.
 * The maximum value in the subarray is equal to maxK.

Return the number of fixed-bound subarrays.

A subarray is a contiguous part of an array.

 

Example 1:


Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5
Output: 2
Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].


Example 2:


Input: nums = [1,1,1,1], minK = 1, maxK = 1
Output: 10
Explanation: Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays.


 

Constraints:

 * 2 <= nums.length <= 105
 * 1 <= nums[i], minK, maxK <= 106",Solutions (601),2.1K
FALSE,0,0,2526,,Longest Increasing Subsequence II,longest-increasing-subsequence-ii,FALSE,7925,36543,2407,FALSE,3,"Can you solve this real interview question? Longest Increasing Subsequence II - You are given an integer array nums and an integer k.

Find the longest subsequence of nums that meets the following requirements:

 * The subsequence is strictly increasing and
 * The difference between adjacent elements in the subsequence is at most k.

Return the length of the longest subsequence that meets the requirements.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:


Input: nums = [4,2,1,4,3,4,5,8,15], k = 3
Output: 5
Explanation:
The longest subsequence that meets the requirements is [1,3,4,5,8].
The subsequence has a length of 5, so we return 5.
Note that the subsequence [1,3,4,5,8,15] does not meet the requirements because 15 - 8 = 7 is larger than 3.


Example 2:


Input: nums = [7,4,5,1,8,12,4,7], k = 5
Output: 4
Explanation:
The longest subsequence that meets the requirements is [4,5,8,12].
The subsequence has a length of 4, so we return 4.


Example 3:


Input: nums = [1,5], k = 1
Output: 1
Explanation:
The longest subsequence that meets the requirements is [1].
The subsequence has a length of 1, so we return 1.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i], k <= 105",Solutions (143),550
FALSE,0,0,2525,,Count Number of Distinct Integers After Reverse Operations,count-number-of-distinct-integers-after-reverse-operations,FALSE,35435,45005,2442,FALSE,2,"Can you solve this real interview question? Count Number of Distinct Integers After Reverse Operations - You are given an array nums consisting of positive integers.

You have to take each integer in the array, reverse its digits, and add it to the end of the array. You should apply this operation to the original integers in nums.

Return the number of distinct integers in the final array.

 

Example 1:


Input: nums = [1,13,10,12,31]
Output: 6
Explanation: After including the reverse of each number, the resulting array is [1,13,10,12,31,1,31,1,21,13].
The reversed integers that were added to the end of the array are underlined. Note that for the integer 10, after reversing it, it becomes 01 which is just 1.
The number of distinct integers in this array is 6 (The numbers 1, 10, 12, 13, 21, and 31).

Example 2:


Input: nums = [2,2,2]
Output: 1
Explanation: After including the reverse of each number, the resulting array is [2,2,2,2,2,2].
The number of distinct integers in this array is 1 (The number 2).


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 106",Solutions (754),396
FALSE,0,0,2524,,Largest Positive Integer That Exists With Its Negative,largest-positive-integer-that-exists-with-its-negative,FALSE,37326,54860,2441,FALSE,1,"Can you solve this real interview question? Largest Positive Integer That Exists With Its Negative - Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.

Return the positive integer k. If there is no such integer, return -1.

 

Example 1:


Input: nums = [-1,2,-3,3]
Output: 3
Explanation: 3 is the only valid k we can find in the array.


Example 2:


Input: nums = [-1,10,6,7,-7,1]
Output: 7
Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.


Example 3:


Input: nums = [-10,8,6,7,-2,-3]
Output: -1
Explanation: There is no a single valid k, we return -1.


 

Constraints:

 * 1 <= nums.length <= 1000
 * -1000 <= nums[i] <= 1000
 * nums[i] != 0",Solutions (699),344
FALSE,0,0,2521,,Paths in Matrix Whose Sum Is Divisible by K,paths-in-matrix-whose-sum-is-divisible-by-k,FALSE,15063,36239,2435,FALSE,3,"Can you solve this real interview question? Paths in Matrix Whose Sum Is Divisible by K - You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.

Return the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/08/13/image-20220813183124-1.png]


Input: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3
Output: 2
Explanation: There are two paths where the sum of the elements on the path is divisible by k.
The first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.
The second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.


Example 2:

[https://assets.leetcode.com/uploads/2022/08/17/image-20220817112930-3.png]


Input: grid = [[0,0]], k = 5
Output: 1
Explanation: The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.


Example 3:

[https://assets.leetcode.com/uploads/2022/08/12/image-20220812224605-3.png]


Input: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1
Output: 10
Explanation: Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 5 * 104
 * 1 <= m * n <= 5 * 104
 * 0 <= grid[i][j] <= 100
 * 1 <= k <= 50",Solutions (344),572
FALSE,0,0,2520,,Using a Robot to Print the Lexicographically Smallest String,using-a-robot-to-print-the-lexicographically-smallest-string,FALSE,13909,36074,2434,FALSE,2,"Can you solve this real interview question? Using a Robot to Print the Lexicographically Smallest String - You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:

 * Remove the first character of a string s and give it to the robot. The robot will append this character to the string t.
 * Remove the last character of a string t and give it to the robot. The robot will write this character on paper.

Return the lexicographically smallest string that can be written on the paper.

 

Example 1:


Input: s = ""zza""
Output: ""azz""
Explanation: Let p denote the written string.
Initially p="""", s=""zza"", t="""".
Perform first operation three times p="""", s="""", t=""zza"".
Perform second operation three times p=""azz"", s="""", t="""".


Example 2:


Input: s = ""bac""
Output: ""abc""
Explanation: Let p denote the written string.
Perform first operation twice p="""", s=""c"", t=""ba"". 
Perform second operation twice p=""ab"", s=""c"", t="""". 
Perform first operation p=""ab"", s="""", t=""c"". 
Perform second operation p=""abc"", s="""", t="""".


Example 3:


Input: s = ""bdda""
Output: ""addb""
Explanation: Let p denote the written string.
Initially p="""", s=""bdda"", t="""".
Perform first operation four times p="""", s="""", t=""bdda"".
Perform second operation four times p=""addb"", s="""", t="""".


 

Constraints:

 * 1 <= s.length <= 105
 * s consists of only English lowercase letters.",Solutions (276),541
FALSE,0,0,2519,,Find The Original Array of Prefix Xor,find-the-original-array-of-prefix-xor,FALSE,31413,36699,2433,FALSE,2,"Can you solve this real interview question? Find The Original Array of Prefix Xor - You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:

 * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].

Note that ^ denotes the bitwise-xor operation.

It can be proven that the answer is unique.

 

Example 1:


Input: pref = [5,2,0,3,1]
Output: [5,7,2,3,2]
Explanation: From the array [5,7,2,3,2] we have the following:
- pref[0] = 5.
- pref[1] = 5 ^ 7 = 2.
- pref[2] = 5 ^ 7 ^ 2 = 0.
- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.
- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.


Example 2:


Input: pref = [13]
Output: [13]
Explanation: We have pref[0] = arr[0] = 13.


 

Constraints:

 * 1 <= pref.length <= 105
 * 0 <= pref[i] <= 106",Solutions (574),468
FALSE,0,0,2518,,The Employee That Worked on the Longest Task,the-employee-that-worked-on-the-longest-task,FALSE,26974,54544,2432,FALSE,1,"Can you solve this real interview question? The Employee That Worked on the Longest Task - There are n employees, each with a unique id from 0 to n - 1.

You are given a 2D integer array logs where logs[i] = [idi, leaveTimei] where:

 * idi is the id of the employee that worked on the ith task, and
 * leaveTimei is the time at which the employee finished the ith task. All the values leaveTimei are unique.

Note that the ith task starts the moment right after the (i - 1)th task ends, and the 0th task starts at time 0.

Return the id of the employee that worked the task with the longest time. If there is a tie between two or more employees, return the smallest id among them.

 

Example 1:


Input: n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]
Output: 1
Explanation: 
Task 0 started at 0 and ended at 3 with 3 units of times.
Task 1 started at 3 and ended at 5 with 2 units of times.
Task 2 started at 5 and ended at 9 with 4 units of times.
Task 3 started at 9 and ended at 15 with 6 units of times.
The task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.


Example 2:


Input: n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]
Output: 3
Explanation: 
Task 0 started at 0 and ended at 1 with 1 unit of times.
Task 1 started at 1 and ended at 7 with 6 units of times.
Task 2 started at 7 and ended at 12 with 5 units of times.
Task 3 started at 12 and ended at 17 with 5 units of times.
The tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3.


Example 3:


Input: n = 2, logs = [[0,10],[1,20]]
Output: 0
Explanation: 
Task 0 started at 0 and ended at 10 with 10 units of times.
Task 1 started at 10 and ended at 20 with 10 units of times.
The tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.


 

Constraints:

 * 2 <= n <= 500
 * 1 <= logs.length <= 500
 * logs[i].length == 2
 * 0 <= idi <= n - 1
 * 1 <= leaveTimei <= 500
 * idi != idi+1
 * leaveTimei are sorted in a strictly increasing order.",Solutions (407),207
FALSE,0,0,2513,,Number of Pairs Satisfying Inequality,number-of-pairs-satisfying-inequality,FALSE,8851,20624,2426,FALSE,3,"Can you solve this real interview question? Number of Pairs Satisfying Inequality - You are given two 0-indexed integer arrays nums1 and nums2, each of size n, and an integer diff. Find the number of pairs (i, j) such that:

 * 0 <= i < j <= n - 1 and
 * nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.

Return the number of pairs that satisfy the conditions.

 

Example 1:


Input: nums1 = [3,2,5], nums2 = [2,2,1], diff = 1
Output: 3
Explanation:
There are 3 pairs that satisfy the conditions:
1. i = 0, j = 1: 3 - 2 <= 2 - 2 + 1. Since i < j and 1 <= 1, this pair satisfies the conditions.
2. i = 0, j = 2: 3 - 5 <= 2 - 1 + 1. Since i < j and -2 <= 2, this pair satisfies the conditions.
3. i = 1, j = 2: 2 - 5 <= 2 - 1 + 1. Since i < j and -3 <= 2, this pair satisfies the conditions.
Therefore, we return 3.


Example 2:


Input: nums1 = [3,-1], nums2 = [-2,2], diff = -1
Output: 0
Explanation:
Since there does not exist any pair that satisfies the conditions, we return 0.


 

Constraints:

 * n == nums1.length == nums2.length
 * 2 <= n <= 105
 * -104 <= nums1[i], nums2[i] <= 104
 * -104 <= diff <= 104",Solutions (175),403
FALSE,0,0,2512,,Longest Uploaded Prefix,longest-uploaded-prefix,FALSE,14974,27728,2424,FALSE,2,"Can you solve this real interview question? Longest Uploaded Prefix - You are given a stream of n videos, each represented by a distinct number from 1 to n that you need to ""upload"" to a server. You need to implement a data structure that calculates the length of the longest uploaded prefix at various points in the upload process.

We consider i to be an uploaded prefix if all videos in the range 1 to i (inclusive) have been uploaded to the server. The longest uploaded prefix is the maximum value of i that satisfies this definition.

Implement the LUPrefix class:

 * LUPrefix(int n) Initializes the object for a stream of n videos.
 * void upload(int video) Uploads video to the server.
 * int longest() Returns the length of the longest uploaded prefix defined above.

 

Example 1:


Input
[""LUPrefix"", ""upload"", ""longest"", ""upload"", ""longest"", ""upload"", ""longest""]
[[4], [3], [], [1], [], [2], []]
Output
[null, null, 0, null, 1, null, 3]

Explanation
LUPrefix server = new LUPrefix(4);   // Initialize a stream of 4 videos.
server.upload(3);                    // Upload video 3.
server.longest();                    // Since video 1 has not been uploaded yet, there is no prefix.
                                     // So, we return 0.
server.upload(1);                    // Upload video 1.
server.longest();                    // The prefix [1] is the longest uploaded prefix, so we return 1.
server.upload(2);                    // Upload video 2.
server.longest();                    // The prefix [1,2,3] is the longest uploaded prefix, so we return 3.


 

Constraints:

 * 1 <= n <= 105
 * 1 <= video <= n
 * All values of video are distinct.
 * At most 2 * 105 calls in total will be made to upload and longest.
 * At least one call will be made to longest.",Solutions (289),259
FALSE,0,0,2511,,Partition String Into Substrings With Values at Most K,partition-string-into-substrings-with-values-at-most-k,FALSE,15542,33269,2522,FALSE,2,"Can you solve this real interview question? Partition String Into Substrings With Values at Most K - You are given a string s consisting of digits from 1 to 9 and an integer k.

A partition of a string s is called good if:

 * Each digit of s is part of exactly one substring.
 * The value of each substring is less than or equal to k.

Return the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.

Note that:

 * The value of a string is its result when interpreted as an integer. For example, the value of ""123"" is 123 and the value of ""1"" is 1.
 * A substring is a contiguous sequence of characters within a string.

 

Example 1:


Input: s = ""165462"", k = 60
Output: 4
Explanation: We can partition the string into substrings ""16"", ""54"", ""6"", and ""2"". Each substring has a value less than or equal to k = 60.
It can be shown that we cannot partition the string into less than 4 substrings.


Example 2:


Input: s = ""238182"", k = 5
Output: -1
Explanation: There is no good partition for this string.


 

Constraints:

 * 1 <= s.length <= 105
 * s[i] is a digit from '1' to '9'.
 * 1 <= k <= 109

 ",Solutions (350),269
FALSE,0,0,2510,,Maximum Deletions on a String,maximum-deletions-on-a-string,FALSE,10294,31943,2430,FALSE,3,"Can you solve this real interview question? Maximum Deletions on a String - You are given a string s consisting of only lowercase English letters. In one operation, you can:

 * Delete the entire string s, or
 * Delete the first i letters of s if the first i letters of s are equal to the following i letters in s, for any i in the range 1 <= i <= s.length / 2.

For example, if s = ""ababc"", then in one operation, you could delete the first two letters of s to get ""abc"", since the first two letters of s and the following two letters of s are both equal to ""ab"".

Return the maximum number of operations needed to delete all of s.

 

Example 1:


Input: s = ""abcabcdabc""
Output: 2
Explanation:
- Delete the first 3 letters (""abc"") since the next 3 letters are equal. Now, s = ""abcdabc"".
- Delete all the letters.
We used 2 operations so return 2. It can be proven that 2 is the maximum number of operations needed.
Note that in the second operation we cannot delete ""abc"" again because the next occurrence of ""abc"" does not happen in the next 3 letters.


Example 2:


Input: s = ""aaabaab""
Output: 4
Explanation:
- Delete the first letter (""a"") since the next letter is equal. Now, s = ""aabaab"".
- Delete the first 3 letters (""aab"") since the next 3 letters are equal. Now, s = ""aab"".
- Delete the first letter (""a"") since the next letter is equal. Now, s = ""ab"".
- Delete all the letters.
We used 4 operations so return 4. It can be proven that 4 is the maximum number of operations needed.


Example 3:


Input: s = ""aaaaa""
Output: 5
Explanation: In each operation, we can delete the first letter of s.


 

Constraints:

 * 1 <= s.length <= 4000
 * s consists only of lowercase English letters.",Solutions (187),382
FALSE,0,0,2509,,Minimize XOR,minimize-xor,FALSE,17511,41169,2429,FALSE,2,"Can you solve this real interview question? Minimize XOR - Given two positive integers num1 and num2, find the positive integer x such that:

 * x has the same number of set bits as num2, and
 * The value x XOR num1 is minimal.

Note that XOR is the bitwise XOR operation.

Return the integer x. The test cases are generated such that x is uniquely determined.

The number of set bits of an integer is the number of 1's in its binary representation.

 

Example 1:


Input: num1 = 3, num2 = 5
Output: 3
Explanation:
The binary representations of num1 and num2 are 0011 and 0101, respectively.
The integer 3 has the same number of set bits as num2, and the value 3 XOR 3 = 0 is minimal.


Example 2:


Input: num1 = 1, num2 = 12
Output: 3
Explanation:
The binary representations of num1 and num2 are 0001 and 1100, respectively.
The integer 3 has the same number of set bits as num2, and the value 3 XOR 1 = 2 is minimal.


 

Constraints:

 * 1 <= num1, num2 <= 109",Solutions (325),347
FALSE,0,0,2508,,Maximum Sum of an Hourglass,maximum-sum-of-an-hourglass,FALSE,26804,36097,2428,FALSE,2,"Can you solve this real interview question? Maximum Sum of an Hourglass - You are given an m x n integer matrix grid.

We define an hourglass as a part of the matrix with the following form:

[https://assets.leetcode.com/uploads/2022/08/21/img.jpg]

Return the maximum sum of the elements of an hourglass.

Note that an hourglass cannot be rotated and must be entirely contained within the matrix.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/08/21/1.jpg]


Input: grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]
Output: 30
Explanation: The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.


Example 2:

[https://assets.leetcode.com/uploads/2022/08/21/2.jpg]


Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
Output: 35
Explanation: There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 3 <= m, n <= 150
 * 0 <= grid[i][j] <= 106",Solutions (470),313
FALSE,0,0,2507,,Number of Common Factors,number-of-common-factors,FALSE,45060,56499,2427,FALSE,1,"Can you solve this real interview question? Number of Common Factors - Given two positive integers a and b, return the number of common factors of a and b.

An integer x is a common factor of a and b if x divides both a and b.

 

Example 1:


Input: a = 12, b = 6
Output: 4
Explanation: The common factors of 12 and 6 are 1, 2, 3, 6.


Example 2:


Input: a = 25, b = 30
Output: 2
Explanation: The common factors of 25 and 30 are 1, 5.


 

Constraints:

 * 1 <= a, b <= 1000",Solutions (826),377
FALSE,0,0,2505,number-of-good-paths,Number of Good Paths,number-of-good-paths,FALSE,47950,83344,2421,FALSE,3,"Can you solve this real interview question? Number of Good Paths - There is a tree (i.e. a connected, undirected graph with no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges.

You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.

A good path is a simple path that satisfies the following conditions:

 1. The starting node and the ending node have the same value.
 2. All nodes between the starting node and the ending node have values less than or equal to the starting node (i.e. the starting node's value should be the maximum value along the path).

Return the number of distinct good paths.

Note that a path and its reverse are counted as the same path. For example, 0 -> 1 is considered to be the same as 1 -> 0. A single node is also considered as a valid path.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png]


Input: vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
Output: 6
Explanation: There are 5 good paths consisting of a single node.
There is 1 additional good path: 1 -> 0 -> 2 -> 4.
(The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)
Note that 0 -> 2 -> 3 is not a good path because vals[2] > vals[0].


Example 2:

[https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png]


Input: vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
Output: 7
Explanation: There are 5 good paths consisting of a single node.
There are 2 additional good paths: 0 -> 1 and 2 -> 3.


Example 3:

[https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png]


Input: vals = [1], edges = []
Output: 1
Explanation: The tree consists of only one node, so there is one good path.


 

Constraints:

 * n == vals.length
 * 1 <= n <= 3 * 104
 * 0 <= vals[i] <= 105
 * edges.length == n - 1
 * edges[i].length == 2
 * 0 <= ai, bi < n
 * ai != bi
 * edges represents a valid tree.",Solutions (366),1.9K
FALSE,0,0,2504,,Find All Good Indices,find-all-good-indices,FALSE,18202,48473,2420,FALSE,2,"Can you solve this real interview question? Find All Good Indices - You are given a 0-indexed integer array nums of size n and a positive integer k.

We call an index i in the range k <= i < n - k good if the following conditions are satisfied:

 * The k elements that are just before the index i are in non-increasing order.
 * The k elements that are just after the index i are in non-decreasing order.

Return an array of all good indices sorted in increasing order.

 

Example 1:


Input: nums = [2,1,1,1,3,4,1], k = 2
Output: [2,3]
Explanation: There are two good indices in the array:
- Index 2. The subarray [2,1] is in non-increasing order, and the subarray [1,3] is in non-decreasing order.
- Index 3. The subarray [1,1] is in non-increasing order, and the subarray [3,4] is in non-decreasing order.
Note that the index 4 is not good because [4,1] is not non-decreasing.

Example 2:


Input: nums = [2,1,1,2], k = 2
Output: []
Explanation: There are no good indices in this array.


 

Constraints:

 * n == nums.length
 * 3 <= n <= 105
 * 1 <= nums[i] <= 106
 * 1 <= k <= n / 2",Solutions (328),498
FALSE,0,0,2503,,Longest Subarray With Maximum Bitwise AND,longest-subarray-with-maximum-bitwise-and,FALSE,21267,44330,2419,FALSE,2,"Can you solve this real interview question? Longest Subarray With Maximum Bitwise AND - You are given an integer array nums of size n.

Consider a non-empty subarray from nums that has the maximum possible bitwise AND.

 * In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.

Return the length of the longest such subarray.

The bitwise AND of an array is the bitwise AND of all the numbers in it.

A subarray is a contiguous sequence of elements within an array.

 

Example 1:


Input: nums = [1,2,3,3,2,2]
Output: 2
Explanation:
The maximum possible bitwise AND of a subarray is 3.
The longest subarray with that value is [3,3], so we return 2.


Example 2:


Input: nums = [1,2,3,4]
Output: 1
Explanation:
The maximum possible bitwise AND of a subarray is 4.
The longest subarray with that value is [4], so we return 1.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 106",Solutions (373),346
FALSE,0,0,2502,,Sort the People,sort-the-people,FALSE,67470,83193,2418,FALSE,1,"Can you solve this real interview question? Sort the People - You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.

For each index i, names[i] and heights[i] denote the name and height of the ith person.

Return names sorted in descending order by the people's heights.

 

Example 1:


Input: names = [""Mary"",""John"",""Emma""], heights = [180,165,170]
Output: [""Mary"",""Emma"",""John""]
Explanation: Mary is the tallest, followed by Emma and John.


Example 2:


Input: names = [""Alice"",""Bob"",""Bob""], heights = [155,185,150]
Output: [""Bob"",""Alice"",""Bob""]
Explanation: The first Bob is the tallest, followed by Alice and the second Bob.


 

Constraints:

 * n == names.length == heights.length
 * 1 <= n <= 103
 * 1 <= names[i].length <= 20
 * 1 <= heights[i] <= 105
 * names[i] consists of lower and upper case English letters.
 * All the values of heights are distinct.",Solutions (1.4K),788
FALSE,0,0,2499,,Minimum Money Required Before Transactions,minimum-money-required-before-transactions,FALSE,8371,21113,2412,FALSE,3,"Can you solve this real interview question? Minimum Money Required Before Transactions - You are given a 0-indexed 2D integer array transactions, where transactions[i] = [costi, cashbacki].

The array describes transactions, where each transaction must be completed exactly once in some order. At any given moment, you have a certain amount of money. In order to complete transaction i, money >= costi must hold true. After performing a transaction, money becomes money - costi + cashbacki.

Return the minimum amount of money required before any transaction so that all of the transactions can be completed regardless of the order of the transactions.

 

Example 1:


Input: transactions = [[2,1],[5,0],[4,2]]
Output: 10
Explanation:
Starting with money = 10, the transactions can be performed in any order.
It can be shown that starting with money < 10 will fail to complete all transactions in some order.


Example 2:


Input: transactions = [[3,0],[0,3]]
Output: 3
Explanation:
- If transactions are in the order [[3,0],[0,3]], the minimum money required to complete the transactions is 3.
- If transactions are in the order [[0,3],[3,0]], the minimum money required to complete the transactions is 0.
Thus, starting with money = 3, the transactions can be performed in any order.


 

Constraints:

 * 1 <= transactions.length <= 105
 * transactions[i].length == 2
 * 0 <= costi, cashbacki <= 109",Solutions (123),326
FALSE,0,0,2498,,Smallest Subarrays With Maximum Bitwise OR,smallest-subarrays-with-maximum-bitwise-or,FALSE,9423,22632,2411,FALSE,2,"Can you solve this real interview question? Smallest Subarrays With Maximum Bitwise OR - You are given a 0-indexed array nums of length n, consisting of non-negative integers. For each index i from 0 to n - 1, you must determine the size of the minimum sized non-empty subarray of nums starting at i (inclusive) that has the maximum possible bitwise OR.

 * In other words, let Bij be the bitwise OR of the subarray nums[i...j]. You need to find the smallest subarray starting at i, such that bitwise OR of this subarray is equal to max(Bik) where i <= k <= n - 1.

The bitwise OR of an array is the bitwise OR of all the numbers in it.

Return an integer array answer of size n where answer[i] is the length of the minimum sized subarray starting at i with maximum bitwise OR.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: nums = [1,0,2,1,3]
Output: [3,3,2,2,1]
Explanation:
The maximum possible bitwise OR starting at any index is 3. 
- Starting at index 0, the shortest subarray that yields it is [1,0,2].
- Starting at index 1, the shortest subarray that yields the maximum bitwise OR is [0,2,1].
- Starting at index 2, the shortest subarray that yields the maximum bitwise OR is [2,1].
- Starting at index 3, the shortest subarray that yields the maximum bitwise OR is [1,3].
- Starting at index 4, the shortest subarray that yields the maximum bitwise OR is [3].
Therefore, we return [3,3,2,2,1]. 


Example 2:


Input: nums = [1,2]
Output: [2,1]
Explanation:
Starting at index 0, the shortest subarray that yields the maximum bitwise OR is of length 2.
Starting at index 1, the shortest subarray that yields the maximum bitwise OR is of length 1.
Therefore, we return [2,1].


 

Constraints:

 * n == nums.length
 * 1 <= n <= 105
 * 0 <= nums[i] <= 109",Solutions (166),435
FALSE,0,0,2497,,Maximum Matching of Players With Trainers,maximum-matching-of-players-with-trainers,FALSE,22915,37592,2410,FALSE,2,"Can you solve this real interview question? Maximum Matching of Players With Trainers - You are given a 0-indexed integer array players, where players[i] represents the ability of the ith player. You are also given a 0-indexed integer array trainers, where trainers[j] represents the training capacity of the jth trainer.

The ith player can match with the jth trainer if the player's ability is less than or equal to the trainer's training capacity. Additionally, the ith player can be matched with at most one trainer, and the jth trainer can be matched with at most one player.

Return the maximum number of matchings between players and trainers that satisfy these conditions.

 

Example 1:


Input: players = [4,7,9], trainers = [8,2,5,8]
Output: 2
Explanation:
One of the ways we can form two matchings is as follows:
- players[0] can be matched with trainers[0] since 4 <= 8.
- players[1] can be matched with trainers[3] since 7 <= 8.
It can be proven that 2 is the maximum number of matchings that can be formed.


Example 2:


Input: players = [1,1,1], trainers = [10]
Output: 1
Explanation:
The trainer can be matched with any of the 3 players.
Each player can only be matched with one trainer, so the maximum answer is 1.


 

Constraints:

 * 1 <= players.length, trainers.length <= 105
 * 1 <= players[i], trainers[j] <= 109",Solutions (478),316
FALSE,0,0,2496,,Count Days Spent Together,count-days-spent-together,FALSE,16770,38514,2409,FALSE,1,"Can you solve this real interview question? Count Days Spent Together - Alice and Bob are traveling to Rome for separate business meetings.

You are given 4 strings arriveAlice, leaveAlice, arriveBob, and leaveBob. Alice will be in the city from the dates arriveAlice to leaveAlice (inclusive), while Bob will be in the city from the dates arriveBob to leaveBob (inclusive). Each will be a 5-character string in the format ""MM-DD"", corresponding to the month and day of the date.

Return the total number of days that Alice and Bob are in Rome together.

You can assume that all dates occur in the same calendar year, which is not a leap year. Note that the number of days per month can be represented as: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].

 

Example 1:


Input: arriveAlice = ""08-15"", leaveAlice = ""08-18"", arriveBob = ""08-16"", leaveBob = ""08-19""
Output: 3
Explanation: Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.


Example 2:


Input: arriveAlice = ""10-01"", leaveAlice = ""10-31"", arriveBob = ""11-01"", leaveBob = ""12-31""
Output: 0
Explanation: There is no day when Alice and Bob are in Rome together, so we return 0.


 

Constraints:

 * All dates are provided in the format ""MM-DD"".
 * Alice and Bob's arrival dates are earlier than or equal to their leaving dates.
 * The given dates are valid dates of a non-leap year.",Solutions (485),194
FALSE,0,0,2494,,Sum of Prefix Scores of Strings,sum-of-prefix-scores-of-strings,FALSE,19728,44963,2416,FALSE,3,"Can you solve this real interview question? Sum of Prefix Scores of Strings - You are given an array words of size n consisting of non-empty strings.

We define the score of a string word as the number of strings words[i] such that word is a prefix of words[i].

 * For example, if words = [""a"", ""ab"", ""abc"", ""cab""], then the score of ""ab"" is 2, since ""ab"" is a prefix of both ""ab"" and ""abc"".

Return an array answer of size n where answer[i] is the sum of scores of every non-empty prefix of words[i].

Note that a string is considered as a prefix of itself.

 

Example 1:


Input: words = [""abc"",""ab"",""bc"",""b""]
Output: [5,4,3,2]
Explanation: The answer for each string is the following:
- ""abc"" has 3 prefixes: ""a"", ""ab"", and ""abc"".
- There are 2 strings with the prefix ""a"", 2 strings with the prefix ""ab"", and 1 string with the prefix ""abc"".
The total is answer[0] = 2 + 2 + 1 = 5.
- ""ab"" has 2 prefixes: ""a"" and ""ab"".
- There are 2 strings with the prefix ""a"", and 2 strings with the prefix ""ab"".
The total is answer[1] = 2 + 2 = 4.
- ""bc"" has 2 prefixes: ""b"" and ""bc"".
- There are 2 strings with the prefix ""b"", and 1 string with the prefix ""bc"".
The total is answer[2] = 2 + 1 = 3.
- ""b"" has 1 prefix: ""b"".
- There are 2 strings with the prefix ""b"".
The total is answer[3] = 2.


Example 2:


Input: words = [""abcd""]
Output: [4]
Explanation:
""abcd"" has 4 prefixes: ""a"", ""ab"", ""abc"", and ""abcd"".
Each prefix has a score of one, so the total is answer[0] = 1 + 1 + 1 + 1 = 4.


 

Constraints:

 * 1 <= words.length <= 1000
 * 1 <= words[i].length <= 1000
 * words[i] consists of lowercase English letters.",Solutions (419),550
FALSE,0,0,2493,,Reverse Odd Levels of Binary Tree,reverse-odd-levels-of-binary-tree,FALSE,31943,41603,2415,FALSE,2,"Can you solve this real interview question? Reverse Odd Levels of Binary Tree - Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.

 * For example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].

Return the root of the reversed tree.

A binary tree is perfect if all parent nodes have two children and all leaves are on the same level.

The level of a node is the number of edges along the path between it and the root node.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/07/28/first_case1.png]


Input: root = [2,3,5,8,13,21,34]
Output: [2,5,3,8,13,21,34]
Explanation: 
The tree has only one odd level.
The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.


Example 2:

[https://assets.leetcode.com/uploads/2022/07/28/second_case3.png]


Input: root = [7,13,11]
Output: [7,11,13]
Explanation: 
The nodes at level 1 are 13, 11, which are reversed and become 11, 13.


Example 3:


Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]
Output: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]
Explanation: 
The odd levels have non-zero values.
The nodes at level 1 were 1, 2, and are 2, 1 after the reversal.
The nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.


 

Constraints:

 * The number of nodes in the tree is in the range [1, 214].
 * 0 <= Node.val <= 105
 * root is a perfect binary tree.",Solutions (670),734
FALSE,0,0,2492,,Length of the Longest Alphabetical Continuous Substring,length-of-the-longest-alphabetical-continuous-substring,FALSE,32170,57174,2414,FALSE,2,"Can you solve this real interview question? Length of the Longest Alphabetical Continuous Substring - An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string ""abcdefghijklmnopqrstuvwxyz"".

 * For example, ""abc"" is an alphabetical continuous string, while ""acb"" and ""za"" are not.

Given a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring.

 

Example 1:


Input: s = ""abacaba""
Output: 2
Explanation: There are 4 distinct continuous substrings: ""a"", ""b"", ""c"" and ""ab"".
""ab"" is the longest continuous substring.


Example 2:


Input: s = ""abcde""
Output: 5
Explanation: ""abcde"" is the longest continuous substring.


 

Constraints:

 * 1 <= s.length <= 105
 * s consists of only English lowercase letters.",Solutions (606),347
FALSE,0,0,2491,,Smallest Even Multiple,smallest-even-multiple,FALSE,77705,88648,2413,FALSE,1,"Can you solve this real interview question? Smallest Even Multiple - Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.

 

Example 1:


Input: n = 5
Output: 10
Explanation: The smallest multiple of both 5 and 2 is 10.


Example 2:


Input: n = 6
Output: 6
Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself.


 

Constraints:

 * 1 <= n <= 150",Solutions (1.3K),544
FALSE,0,0,2488,,Divide Intervals Into Minimum Number of Groups,divide-intervals-into-minimum-number-of-groups,FALSE,20430,44450,2406,FALSE,2,"Can you solve this real interview question? Divide Intervals Into Minimum Number of Groups - You are given a 2D integer array intervals where intervals[i] = [lefti, righti] represents the inclusive interval [lefti, righti].

You have to divide the intervals into one or more groups such that each interval is in exactly one group, and no two intervals that are in the same group intersect each other.

Return the minimum number of groups you need to make.

Two intervals intersect if there is at least one common number between them. For example, the intervals [1, 5] and [5, 8] intersect.

 

Example 1:


Input: intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]
Output: 3
Explanation: We can divide the intervals into the following groups:
- Group 1: [1, 5], [6, 8].
- Group 2: [2, 3], [5, 10].
- Group 3: [1, 10].
It can be proven that it is not possible to divide the intervals into fewer than 3 groups.


Example 2:


Input: intervals = [[1,3],[5,6],[8,10],[11,13]]
Output: 1
Explanation: None of the intervals overlap, so we can put all of them in one group.


 

Constraints:

 * 1 <= intervals.length <= 105
 * intervals[i].length == 2
 * 1 <= lefti <= righti <= 106",Solutions (326),590
FALSE,0,0,2487,optimal-partition-of-string,Optimal Partition of String,optimal-partition-of-string,FALSE,33570,44700,2405,FALSE,2,"Can you solve this real interview question? Optimal Partition of String - Given a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once.

Return the minimum number of substrings in such a partition.

Note that each character should belong to exactly one substring in a partition.

 

Example 1:


Input: s = ""abacaba""
Output: 4
Explanation:
Two possible partitions are (""a"",""ba"",""cab"",""a"") and (""ab"",""a"",""ca"",""ba"").
It can be shown that 4 is the minimum number of substrings needed.


Example 2:


Input: s = ""ssssss""
Output: 6
Explanation:
The only valid partition is (""s"",""s"",""s"",""s"",""s"",""s"").


 

Constraints:

 * 1 <= s.length <= 105
 * s consists of only English lowercase letters.",Solutions (668),508
FALSE,0,0,2486,,Most Frequent Even Element,most-frequent-even-element,FALSE,45985,90249,2404,FALSE,1,"Can you solve this real interview question? Most Frequent Even Element - Given an integer array nums, return the most frequent even element.

If there is a tie, return the smallest one. If there is no such element, return -1.

 

Example 1:


Input: nums = [0,1,2,2,4,4,1]
Output: 2
Explanation:
The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.
We return the smallest one, which is 2.

Example 2:


Input: nums = [4,4,4,9,2,4]
Output: 4
Explanation: 4 is the even element appears the most.


Example 3:


Input: nums = [29,47,21,41,13,37,25,7]
Output: -1
Explanation: There is no even element.


 

Constraints:

 * 1 <= nums.length <= 2000
 * 0 <= nums[i] <= 105",Solutions (712),583
FALSE,0,0,2483,,Task Scheduler II,task-scheduler-ii,FALSE,17692,37831,2365,FALSE,2,"Can you solve this real interview question? Task Scheduler II - You are given a 0-indexed array of positive integers tasks, representing tasks that need to be completed in order, where tasks[i] represents the type of the ith task.

You are also given a positive integer space, which represents the minimum number of days that must pass after the completion of a task before another task of the same type can be performed.

Each day, until all tasks have been completed, you must either:

 * Complete the next task from tasks, or
 * Take a break.

Return the minimum number of days needed to complete all tasks.

 

Example 1:


Input: tasks = [1,2,1,2,3,1], space = 3
Output: 9
Explanation:
One way to complete all tasks in 9 days is as follows:
Day 1: Complete the 0th task.
Day 2: Complete the 1st task.
Day 3: Take a break.
Day 4: Take a break.
Day 5: Complete the 2nd task.
Day 6: Complete the 3rd task.
Day 7: Take a break.
Day 8: Complete the 4th task.
Day 9: Complete the 5th task.
It can be shown that the tasks cannot be completed in less than 9 days.


Example 2:


Input: tasks = [5,8,8,5], space = 2
Output: 6
Explanation:
One way to complete all tasks in 6 days is as follows:
Day 1: Complete the 0th task.
Day 2: Complete the 1st task.
Day 3: Take a break.
Day 4: Take a break.
Day 5: Complete the 2nd task.
Day 6: Complete the 3rd task.
It can be shown that the tasks cannot be completed in less than 6 days.


 

Constraints:

 * 1 <= tasks.length <= 105
 * 1 <= tasks[i] <= 109
 * 1 <= space <= tasks.length",Solutions (337),398
FALSE,0,0,2482,,Maximum Rows Covered by Columns,maximum-rows-covered-by-columns,FALSE,11735,22222,2397,FALSE,2,"Can you solve this real interview question? Maximum Rows Covered by Columns - You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.

Let us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:

 * For each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,
 * No cell in row has a value of 1.

You need to choose numSelect columns such that the number of rows that are covered is maximized.

Return the maximum number of rows that can be covered by a set of numSelect columns.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png]


Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2
Output: 3
Explanation: One possible way to cover 3 rows is shown in the diagram above.
We choose s = {0, 2}.
- Row 0 is covered because it has no occurrences of 1.
- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.
- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.
- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.
Thus, we can cover three rows.
Note that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.


Example 2:

[https://assets.leetcode.com/uploads/2022/07/14/rowscovered2.png]


Input: matrix = [[1],[0]], numSelect = 1
Output: 2
Explanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.
Therefore, we return 2.


 

Constraints:

 * m == matrix.length
 * n == matrix[i].length
 * 1 <= m, n <= 12
 * matrix[i][j] is either 0 or 1.
 * 1 <= numSelect <= n",Solutions (303),213
FALSE,0,0,2481,,Strictly Palindromic Number,strictly-palindromic-number,FALSE,46803,53323,2396,FALSE,2,"Can you solve this real interview question? Strictly Palindromic Number - An integer n is strictly palindromic if, for every base b between 2 and n - 2 (inclusive), the string representation of the integer n in base b is palindromic.

Given an integer n, return true if n is strictly palindromic and false otherwise.

A string is palindromic if it reads the same forward and backward.

 

Example 1:


Input: n = 9
Output: false
Explanation: In base 2: 9 = 1001 (base 2), which is palindromic.
In base 3: 9 = 100 (base 3), which is not palindromic.
Therefore, 9 is not strictly palindromic so we return false.
Note that in bases 4, 5, 6, and 7, n = 9 is also not palindromic.


Example 2:


Input: n = 4
Output: false
Explanation: We only consider base 2: 4 = 100 (base 2), which is not palindromic.
Therefore, we return false.



 

Constraints:

 * 4 <= n <= 105",Solutions (786),367
FALSE,0,0,2480,,Find Subarrays With Equal Sum,find-subarrays-with-equal-sum,FALSE,34165,53034,2395,FALSE,1,"Can you solve this real interview question? Find Subarrays With Equal Sum - Given a 0-indexed integer array nums, determine whether there exist two subarrays of length 2 with equal sum. Note that the two subarrays must begin at different indices.

Return true if these subarrays exist, and false otherwise.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: nums = [4,2,4]
Output: true
Explanation: The subarrays with elements [4,2] and [2,4] have the same sum of 6.


Example 2:


Input: nums = [1,2,3,4,5]
Output: false
Explanation: No two subarrays of size 2 have the same sum.


Example 3:


Input: nums = [0,0,0]
Output: true
Explanation: The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the same sum of 0. 
Note that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array.


 

Constraints:

 * 2 <= nums.length <= 1000
 * -109 <= nums[i] <= 109",Solutions (605),374
FALSE,0,0,2479,,Meeting Rooms III,meeting-rooms-iii,FALSE,15981,47602,2402,FALSE,3,"Can you solve this real interview question? Meeting Rooms III - You are given an integer n. There are n rooms numbered from 0 to n - 1.

You are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique.

Meetings are allocated to rooms in the following manner:

 1. Each meeting will take place in the unused room with the lowest number.
 2. If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.
 3. When a room becomes unused, meetings that have an earlier original start time should be given the room.

Return the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.

A half-closed interval [a, b) is the interval between a and b including a and not including b.

 

Example 1:


Input: n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]
Output: 0
Explanation:
- At time 0, both rooms are not being used. The first meeting starts in room 0.
- At time 1, only room 1 is not being used. The second meeting starts in room 1.
- At time 2, both rooms are being used. The third meeting is delayed.
- At time 3, both rooms are being used. The fourth meeting is delayed.
- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10).
- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11).
Both rooms 0 and 1 held 2 meetings, so we return 0. 


Example 2:


Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]
Output: 1
Explanation:
- At time 1, all three rooms are not being used. The first meeting starts in room 0.
- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.
- At time 3, only room 2 is not being used. The third meeting starts in room 2.
- At time 4, all three rooms are being used. The fourth meeting is delayed.
- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10).
- At time 6, all three rooms are being used. The fifth meeting is delayed.
- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12).
Room 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. 


 

Constraints:

 * 1 <= n <= 100
 * 1 <= meetings.length <= 105
 * meetings[i].length == 2
 * 0 <= starti < endi <= 5 * 105
 * All the values of starti are unique.",Solutions (249),516
FALSE,0,0,2478,,Longest Nice Subarray,longest-nice-subarray,FALSE,20425,41504,2401,FALSE,2,"Can you solve this real interview question? Longest Nice Subarray - You are given an array nums consisting of positive integers.

We call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.

Return the length of the longest nice subarray.

A subarray is a contiguous part of an array.

Note that subarrays of length 1 are always considered nice.

 

Example 1:


Input: nums = [1,3,8,48,10]
Output: 3
Explanation: The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:
- 3 AND 8 = 0.
- 3 AND 48 = 0.
- 8 AND 48 = 0.
It can be proven that no longer nice subarray can be obtained, so we return 3.

Example 2:


Input: nums = [3,1,5,11,13]
Output: 1
Explanation: The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (366),881
FALSE,0,0,2477,,Number of Ways to Reach a Position After Exactly k Steps,number-of-ways-to-reach-a-position-after-exactly-k-steps,FALSE,21195,64303,2400,FALSE,2,"Can you solve this real interview question? Number of Ways to Reach a Position After Exactly k Steps - You are given two positive integers startPos and endPos. Initially, you are standing at position startPos on an infinite number line. With one step, you can move either one position to the left, or one position to the right.

Given a positive integer k, return the number of different ways to reach the position endPos starting from startPos, such that you perform exactly k steps. Since the answer may be very large, return it modulo 109 + 7.

Two ways are considered different if the order of the steps made is not exactly the same.

Note that the number line includes negative integers.

 

Example 1:


Input: startPos = 1, endPos = 2, k = 3
Output: 3
Explanation: We can reach position 2 from 1 in exactly 3 steps in three ways:
- 1 -> 2 -> 3 -> 2.
- 1 -> 2 -> 1 -> 2.
- 1 -> 0 -> 1 -> 2.
It can be proven that no other way is possible, so we return 3.

Example 2:


Input: startPos = 2, endPos = 5, k = 10
Output: 0
Explanation: It is impossible to reach position 5 from position 2 in exactly 10 steps.


 

Constraints:

 * 1 <= startPos, endPos, k <= 1000",Solutions (362),533
FALSE,0,0,2476,,Check Distances Between Same Letters,check-distances-between-same-letters,FALSE,34132,48345,2399,FALSE,1,"Can you solve this real interview question? Check Distances Between Same Letters - You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26.

Each letter in the alphabet is numbered from 0 to 25 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25).

In a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored.

Return true if s is a well-spaced string, otherwise return false.

 

Example 1:


Input: s = ""abaccb"", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: true
Explanation:
- 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1.
- 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3.
- 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0.
Note that distance[3] = 5, but since 'd' does not appear in s, it can be ignored.
Return true because s is a well-spaced string.


Example 2:


Input: s = ""aa"", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: false
Explanation:
- 'a' appears at indices 0 and 1 so there are zero letters between them.
Because distance[0] = 1, s is not a well-spaced string.


 

Constraints:

 * 2 <= s.length <= 52
 * s consists only of lowercase English letters.
 * Each letter appears in s exactly twice.
 * distance.length == 26
 * 0 <= distance[i] <= 50",Solutions (575),337
FALSE,0,0,2475,,Largest Palindromic Number,largest-palindromic-number,FALSE,20309,65122,2384,FALSE,2,"Can you solve this real interview question? Largest Palindromic Number - You are given a string num consisting of digits only.

Return the largest palindromic integer (in the form of a string) that can be formed using digits taken from num. It should not contain leading zeroes.

Notes:

 * You do not need to use all the digits of num, but you must use at least one digit.
 * The digits can be reordered.

 

Example 1:


Input: num = ""444947137""
Output: ""7449447""
Explanation: 
Use the digits ""4449477"" from ""444947137"" to form the palindromic integer ""7449447"".
It can be shown that ""7449447"" is the largest palindromic integer that can be formed.


Example 2:


Input: num = ""00009""
Output: ""9""
Explanation: 
It can be shown that ""9"" is the largest palindromic integer that can be formed.
Note that the integer returned should not contain leading zeroes.


 

Constraints:

 * 1 <= num.length <= 105
 * num consists of digits.",Solutions (454),450
FALSE,0,0,2473,,Max Sum of a Pair With Equal Sum of Digits,max-sum-of-a-pair-with-equal-sum-of-digits,FALSE,31613,59248,2342,FALSE,2,"Can you solve this real interview question? Max Sum of a Pair With Equal Sum of Digits - You are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i != j, and the sum of digits of the number nums[i] is equal to that of nums[j].

Return the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions.

 

Example 1:


Input: nums = [18,43,36,13,7]
Output: 54
Explanation: The pairs (i, j) that satisfy the conditions are:
- (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54.
- (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50.
So the maximum sum that we can obtain is 54.


Example 2:


Input: nums = [10,12,19,14]
Output: -1
Explanation: There are no two numbers that satisfy the conditions, so we return -1.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (719),520
FALSE,0,0,2472,,Build a Matrix With Conditions,build-a-matrix-with-conditions,FALSE,10943,18408,2392,FALSE,3,"Can you solve this real interview question? Build a Matrix With Conditions - You are given a positive integer k. You are also given:

 * a 2D integer array rowConditions of size n where rowConditions[i] = [abovei, belowi], and
 * a 2D integer array colConditions of size m where colConditions[i] = [lefti, righti].

The two arrays contain integers from 1 to k.

You have to build a k x k matrix that contains each of the numbers from 1 to k exactly once. The remaining cells should have the value 0.

The matrix should also satisfy the following conditions:

 * The number abovei should appear in a row that is strictly above the row at which the number belowi appears for all i from 0 to n - 1.
 * The number lefti should appear in a column that is strictly left of the column at which the number righti appears for all i from 0 to m - 1.

Return any matrix that satisfies the conditions. If no answer exists, return an empty matrix.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png]


Input: k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]
Output: [[3,0,0],[0,0,1],[0,2,0]]
Explanation: The diagram above shows a valid example of a matrix that satisfies all the conditions.
The row conditions are the following:
- Number 1 is in row 1, and number 2 is in row 2, so 1 is above 2 in the matrix.
- Number 3 is in row 0, and number 2 is in row 2, so 3 is above 2 in the matrix.
The column conditions are the following:
- Number 2 is in column 1, and number 1 is in column 2, so 2 is left of 1 in the matrix.
- Number 3 is in column 0, and number 2 is in column 1, so 3 is left of 2 in the matrix.
Note that there may be multiple correct answers.


Example 2:


Input: k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]
Output: []
Explanation: From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.
No matrix can satisfy all the conditions, so we return the empty matrix.


 

Constraints:

 * 2 <= k <= 400
 * 1 <= rowConditions.length, colConditions.length <= 104
 * rowConditions[i].length == colConditions[i].length == 2
 * 1 <= abovei, belowi, lefti, righti <= k
 * abovei != belowi
 * lefti != righti",Solutions (299),622
FALSE,0,0,2471,,Minimum Amount of Time to Collect Garbage,minimum-amount-of-time-to-collect-garbage,FALSE,32074,38033,2391,FALSE,2,"Can you solve this real interview question? Minimum Amount of Time to Collect Garbage - You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.

You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.

There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.

Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.

Return the minimum number of minutes needed to pick up all the garbage.

 

Example 1:


Input: garbage = [""G"",""P"",""GP"",""GG""], travel = [2,4,3]
Output: 21
Explanation:
The paper garbage truck:
1. Travels from house 0 to house 1
2. Collects the paper garbage at house 1
3. Travels from house 1 to house 2
4. Collects the paper garbage at house 2
Altogether, it takes 8 minutes to pick up all the paper garbage.
The glass garbage truck:
1. Collects the glass garbage at house 0
2. Travels from house 0 to house 1
3. Travels from house 1 to house 2
4. Collects the glass garbage at house 2
5. Travels from house 2 to house 3
6. Collects the glass garbage at house 3
Altogether, it takes 13 minutes to pick up all the glass garbage.
Since there is no metal garbage, we do not need to consider the metal garbage truck.
Therefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.


Example 2:


Input: garbage = [""MMM"",""PGM"",""GP""], travel = [3,10]
Output: 37
Explanation:
The metal garbage truck takes 7 minutes to pick up all the metal garbage.
The paper garbage truck takes 15 minutes to pick up all the paper garbage.
The glass garbage truck takes 15 minutes to pick up all the glass garbage.
It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.


 

Constraints:

 * 2 <= garbage.length <= 105
 * garbage[i] consists of only the letters 'M', 'P', and 'G'.
 * 1 <= garbage[i].length <= 10
 * travel.length == garbage.length - 1
 * 1 <= travel[i] <= 100",Solutions (766),535
FALSE,0,0,2470,removing-stars-from-a-string,Removing Stars From a String,removing-stars-from-a-string,FALSE,39849,61001,2390,FALSE,2,"Can you solve this real interview question? Removing Stars From a String - You are given a string s, which contains stars *.

In one operation, you can:

 * Choose a star in s.
 * Remove the closest non-star character to its left, as well as remove the star itself.

Return the string after all stars have been removed.

Note:

 * The input will be generated such that the operation is always possible.
 * It can be shown that the resulting string will always be unique.

 

Example 1:


Input: s = ""leet**cod*e""
Output: ""lecoe""
Explanation: Performing the removals from left to right:
- The closest character to the 1st star is 't' in ""leet**cod*e"". s becomes ""lee*cod*e"".
- The closest character to the 2nd star is 'e' in ""lee*cod*e"". s becomes ""lecod*e"".
- The closest character to the 3rd star is 'd' in ""lecod*e"". s becomes ""lecoe"".
There are no more stars, so we return ""lecoe"".

Example 2:


Input: s = ""erase*****""
Output: """"
Explanation: The entire string is removed, so we return an empty string.


 

Constraints:

 * 1 <= s.length <= 105
 * s consists of lowercase English letters and stars *.
 * The operation above can be performed on s.",Solutions (903),698
FALSE,0,0,2469,longest-subsequence-with-limited-sum,Longest Subsequence With Limited Sum,longest-subsequence-with-limited-sum,FALSE,79093,109088,2389,FALSE,1,"Can you solve this real interview question? Longest Subsequence With Limited Sum - You are given an integer array nums of length n, and an integer array queries of length m.

Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:


Input: nums = [4,5,2,1], queries = [3,10,21]
Output: [2,3,4]
Explanation: We answer the queries as follows:
- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.
- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.
- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.


Example 2:


Input: nums = [2,3,4,5], queries = [1]
Output: [0]
Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0.

 

Constraints:

 * n == nums.length
 * m == queries.length
 * 1 <= n, m <= 1000
 * 1 <= nums[i], queries[i] <= 106",Solutions (1.2K),1.5K
FALSE,0,0,2466,,Maximum Segment Sum After Removals,maximum-segment-sum-after-removals,FALSE,6354,13299,2382,FALSE,3,"Can you solve this real interview question? Maximum Segment Sum After Removals - You are given two 0-indexed integer arrays nums and removeQueries, both of length n. For the ith query, the element in nums at the index removeQueries[i] is removed, splitting nums into different segments.

A segment is a contiguous sequence of positive integers in nums. A segment sum is the sum of every element in a segment.

Return an integer array answer, of length n, where answer[i] is the maximum segment sum after applying the ith removal.

Note: The same index will not be removed more than once.

 

Example 1:


Input: nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]
Output: [14,7,2,2,0]
Explanation: Using 0 to indicate a removed element, the answer is as follows:
Query 1: Remove the 0th element, nums becomes [0,2,5,6,1] and the maximum segment sum is 14 for segment [2,5,6,1].
Query 2: Remove the 3rd element, nums becomes [0,2,5,0,1] and the maximum segment sum is 7 for segment [2,5].
Query 3: Remove the 2nd element, nums becomes [0,2,0,0,1] and the maximum segment sum is 2 for segment [2]. 
Query 4: Remove the 4th element, nums becomes [0,2,0,0,0] and the maximum segment sum is 2 for segment [2]. 
Query 5: Remove the 1st element, nums becomes [0,0,0,0,0] and the maximum segment sum is 0, since there are no segments.
Finally, we return [14,7,2,2,0].

Example 2:


Input: nums = [3,2,11,1], removeQueries = [3,2,1,0]
Output: [16,5,3,0]
Explanation: Using 0 to indicate a removed element, the answer is as follows:
Query 1: Remove the 3rd element, nums becomes [3,2,11,0] and the maximum segment sum is 16 for segment [3,2,11].
Query 2: Remove the 2nd element, nums becomes [3,2,0,0] and the maximum segment sum is 5 for segment [3,2].
Query 3: Remove the 1st element, nums becomes [3,0,0,0] and the maximum segment sum is 3 for segment [3].
Query 4: Remove the 0th element, nums becomes [0,0,0,0] and the maximum segment sum is 0, since there are no segments.
Finally, we return [16,5,3,0].


 

Constraints:

 * n == nums.length == removeQueries.length
 * 1 <= n <= 105
 * 1 <= nums[i] <= 109
 * 0 <= removeQueries[i] < n
 * All the values of removeQueries are unique.",Solutions (160),371
FALSE,0,0,2465,,Shifting Letters II,shifting-letters-ii,FALSE,14557,41607,2381,FALSE,2,"Can you solve this real interview question? Shifting Letters II - You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0.

Shifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that 'a' becomes 'z').

Return the final string after all such shifts to s are applied.

 

Example 1:


Input: s = ""abc"", shifts = [[0,1,0],[1,2,1],[0,2,1]]
Output: ""ace""
Explanation: Firstly, shift the characters from index 0 to index 1 backward. Now s = ""zac"".
Secondly, shift the characters from index 1 to index 2 forward. Now s = ""zbd"".
Finally, shift the characters from index 0 to index 2 forward. Now s = ""ace"".

Example 2:


Input: s = ""dztz"", shifts = [[0,0,0],[1,1,1]]
Output: ""catz""
Explanation: Firstly, shift the characters from index 0 to index 0 backward. Now s = ""cztz"".
Finally, shift the characters from index 1 to index 1 forward. Now s = ""catz"".


 

Constraints:

 * 1 <= s.length, shifts.length <= 5 * 104
 * shifts[i].length == 3
 * 0 <= starti <= endi < s.length
 * 0 <= directioni <= 1
 * s consists of lowercase English letters.",Solutions (268),573
FALSE,0,0,2464,,Time Needed to Rearrange a Binary String,time-needed-to-rearrange-a-binary-string,FALSE,22231,45359,2380,FALSE,2,"Can you solve this real interview question? Time Needed to Rearrange a Binary String - You are given a binary string s. In one second, all occurrences of ""01"" are simultaneously replaced with ""10"". This process repeats until no occurrences of ""01"" exist.

Return the number of seconds needed to complete this process.

 

Example 1:


Input: s = ""0110101""
Output: 4
Explanation: 
After one second, s becomes ""1011010"".
After another second, s becomes ""1101100"".
After the third second, s becomes ""1110100"".
After the fourth second, s becomes ""1111000"".
No occurrence of ""01"" exists any longer, and the process needed 4 seconds to complete,
so we return 4.


Example 2:


Input: s = ""11100""
Output: 0
Explanation:
No occurrence of ""01"" exists in s, and the processes needed 0 seconds to complete,
so we return 0.


 

Constraints:

 * 1 <= s.length <= 1000
 * s[i] is either '0' or '1'.

 

Follow up:

Can you solve this problem in O(n) time complexity?",Solutions (330),356
FALSE,0,0,2463,,Minimum Recolors to Get K Consecutive Black Blocks,minimum-recolors-to-get-k-consecutive-black-blocks,FALSE,31689,54878,2379,FALSE,1,"Can you solve this real interview question? Minimum Recolors to Get K Consecutive Black Blocks - You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the ith block. The characters 'W' and 'B' denote the colors white and black, respectively.

You are also given an integer k, which is the desired number of consecutive black blocks.

In one operation, you can recolor a white block such that it becomes a black block.

Return the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.

 

Example 1:


Input: blocks = ""WBBWWBBWBW"", k = 7
Output: 3
Explanation:
One way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 4th blocks
so that blocks = ""BBBBBBBWBW"". 
It can be shown that there is no way to achieve 7 consecutive black blocks in less than 3 operations.
Therefore, we return 3.


Example 2:


Input: blocks = ""WBWBBBW"", k = 2
Output: 0
Explanation:
No changes need to be made, since 2 consecutive black blocks already exist.
Therefore, we return 0.


 

Constraints:

 * n == blocks.length
 * 1 <= n <= 100
 * blocks[i] is either 'W' or 'B'.
 * 1 <= k <= n",Solutions (642),492
FALSE,0,0,2462,,Find the K-Sum of an Array,find-the-k-sum-of-an-array,FALSE,6958,18238,2386,FALSE,3,"Can you solve this real interview question? Find the K-Sum of an Array - You are given an integer array nums and a positive integer k. You can choose any subsequence of the array and sum all of its elements together.

We define the K-Sum of the array as the kth largest subsequence sum that can be obtained (not necessarily distinct).

Return the K-Sum of the array.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

Note that the empty subsequence is considered to have a sum of 0.

 

Example 1:


Input: nums = [2,4,-2], k = 5
Output: 2
Explanation: All the possible subsequence sums that we can obtain are the following sorted in decreasing order:
- 6, 4, 4, 2, 2, 0, 0, -2.
The 5-Sum of the array is 2.


Example 2:


Input: nums = [1,-2,3,4,-10,12], k = 16
Output: 10
Explanation: The 16-Sum of the array is 10.


 

Constraints:

 * n == nums.length
 * 1 <= n <= 105
 * -109 <= nums[i] <= 109
 * 1 <= k <= min(2000, 2n)",Solutions (78),459
FALSE,0,0,2461,,Amount of Time for Binary Tree to Be Infected,amount-of-time-for-binary-tree-to-be-infected,FALSE,23195,40944,2385,FALSE,2,"Can you solve this real interview question? Amount of Time for Binary Tree to Be Infected - You are given the root of a binary tree with unique values, and an integer start. At minute 0, an infection starts from the node with value start.

Each minute, a node becomes infected if:

 * The node is currently uninfected.
 * The node is adjacent to an infected node.

Return the number of minutes needed for the entire tree to be infected.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png]


Input: root = [1,5,3,null,4,10,6,9,2], start = 3
Output: 4
Explanation: The following nodes are infected during:
- Minute 0: Node 3
- Minute 1: Nodes 1, 10 and 6
- Minute 2: Node 5
- Minute 3: Node 4
- Minute 4: Nodes 9 and 2
It takes 4 minutes for the whole tree to be infected so we return 4.


Example 2:

[https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png]


Input: root = [1], start = 1
Output: 0
Explanation: At minute 0, the only node in the tree is infected so we return 0.


 

Constraints:

 * The number of nodes in the tree is in the range [1, 105].
 * 1 <= Node.val <= 105
 * Each node has a unique value.
 * A node with a value of start exists in the tree.",Solutions (606),980
FALSE,0,0,2459,,Minimum Hours of Training to Win a Competition,minimum-hours-of-training-to-win-a-competition,FALSE,25312,61726,2383,FALSE,1,"Can you solve this real interview question? Minimum Hours of Training to Win a Competition - You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively.

You are also given two 0-indexed integer arrays energy and experience, both of length n.

You will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available.

Defeating the ith opponent increases your experience by experience[i], but decreases your energy by energy[i].

Before starting the competition, you can train for some number of hours. After each hour of training, you can either choose to increase your initial experience by one, or increase your initial energy by one.

Return the minimum number of training hours required to defeat all n opponents.

 

Example 1:


Input: initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]
Output: 8
Explanation: You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.
You face the opponents in the following order:
- You have more energy and experience than the 0th opponent so you win.
  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.
- You have more energy and experience than the 1st opponent so you win.
  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.
- You have more energy and experience than the 2nd opponent so you win.
  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.
- You have more energy and experience than the 3rd opponent so you win.
  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.
You did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.
It can be proven that no smaller answer exists.


Example 2:


Input: initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]
Output: 0
Explanation: You do not need any additional energy or experience to win the competition, so we return 0.


 

Constraints:

 * n == energy.length == experience.length
 * 1 <= n <= 100
 * 1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100",Solutions (410),251
FALSE,0,0,2457,,Count Special Integers,count-special-integers,FALSE,8660,23613,2376,FALSE,3,"Can you solve this real interview question? Count Special Integers - We call a positive integer special if all of its digits are distinct.

Given a positive integer n, return the number of special integers that belong to the interval [1, n].

 

Example 1:


Input: n = 20
Output: 19
Explanation: All the integers from 1 to 20, except 11, are special. Thus, there are 19 special integers.


Example 2:


Input: n = 5
Output: 5
Explanation: All the integers from 1 to 5 are special.


Example 3:


Input: n = 135
Output: 110
Explanation: There are 110 integers from 1 to 135 that are special.
Some of the integers that are not special are: 22, 114, and 131.

 

Constraints:

 * 1 <= n <= 2 * 109",Solutions (169),457
FALSE,0,0,2456,,Construct Smallest Number From DI String,construct-smallest-number-from-di-string,FALSE,21706,29107,2375,FALSE,2,"Can you solve this real interview question? Construct Smallest Number From DI String - You are given a 0-indexed string pattern of length n consisting of the characters 'I' meaning increasing and 'D' meaning decreasing.

A 0-indexed string num of length n + 1 is created using the following conditions:

 * num consists of the digits '1' to '9', where each digit is used at most once.
 * If pattern[i] == 'I', then num[i] < num[i + 1].
 * If pattern[i] == 'D', then num[i] > num[i + 1].

Return the lexicographically smallest possible string num that meets the conditions.

 

Example 1:


Input: pattern = ""IIIDIDDD""
Output: ""123549876""
Explanation:
At indices 0, 1, 2, and 4 we must have that num[i] < num[i+1].
At indices 3, 5, 6, and 7 we must have that num[i] > num[i+1].
Some possible values of num are ""245639871"", ""135749862"", and ""123849765"".
It can be proven that ""123549876"" is the smallest possible num that meets the conditions.
Note that ""123414321"" is not possible because the digit '1' is used more than once.

Example 2:


Input: pattern = ""DDD""
Output: ""4321""
Explanation:
Some possible values of num are ""9876"", ""7321"", and ""8742"".
It can be proven that ""4321"" is the smallest possible num that meets the conditions.


 

Constraints:

 * 1 <= pattern.length <= 8
 * pattern consists of only the letters 'I' and 'D'.",Solutions (521),680
FALSE,0,0,2455,,Node With Highest Edge Score,node-with-highest-edge-score,FALSE,25528,54910,2374,FALSE,2,"Can you solve this real interview question? Node With Highest Edge Score - You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.

The graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].

The edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.

Return the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png]


Input: edges = [1,0,0,0,0,7,7,5]
Output: 7
Explanation:
- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.
- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.
- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.
- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.
Node 7 has the highest edge score so return 7.


Example 2:

[https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png]


Input: edges = [2,0,0,2]
Output: 0
Explanation:
- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.
- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.
Nodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0.


 

Constraints:

 * n == edges.length
 * 2 <= n <= 105
 * 0 <= edges[i] < n
 * edges[i] != i",Solutions (427),327
FALSE,0,0,2454,,Largest Local Values in a Matrix,largest-local-values-in-a-matrix,FALSE,34393,41249,2373,FALSE,1,"Can you solve this real interview question? Largest Local Values in a Matrix - You are given an n x n integer matrix grid.

Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:

 * maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.

In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.

Return the generated matrix.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/06/21/ex1.png]


Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
Output: [[9,9],[8,6]]
Explanation: The diagram above shows the original matrix and the generated matrix.
Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.

Example 2:

[https://assets.leetcode.com/uploads/2022/07/02/ex2new2.png]


Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]
Output: [[2,2,2],[2,2,2],[2,2,2]]
Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid.


 

Constraints:

 * n == grid.length == grid[i].length
 * 3 <= n <= 100
 * 1 <= grid[i][j] <= 100",Solutions (569),513
FALSE,0,0,2450,,Minimum Replacements to Sort the Array,minimum-replacements-to-sort-the-array,FALSE,9609,23468,2366,FALSE,3,"Can you solve this real interview question? Minimum Replacements to Sort the Array - You are given a 0-indexed integer array nums. In one operation you can replace any element of the array with any two elements that sum to it.

 * For example, consider nums = [5,6,7]. In one operation, we can replace nums[1] with 2 and 4 and convert nums to [5,2,4,7].

Return the minimum number of operations to make an array that is sorted in non-decreasing order.

 

Example 1:


Input: nums = [3,9,3]
Output: 2
Explanation: Here are the steps to sort the array in non-decreasing order:
- From [3,9,3], replace the 9 with 3 and 6 so the array becomes [3,3,6,3]
- From [3,3,6,3], replace the 6 with 3 and 3 so the array becomes [3,3,3,3,3]
There are 2 steps to sort the array in non-decreasing order. Therefore, we return 2.



Example 2:


Input: nums = [1,2,3,4,5]
Output: 0
Explanation: The array is already in non-decreasing order. Therefore, we return 0. 


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (140),426
FALSE,0,0,2449,,Maximum Number of Robots Within Budget,maximum-number-of-robots-within-budget,FALSE,14754,44747,2398,FALSE,3,"Can you solve this real interview question? Maximum Number of Robots Within Budget - You have n robots. You are given two 0-indexed integer arrays, chargeTimes and runningCosts, both of length n. The ith robot costs chargeTimes[i] units to charge and costs runningCosts[i] units to run. You are also given an integer budget.

The total cost of running k chosen robots is equal to max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the largest charge cost among the k robots and sum(runningCosts) is the sum of running costs among the k robots.

Return the maximum number of consecutive robots you can run such that the total cost does not exceed budget.

 

Example 1:


Input: chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25
Output: 3
Explanation: 
It is possible to run all individual and consecutive pairs of robots within budget.
To obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less than 25.
It can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.


Example 2:


Input: chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19
Output: 0
Explanation: No robot can be run that does not exceed the budget, so we return 0.


 

Constraints:

 * chargeTimes.length == runningCosts.length == n
 * 1 <= n <= 5 * 104
 * 1 <= chargeTimes[i], runningCosts[i] <= 105
 * 1 <= budget <= 1015",Solutions (311),612
FALSE,0,0,2448,,Count Number of Bad Pairs,count-number-of-bad-pairs,FALSE,22527,54808,2364,FALSE,2,"Can you solve this real interview question? Count Number of Bad Pairs - You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].

Return the total number of bad pairs in nums.

 

Example 1:


Input: nums = [4,1,3,3]
Output: 5
Explanation: The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.
The pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.
The pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.
The pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.
The pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.
There are a total of 5 bad pairs, so we return 5.


Example 2:


Input: nums = [1,2,3,4,5]
Output: 0
Explanation: There are no bad pairs.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (432),726
FALSE,0,0,2447,,Merge Similar Items,merge-similar-items,FALSE,35204,46638,2363,FALSE,1,"Can you solve this real interview question? Merge Similar Items - You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:

 * items[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.
 * The value of each item in items is unique.

Return a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.

Note: ret should be returned in ascending order by value.

 

Example 1:


Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]
Output: [[1,6],[3,9],[4,5]]
Explanation: 
The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.
The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.
The item with value = 4 occurs in items1 with weight = 5, total weight = 5.  
Therefore, we return [[1,6],[3,9],[4,5]].


Example 2:


Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]
Output: [[1,4],[2,4],[3,4]]
Explanation: 
The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.
The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.
The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.
Therefore, we return [[1,4],[2,4],[3,4]].

Example 3:


Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]
Output: [[1,7],[2,4],[7,1]]
Explanation:
The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. 
The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. 
The item with value = 7 occurs in items2 with weight = 1, total weight = 1.
Therefore, we return [[1,7],[2,4],[7,1]].


 

Constraints:

 * 1 <= items1.length, items2.length <= 1000
 * items1[i].length == items2[i].length == 2
 * 1 <= valuei, weighti <= 1000
 * Each valuei in items1 is unique.
 * Each valuei in items2 is unique.",Solutions (662),376
FALSE,0,0,2445,reachable-nodes-with-restrictions,Reachable Nodes With Restrictions,reachable-nodes-with-restrictions,FALSE,31507,54585,2368,FALSE,2,"Can you solve this real interview question? Reachable Nodes With Restrictions - There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.

You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.

Return the maximum number of nodes you can reach from node 0 without visiting a restricted node.

Note that node 0 will not be a restricted node.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png]


Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
Output: 4
Explanation: The diagram above shows the tree.
We have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.


Example 2:

[https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png]


Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
Output: 3
Explanation: The diagram above shows the tree.
We have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.


 

Constraints:

 * 2 <= n <= 105
 * edges.length == n - 1
 * edges[i].length == 2
 * 0 <= ai, bi < n
 * ai != bi
 * edges represents a valid tree.
 * 1 <= restricted.length < n
 * 1 <= restricted[i] < n
 * All the values of restricted are unique.",Solutions (503),479
FALSE,0,0,2444,,Longest Ideal Subsequence,longest-ideal-subsequence,FALSE,18712,49616,2370,FALSE,2,"Can you solve this real interview question? Longest Ideal Subsequence - You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:

 * t is a subsequence of the string s.
 * The absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.

Return the length of the longest ideal string.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

Note that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.

 

Example 1:


Input: s = ""acfgbd"", k = 2
Output: 4
Explanation: The longest ideal string is ""acbd"". The length of this string is 4, so 4 is returned.
Note that ""acfgbd"" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.

Example 2:


Input: s = ""abcd"", k = 3
Output: 4
Explanation: The longest ideal string is ""abcd"". The length of this string is 4, so 4 is returned.


 

Constraints:

 * 1 <= s.length <= 105
 * 0 <= k <= 25
 * s consists of lowercase English letters.",Solutions (327),630
FALSE,0,0,2443,,Check if There is a Valid Partition For The Array,check-if-there-is-a-valid-partition-for-the-array,FALSE,19014,47353,2369,FALSE,2,"Can you solve this real interview question? Check if There is a Valid Partition For The Array - You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.

We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:

 1. The subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.
 2. The subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.
 3. The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.

Return true if the array has at least one valid partition. Otherwise, return false.

 

Example 1:


Input: nums = [4,4,4,5,6]
Output: true
Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].
This partition is valid, so we return true.


Example 2:


Input: nums = [1,1,1,2]
Output: false
Explanation: There is no valid partition for this array.


 

Constraints:

 * 2 <= nums.length <= 105
 * 1 <= nums[i] <= 106",Solutions (309),504
FALSE,0,0,2442,,Number of Arithmetic Triplets,number-of-arithmetic-triplets,FALSE,66105,79041,2367,FALSE,1,"Can you solve this real interview question? Number of Arithmetic Triplets - You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:

 * i < j < k,
 * nums[j] - nums[i] == diff, and
 * nums[k] - nums[j] == diff.

Return the number of unique arithmetic triplets.

 

Example 1:


Input: nums = [0,1,4,6,7,10], diff = 3
Output: 2
Explanation:
(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. 


Example 2:


Input: nums = [4,5,6,7,8,9], diff = 2
Output: 2
Explanation:
(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.


 

Constraints:

 * 3 <= nums.length <= 200
 * 0 <= nums[i] <= 200
 * 1 <= diff <= 50
 * nums is strictly increasing.",Solutions (1.1K),809
FALSE,0,0,2439,longest-cycle-in-a-graph,Longest Cycle in a Graph,longest-cycle-in-a-graph,FALSE,17729,45564,2360,FALSE,3,"Can you solve this real interview question? Longest Cycle in a Graph - You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.

The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.

Return the length of the longest cycle in the graph. If no cycle exists, return -1.

A cycle is a path that starts and ends at the same node.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png]


Input: edges = [3,3,4,2,3]
Output: 3
Explanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.
The length of this cycle is 3, so 3 is returned.


Example 2:

[https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png]


Input: edges = [2,-1,3,1]
Output: -1
Explanation: There are no cycles in this graph.


 

Constraints:

 * n == edges.length
 * 2 <= n <= 105
 * -1 <= edges[i] < n
 * edges[i] != i",Solutions (996),1.9K
FALSE,0,0,2438,find-closest-node-to-given-two-nodes,Find Closest Node to Given Two Nodes,find-closest-node-to-given-two-nodes,FALSE,66291,143605,2359,FALSE,2,"Can you solve this real interview question? Find Closest Node to Given Two Nodes - You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.

The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.

You are also given two integers node1 and node2.

Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.

Note that edges may contain cycles.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png]


Input: edges = [2,2,3,-1], node1 = 0, node2 = 1
Output: 2
Explanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.
The maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.


Example 2:

[https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png]


Input: edges = [1,2,-1], node1 = 0, node2 = 2
Output: 2
Explanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.
The maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.


 

Constraints:

 * n == edges.length
 * 2 <= n <= 105
 * -1 <= edges[i] < n
 * edges[i] != i
 * 0 <= node1, node2 < n",Solutions (1.1K),1.5K
FALSE,0,0,2437,,Maximum Number of Groups Entering a Competition,maximum-number-of-groups-entering-a-competition,FALSE,28687,42406,2358,FALSE,2,"Can you solve this real interview question? Maximum Number of Groups Entering a Competition - You are given a positive integer array grades which represents the grades of students in a university. You would like to enter all these students into a competition in ordered non-empty groups, such that the ordering meets the following conditions:

 * The sum of the grades of students in the ith group is less than the sum of the grades of students in the (i + 1)th group, for all groups (except the last).
 * The total number of students in the ith group is less than the total number of students in the (i + 1)th group, for all groups (except the last).

Return the maximum number of groups that can be formed.

 

Example 1:


Input: grades = [10,6,12,7,3,5]
Output: 3
Explanation: The following is a possible way to form 3 groups of students:
- 1st group has the students with grades = [12]. Sum of grades: 12. Student count: 1
- 2nd group has the students with grades = [6,7]. Sum of grades: 6 + 7 = 13. Student count: 2
- 3rd group has the students with grades = [10,3,5]. Sum of grades: 10 + 3 + 5 = 18. Student count: 3
It can be shown that it is not possible to form more than 3 groups.


Example 2:


Input: grades = [8,8]
Output: 1
Explanation: We can only form 1 group, since forming 2 groups would lead to an equal number of students in both groups.


 

Constraints:

 * 1 <= grades.length <= 105
 * 1 <= grades[i] <= 105",Solutions (484),491
FALSE,0,0,2436,,Make Array Zero by Subtracting Equal Amounts,make-array-zero-by-subtracting-equal-amounts,FALSE,63171,87064,2357,FALSE,1,"Can you solve this real interview question? Make Array Zero by Subtracting Equal Amounts - You are given a non-negative integer array nums. In one operation, you must:

 * Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.
 * Subtract x from every positive element in nums.

Return the minimum number of operations to make every element in nums equal to 0.

 

Example 1:


Input: nums = [1,5,0,3,5]
Output: 3
Explanation:
In the first operation, choose x = 1. Now, nums = [0,4,0,2,4].
In the second operation, choose x = 2. Now, nums = [0,2,0,0,2].
In the third operation, choose x = 2. Now, nums = [0,0,0,0,0].


Example 2:


Input: nums = [0]
Output: 0
Explanation: Each element in nums is already 0 so no operations are needed.


 

Constraints:

 * 1 <= nums.length <= 100
 * 0 <= nums[i] <= 100",Solutions (1K),796
FALSE,0,0,2435,,Shortest Impossible Sequence of Rolls,shortest-impossible-sequence-of-rolls,FALSE,11617,17025,2350,FALSE,3,"Can you solve this real interview question? Shortest Impossible Sequence of Rolls - You are given an integer array rolls of length n and an integer k. You roll a k sided dice numbered from 1 to k, n times, where the result of the ith roll is rolls[i].

Return the length of the shortest sequence of rolls that cannot be taken from rolls.

A sequence of rolls of length len is the result of rolling a k sided dice len times.

Note that the sequence taken does not have to be consecutive as long as it is in order.

 

Example 1:


Input: rolls = [4,2,1,2,3,3,2,4,1], k = 4
Output: 3
Explanation: Every sequence of rolls of length 1, [1], [2], [3], [4], can be taken from rolls.
Every sequence of rolls of length 2, [1, 1], [1, 2], ..., [4, 4], can be taken from rolls.
The sequence [1, 4, 2] cannot be taken from rolls, so we return 3.
Note that there are other sequences that cannot be taken from rolls.

Example 2:


Input: rolls = [1,1,2,2], k = 2
Output: 2
Explanation: Every sequence of rolls of length 1, [1], [2], can be taken from rolls.
The sequence [2, 1] cannot be taken from rolls, so we return 2.
Note that there are other sequences that cannot be taken from rolls but [2, 1] is the shortest.


Example 3:


Input: rolls = [1,1,3,2,2,2,3,3], k = 4
Output: 1
Explanation: The sequence [4] cannot be taken from rolls, so we return 1.
Note that there are other sequences that cannot be taken from rolls but [4] is the shortest.


 

Constraints:

 * n == rolls.length
 * 1 <= n <= 105
 * 1 <= rolls[i] <= k <= 105",Solutions (190),520
FALSE,0,0,2434,,Design a Number Container System,design-a-number-container-system,FALSE,18491,40479,2349,FALSE,2,"Can you solve this real interview question? Design a Number Container System - Design a number container system that can do the following:

 * Insert or Replace a number at the given index in the system.
 * Return the smallest index for the given number in the system.

Implement the NumberContainers class:

 * NumberContainers() Initializes the number container system.
 * void change(int index, int number) Fills the container at index with the number. If there is already a number at that index, replace it.
 * int find(int number) Returns the smallest index for the given number, or -1 if there is no index that is filled by number in the system.

 

Example 1:


Input
[""NumberContainers"", ""find"", ""change"", ""change"", ""change"", ""change"", ""find"", ""change"", ""find""]
[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]
Output
[null, -1, null, null, null, null, 1, null, 2]

Explanation
NumberContainers nc = new NumberContainers();
nc.find(10); // There is no index that is filled with number 10. Therefore, we return -1.
nc.change(2, 10); // Your container at index 2 will be filled with number 10.
nc.change(1, 10); // Your container at index 1 will be filled with number 10.
nc.change(3, 10); // Your container at index 3 will be filled with number 10.
nc.change(5, 10); // Your container at index 5 will be filled with number 10.
nc.find(10); // Number 10 is at the indices 1, 2, 3, and 5. Since the smallest index that is filled with 10 is 1, we return 1.
nc.change(1, 20); // Your container at index 1 will be filled with number 20. Note that index 1 was filled with 10 and then replaced with 20. 
nc.find(10); // Number 10 is at the indices 2, 3, and 5. The smallest index that is filled with 10 is 2. Therefore, we return 2.


 

Constraints:

 * 1 <= index, number <= 109
 * At most 105 calls will be made in total to change and find.",Solutions (341),302
FALSE,0,0,2433,,Best Poker Hand,best-poker-hand,FALSE,30934,51016,2347,FALSE,1,"Can you solve this real interview question? Best Poker Hand - You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i].

The following are the types of poker hands you can make from best to worst:

 1. ""Flush"": Five cards of the same suit.
 2. ""Three of a Kind"": Three cards of the same rank.
 3. ""Pair"": Two cards of the same rank.
 4. ""High Card"": Any single card.

Return a string representing the best type of poker hand you can make with the given cards.

Note that the return values are case-sensitive.

 

Example 1:


Input: ranks = [13,2,3,1,9], suits = [""a"",""a"",""a"",""a"",""a""]
Output: ""Flush""
Explanation: The hand with all the cards consists of 5 cards with the same suit, so we have a ""Flush"".


Example 2:


Input: ranks = [4,4,2,4,4], suits = [""d"",""a"",""a"",""b"",""c""]
Output: ""Three of a Kind""
Explanation: The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a ""Three of a Kind"".
Note that we could also make a ""Pair"" hand but ""Three of a Kind"" is a better hand.
Also note that other cards could be used to make the ""Three of a Kind"" hand.

Example 3:


Input: ranks = [10,10,2,12,9], suits = [""a"",""b"",""c"",""a"",""d""]
Output: ""Pair""
Explanation: The hand with the first and second card consists of 2 cards with the same rank, so we have a ""Pair"".
Note that we cannot make a ""Flush"" or a ""Three of a Kind"".


 

Constraints:

 * ranks.length == suits.length == 5
 * 1 <= ranks[i] <= 13
 * 'a' <= suits[i] <= 'd'
 * No two cards have the same rank and suit.",Solutions (485),293
FALSE,0,0,2432,number-of-zero-filled-subarrays,Number of Zero-Filled Subarrays,number-of-zero-filled-subarrays,FALSE,102026,152852,2348,FALSE,2,"Can you solve this real interview question? Number of Zero-Filled Subarrays - Given an integer array nums, return the number of subarrays filled with 0.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: nums = [1,3,0,0,2,0,0,4]
Output: 6
Explanation: 
There are 4 occurrences of [0] as a subarray.
There are 2 occurrences of [0,0] as a subarray.
There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.

Example 2:


Input: nums = [0,0,0,2,0,0]
Output: 9
Explanation:
There are 5 occurrences of [0] as a subarray.
There are 3 occurrences of [0,0] as a subarray.
There is 1 occurrence of [0,0,0] as a subarray.
There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.


Example 3:


Input: nums = [2,10,2019]
Output: 0
Explanation: There is no subarray filled with 0. Therefore, we return 0.


 

Constraints:

 * 1 <= nums.length <= 105
 * -109 <= nums[i] <= 109",Solutions (2.2K),2K
FALSE,0,0,2430,,Number of Excellent Pairs,number-of-excellent-pairs,FALSE,11846,25738,2354,FALSE,3,"Can you solve this real interview question? Number of Excellent Pairs - You are given a 0-indexed positive integer array nums and a positive integer k.

A pair of numbers (num1, num2) is called excellent if the following conditions are satisfied:

 * Both the numbers num1 and num2 exist in the array nums.
 * The sum of the number of set bits in num1 OR num2 and num1 AND num2 is greater than or equal to k, where OR is the bitwise OR operation and AND is the bitwise AND operation.

Return the number of distinct excellent pairs.

Two pairs (a, b) and (c, d) are considered distinct if either a != c or b != d. For example, (1, 2) and (2, 1) are distinct.

Note that a pair (num1, num2) such that num1 == num2 can also be excellent if you have at least one occurrence of num1 in the array.

 

Example 1:


Input: nums = [1,2,3,1], k = 3
Output: 5
Explanation: The excellent pairs are the following:
- (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.
- (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.
- (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.
So the number of excellent pairs is 5.

Example 2:


Input: nums = [5,1,1], k = 10
Output: 0
Explanation: There are no excellent pairs for this array.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109
 * 1 <= k <= 60",Solutions (202),503
FALSE,0,0,2429,,Design a Food Rating System,design-a-food-rating-system,FALSE,16207,46769,2353,FALSE,2,"Can you solve this real interview question? Design a Food Rating System - Design a food rating system that can do the following:

 * Modify the rating of a food item listed in the system.
 * Return the highest-rated food item for a type of cuisine in the system.

Implement the FoodRatings class:

 * FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.
   * foods[i] is the name of the ith food,
   * cuisines[i] is the type of cuisine of the ith food, and
   * ratings[i] is the initial rating of the ith food.
 * void changeRating(String food, int newRating) Changes the rating of the food item with the name food.
 * String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.

Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.

 

Example 1:


Input
[""FoodRatings"", ""highestRated"", ""highestRated"", ""changeRating"", ""highestRated"", ""changeRating"", ""highestRated""]
[[[""kimchi"", ""miso"", ""sushi"", ""moussaka"", ""ramen"", ""bulgogi""], [""korean"", ""japanese"", ""japanese"", ""greek"", ""japanese"", ""korean""], [9, 12, 8, 15, 14, 7]], [""korean""], [""japanese""], [""sushi"", 16], [""japanese""], [""ramen"", 16], [""japanese""]]
Output
[null, ""kimchi"", ""ramen"", null, ""sushi"", null, ""ramen""]

Explanation
FoodRatings foodRatings = new FoodRatings([""kimchi"", ""miso"", ""sushi"", ""moussaka"", ""ramen"", ""bulgogi""], [""korean"", ""japanese"", ""japanese"", ""greek"", ""japanese"", ""korean""], [9, 12, 8, 15, 14, 7]);
foodRatings.highestRated(""korean""); // return ""kimchi""
                                    // ""kimchi"" is the highest rated korean food with a rating of 9.
foodRatings.highestRated(""japanese""); // return ""ramen""
                                      // ""ramen"" is the highest rated japanese food with a rating of 14.
foodRatings.changeRating(""sushi"", 16); // ""sushi"" now has a rating of 16.
foodRatings.highestRated(""japanese""); // return ""sushi""
                                      // ""sushi"" is the highest rated japanese food with a rating of 16.
foodRatings.changeRating(""ramen"", 16); // ""ramen"" now has a rating of 16.
foodRatings.highestRated(""japanese""); // return ""ramen""
                                      // Both ""sushi"" and ""ramen"" have a rating of 16.
                                      // However, ""ramen"" is lexicographically smaller than ""sushi"".


 

Constraints:

 * 1 <= n <= 2 * 104
 * n == foods.length == cuisines.length == ratings.length
 * 1 <= foods[i].length, cuisines[i].length <= 10
 * foods[i], cuisines[i] consist of lowercase English letters.
 * 1 <= ratings[i] <= 108
 * All the strings in foods are distinct.
 * food will be the name of a food item in the system across all calls to changeRating.
 * cuisine will be a type of cuisine of at least one food item in the system across all calls to highestRated.
 * At most 2 * 104 calls in total will be made to changeRating and highestRated.",Solutions (331),441
FALSE,0,0,2428,,Equal Row and Column Pairs,equal-row-and-column-pairs,FALSE,33741,47742,2352,FALSE,2,"Can you solve this real interview question? Equal Row and Column Pairs - Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.

A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).

 

Example 1:

[https://assets.leetcode.com/uploads/2022/06/01/ex1.jpg]


Input: grid = [[3,2,1],[1,7,6],[2,7,7]]
Output: 1
Explanation: There is 1 equal row and column pair:
- (Row 2, Column 1): [2,7,7]


Example 2:

[https://assets.leetcode.com/uploads/2022/06/01/ex2.jpg]


Input: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
Output: 3
Explanation: There are 3 equal row and column pairs:
- (Row 0, Column 0): [3,1,2,2]
- (Row 2, Column 2): [2,4,2,2]
- (Row 3, Column 2): [2,4,2,2]


 

Constraints:

 * n == grid.length == grid[i].length
 * 1 <= n <= 200
 * 1 <= grid[i][j] <= 105",Solutions (574),422
FALSE,0,0,2427,,First Letter to Appear Twice,first-letter-to-appear-twice,FALSE,67775,90506,2351,FALSE,1,"Can you solve this real interview question? First Letter to Appear Twice - Given a string s consisting of lowercase English letters, return the first letter to appear twice.

Note:

 * A letter a appears twice before another letter b if the second occurrence of a is before the second occurrence of b.
 * s will contain at least one letter that appears twice.

 

Example 1:


Input: s = ""abccbaacz""
Output: ""c""
Explanation:
The letter 'a' appears on the indexes 0, 5 and 6.
The letter 'b' appears on the indexes 1 and 4.
The letter 'c' appears on the indexes 2, 3 and 7.
The letter 'z' appears on the index 8.
The letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.


Example 2:


Input: s = ""abcdd""
Output: ""d""
Explanation:
The only letter that appears twice is 'd' so we return 'd'.


 

Constraints:

 * 2 <= s.length <= 100
 * s consists of lowercase English letters.
 * s has at least one repeated letter.",Solutions (1.3K),714
FALSE,0,0,2423,,Minimum Deletions to Make Array Divisible,minimum-deletions-to-make-array-divisible,FALSE,23120,40738,2344,FALSE,3,"Can you solve this real interview question? Minimum Deletions to Make Array Divisible - You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.

Return the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.

Note that an integer x divides y if y % x == 0.

 

Example 1:


Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]
Output: 2
Explanation: 
The smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.
We use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].
The smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.
It can be shown that 2 is the minimum number of deletions needed.


Example 2:


Input: nums = [4,3,6], numsDivide = [8,2,6,10]
Output: -1
Explanation: 
We want the smallest element in nums to divide all the elements of numsDivide.
There is no way to delete elements from nums to allow this.

 

Constraints:

 * 1 <= nums.length, numsDivide.length <= 105
 * 1 <= nums[i], numsDivide[i] <= 109",Solutions (455),464
FALSE,0,0,2422,,Query Kth Smallest Trimmed Number,query-kth-smallest-trimmed-number,FALSE,20830,50366,2343,FALSE,2,"Can you solve this real interview question? Query Kth Smallest Trimmed Number - You are given a 0-indexed array of strings nums, where each string is of equal length and consists of only digits.

You are also given a 0-indexed 2D integer array queries where queries[i] = [ki, trimi]. For each queries[i], you need to:

 * Trim each number in nums to its rightmost trimi digits.
 * Determine the index of the kith smallest trimmed number in nums. If two trimmed numbers are equal, the number with the lower index is considered to be smaller.
 * Reset each number in nums to its original length.

Return an array answer of the same length as queries, where answer[i] is the answer to the ith query.

Note:

 * To trim to the rightmost x digits means to keep removing the leftmost digit, until only x digits remain.
 * Strings in nums may contain leading zeros.

 

Example 1:


Input: nums = [""102"",""473"",""251"",""814""], queries = [[1,1],[2,3],[4,2],[1,2]]
Output: [2,2,1,0]
Explanation:
1. After trimming to the last digit, nums = [""2"",""3"",""1"",""4""]. The smallest number is 1 at index 2.
2. Trimmed to the last 3 digits, nums is unchanged. The 2nd smallest number is 251 at index 2.
3. Trimmed to the last 2 digits, nums = [""02"",""73"",""51"",""14""]. The 4th smallest number is 73.
4. Trimmed to the last 2 digits, the smallest number is 2 at index 0.
   Note that the trimmed number ""02"" is evaluated as 2.


Example 2:


Input: nums = [""24"",""37"",""96"",""04""], queries = [[2,1],[2,2]]
Output: [3,0]
Explanation:
1. Trimmed to the last digit, nums = [""4"",""7"",""6"",""4""]. The 2nd smallest number is 4 at index 3.
   There are two occurrences of 4, but the one at index 0 is considered smaller than the one at index 3.
2. Trimmed to the last 2 digits, nums is unchanged. The 2nd smallest number is 24.


 

Constraints:

 * 1 <= nums.length <= 100
 * 1 <= nums[i].length <= 100
 * nums[i] consists of only digits.
 * All nums[i].length are equal.
 * 1 <= queries.length <= 100
 * queries[i].length == 2
 * 1 <= ki <= nums.length
 * 1 <= trimi <= nums[i].length

 

Follow up: Could you use the Radix Sort Algorithm to solve this problem? What will be the complexity of that solution?",Solutions (394),226
FALSE,0,0,2421,,Maximum Number of Pairs in Array,maximum-number-of-pairs-in-array,FALSE,46634,61370,2341,FALSE,1,"Can you solve this real interview question? Maximum Number of Pairs in Array - You are given a 0-indexed integer array nums. In one operation, you may do the following:

 * Choose two integers in nums that are equal.
 * Remove both integers from nums, forming a pair.

The operation is done on nums as many times as possible.

Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.

 

Example 1:


Input: nums = [1,3,2,1,3,2,2]
Output: [3,1]
Explanation:
Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].
Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].
Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].
No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.


Example 2:


Input: nums = [1,1]
Output: [1,0]
Explanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].
No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.


Example 3:


Input: nums = [0]
Output: [0,1]
Explanation: No pairs can be formed, and there is 1 number leftover in nums.


 

Constraints:

 * 1 <= nums.length <= 100
 * 0 <= nums[i] <= 100",Solutions (1.2K),502
FALSE,0,0,2419,,Subarray With Elements Greater Than Varying Threshold,subarray-with-elements-greater-than-varying-threshold,FALSE,5971,14501,2334,FALSE,3,"Can you solve this real interview question? Subarray With Elements Greater Than Varying Threshold - You are given an integer array nums and an integer threshold.

Find any subarray of nums of length k such that every element in the subarray is greater than threshold / k.

Return the size of any such subarray. If there is no such subarray, return -1.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: nums = [1,3,4,3,1], threshold = 6
Output: 3
Explanation: The subarray [3,4,3] has a size of 3, and every element is greater than 6 / 3 = 2.
Note that this is the only valid subarray.


Example 2:


Input: nums = [6,5,6,5,8], threshold = 7
Output: 1
Explanation: The subarray [8] has a size of 1, and 8 > 7 / 1 = 7. So 1 is returned.
Note that the subarray [6,5] has a size of 2, and every element is greater than 7 / 2 = 3.5. 
Similarly, the subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the given conditions.
Therefore, 2, 3, 4, or 5 may also be returned.

 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i], threshold <= 109",Solutions (136),432
FALSE,0,0,2418,,Minimum Sum of Squared Difference,minimum-sum-of-squared-difference,FALSE,11015,43181,2333,FALSE,2,"Can you solve this real interview question? Minimum Sum of Squared Difference - You are given two positive 0-indexed integer arrays nums1 and nums2, both of length n.

The sum of squared difference of arrays nums1 and nums2 is defined as the sum of (nums1[i] - nums2[i])2 for each 0 <= i < n.

You are also given two positive integers k1 and k2. You can modify any of the elements of nums1 by +1 or -1 at most k1 times. Similarly, you can modify any of the elements of nums2 by +1 or -1 at most k2 times.

Return the minimum sum of squared difference after modifying array nums1 at most k1 times and modifying array nums2 at most k2 times.

Note: You are allowed to modify the array elements to become negative integers.

 

Example 1:


Input: nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0
Output: 579
Explanation: The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. 
The sum of square difference will be: (1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579.


Example 2:


Input: nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1
Output: 43
Explanation: One way to obtain the minimum sum of square difference is: 
- Increase nums1[0] once.
- Increase nums2[2] once.
The minimum of the sum of square difference will be: 
(2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43.
Note that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43.

 

Constraints:

 * n == nums1.length == nums2.length
 * 1 <= n <= 105
 * 0 <= nums1[i], nums2[i] <= 105
 * 0 <= k1, k2 <= 109",Solutions (198),516
FALSE,0,0,2417,,The Latest Time to Catch a Bus,the-latest-time-to-catch-a-bus,FALSE,13309,56767,2332,FALSE,2,"Can you solve this real interview question? The Latest Time to Catch a Bus - You are given a 0-indexed integer array buses of length n, where buses[i] represents the departure time of the ith bus. You are also given a 0-indexed integer array passengers of length m, where passengers[j] represents the arrival time of the jth passenger. All bus departure times are unique. All passenger arrival times are unique.

You are given an integer capacity, which represents the maximum number of passengers that can get on each bus.

When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x, and the bus is not full. Passengers with the earliest arrival times get on the bus first.

More formally when a bus arrives, either:

 * If capacity or fewer passengers are waiting for a bus, they will all get on the bus, or
 * The capacity passengers with the earliest arrival times will get on the bus.

Return the latest time you may arrive at the bus station to catch a bus. You cannot arrive at the same time as another passenger.

Note: The arrays buses and passengers are not necessarily sorted.

 

Example 1:


Input: buses = [10,20], passengers = [2,17,18,19], capacity = 2
Output: 16
Explanation: Suppose you arrive at time 16.
At time 10, the first bus departs with the 0th passenger. 
At time 20, the second bus departs with you and the 1st passenger.
Note that you may not arrive at the same time as another passenger, which is why you must arrive before the 1st passenger to catch the bus.

Example 2:


Input: buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2
Output: 20
Explanation: Suppose you arrive at time 20.
At time 10, the first bus departs with the 3rd passenger. 
At time 20, the second bus departs with the 5th and 1st passengers.
At time 30, the third bus departs with the 0th passenger and you.
Notice if you had arrived any later, then the 6th passenger would have taken your seat on the third bus.

 

Constraints:

 * n == buses.length
 * m == passengers.length
 * 1 <= n, m, capacity <= 105
 * 2 <= buses[i], passengers[i] <= 109
 * Each element in buses is unique.
 * Each element in passengers is unique.",Solutions (277),311
FALSE,0,0,2416,,Evaluate Boolean Binary Tree,evaluate-boolean-binary-tree,FALSE,43818,55805,2331,FALSE,1,"Can you solve this real interview question? Evaluate Boolean Binary Tree - You are given the root of a full binary tree with the following properties:

 * Leaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.
 * Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.

The evaluation of a node is as follows:

 * If the node is a leaf node, the evaluation is the value of the node, i.e. True or False.
 * Otherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.

Return the boolean result of evaluating the root node.

A full binary tree is a binary tree where each node has either 0 or 2 children.

A leaf node is a node that has zero children.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/05/16/example1drawio1.png]


Input: root = [2,1,3,null,null,0,1]
Output: true
Explanation: The above diagram illustrates the evaluation process.
The AND node evaluates to False AND True = False.
The OR node evaluates to True OR False = True.
The root node evaluates to True, so we return true.

Example 2:


Input: root = [0]
Output: false
Explanation: The root node is a leaf node and it evaluates to false, so we return false.


 

Constraints:

 * The number of nodes in the tree is in the range [1, 1000].
 * 0 <= Node.val <= 3
 * Every node has either 0 or 2 children.
 * Leaf nodes have a value of 0 or 1.
 * Non-leaf nodes have a value of 2 or 3.",Solutions (829),662
FALSE,0,0,2415,,Count the Number of Ideal Arrays,count-the-number-of-ideal-arrays,FALSE,4741,17994,2338,FALSE,3,"Can you solve this real interview question? Count the Number of Ideal Arrays - You are given two integers n and maxValue, which are used to describe an ideal array.

A 0-indexed integer array arr of length n is considered ideal if the following conditions hold:

 * Every arr[i] is a value from 1 to maxValue, for 0 <= i < n.
 * Every arr[i] is divisible by arr[i - 1], for 0 < i < n.

Return the number of distinct ideal arrays of length n. Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:


Input: n = 2, maxValue = 5
Output: 10
Explanation: The following are the possible ideal arrays:
- Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5]
- Arrays starting with the value 2 (2 arrays): [2,2], [2,4]
- Arrays starting with the value 3 (1 array): [3,3]
- Arrays starting with the value 4 (1 array): [4,4]
- Arrays starting with the value 5 (1 array): [5,5]
There are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.


Example 2:


Input: n = 5, maxValue = 3
Output: 11
Explanation: The following are the possible ideal arrays:
- Arrays starting with the value 1 (9 arrays): 
   - With no other distinct values (1 array): [1,1,1,1,1] 
   - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]
   - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]
- Arrays starting with the value 2 (1 array): [2,2,2,2,2]
- Arrays starting with the value 3 (1 array): [3,3,3,3,3]
There are a total of 9 + 1 + 1 = 11 distinct ideal arrays.


 

Constraints:

 * 2 <= n <= 104
 * 1 <= maxValue <= 104",Solutions (106),380
FALSE,0,0,2414,,Move Pieces to Obtain a String,move-pieces-to-obtain-a-string,FALSE,20664,43218,2337,FALSE,2,"Can you solve this real interview question? Move Pieces to Obtain a String - You are given two strings start and target, both of length n. Each string consists only of the characters 'L', 'R', and '_' where:

 * The characters 'L' and 'R' represent pieces, where a piece 'L' can move to the left only if there is a blank space directly to its left, and a piece 'R' can move to the right only if there is a blank space directly to its right.
 * The character '_' represents a blank space that can be occupied by any of the 'L' or 'R' pieces.

Return true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.

 

Example 1:


Input: start = ""_L__R__R_"", target = ""L______RR""
Output: true
Explanation: We can obtain the string target from start by doing the following moves:
- Move the first piece one step to the left, start becomes equal to ""L___R__R_"".
- Move the last piece one step to the right, start becomes equal to ""L___R___R"".
- Move the second piece three steps to the right, start becomes equal to ""L______RR"".
Since it is possible to get the string target from start, we return true.


Example 2:


Input: start = ""R_L_"", target = ""__LR""
Output: false
Explanation: The 'R' piece in the string start can move one step to the right to obtain ""_RL_"".
After that, no pieces can move anymore, so it is impossible to obtain the string target from start.


Example 3:


Input: start = ""_R"", target = ""R_""
Output: false
Explanation: The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.

 

Constraints:

 * n == start.length == target.length
 * 1 <= n <= 105
 * start and target consist of the characters 'L', 'R', and '_'.",Solutions (360),537
FALSE,0,0,2413,smallest-number-in-infinite-set,Smallest Number in Infinite Set,smallest-number-in-infinite-set,FALSE,28218,39569,2336,FALSE,2,"Can you solve this real interview question? Smallest Number in Infinite Set - You have a set which contains all positive integers [1, 2, 3, 4, 5, ...].

Implement the SmallestInfiniteSet class:

 * SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers.
 * int popSmallest() Removes and returns the smallest integer contained in the infinite set.
 * void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set.

 

Example 1:


Input
[""SmallestInfiniteSet"", ""addBack"", ""popSmallest"", ""popSmallest"", ""popSmallest"", ""addBack"", ""popSmallest"", ""popSmallest"", ""popSmallest""]
[[], [2], [], [], [], [1], [], [], []]
Output
[null, null, 1, 2, 3, null, 1, 4, 5]

Explanation
SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();
smallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.
smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.
smallestInfiniteSet.addBack(1);    // 1 is added back to the set.
smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and
                                   // is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.


 

Constraints:

 * 1 <= num <= 1000
 * At most 1000 calls will be made in total to popSmallest and addBack.",Solutions (494),370
FALSE,0,0,2412,,Minimum Amount of Time to Fill Cups,minimum-amount-of-time-to-fill-cups,FALSE,33621,59730,2335,FALSE,1,"Can you solve this real interview question? Minimum Amount of Time to Fill Cups - You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water.

You are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively. Return the minimum number of seconds needed to fill up all the cups.

 

Example 1:


Input: amount = [1,4,2]
Output: 4
Explanation: One way to fill up the cups is:
Second 1: Fill up a cold cup and a warm cup.
Second 2: Fill up a warm cup and a hot cup.
Second 3: Fill up a warm cup and a hot cup.
Second 4: Fill up a warm cup.
It can be proven that 4 is the minimum number of seconds needed.


Example 2:


Input: amount = [5,4,4]
Output: 7
Explanation: One way to fill up the cups is:
Second 1: Fill up a cold cup, and a hot cup.
Second 2: Fill up a cold cup, and a warm cup.
Second 3: Fill up a cold cup, and a warm cup.
Second 4: Fill up a warm cup, and a hot cup.
Second 5: Fill up a cold cup, and a hot cup.
Second 6: Fill up a cold cup, and a warm cup.
Second 7: Fill up a hot cup.


Example 3:


Input: amount = [5,0,0]
Output: 5
Explanation: Every second, we fill up a cold cup.


 

Constraints:

 * amount.length == 3
 * 0 <= amount[i] <= 100",Solutions (574),490
FALSE,0,0,2411,,Spiral Matrix IV,spiral-matrix-iv,FALSE,26178,35026,2326,FALSE,2,"Can you solve this real interview question? Spiral Matrix IV - You are given two integers m and n, which represent the dimensions of a matrix.

You are also given the head of a linked list of integers.

Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.

Return the generated matrix.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg]


Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
Explanation: The diagram above shows how the values are printed in the matrix.
Note that the remaining spaces in the matrix are filled with -1.


Example 2:

[https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg]


Input: m = 1, n = 4, head = [0,1,2]
Output: [[0,1,2,-1]]
Explanation: The diagram above shows how the values are printed from left to right in the matrix.
The last space in the matrix is set to -1.

 

Constraints:

 * 1 <= m, n <= 105
 * 1 <= m * n <= 105
 * The number of nodes in the list is in the range [1, m * n].
 * 0 <= Node.val <= 1000",Solutions (597),471
FALSE,0,0,2409,number-of-increasing-paths-in-a-grid,Number of Increasing Paths in a Grid,number-of-increasing-paths-in-a-grid,FALSE,16559,34762,2328,FALSE,3,"Can you solve this real interview question? Number of Increasing Paths in a Grid - You are given an m x n integer matrix grid, where you can move from a cell to any adjacent cell in all 4 directions.

Return the number of strictly increasing paths in the grid such that you can start from any cell and end at any cell. Since the answer may be very large, return it modulo 109 + 7.

Two paths are considered different if they do not have exactly the same sequence of visited cells.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png]


Input: grid = [[1,1],[3,4]]
Output: 8
Explanation: The strictly increasing paths are:
- Paths with length 1: [1], [1], [3], [4].
- Paths with length 2: [1 -> 3], [1 -> 4], [3 -> 4].
- Paths with length 3: [1 -> 3 -> 4].
The total number of paths is 4 + 3 + 1 = 8.


Example 2:


Input: grid = [[1],[2]]
Output: 3
Explanation: The strictly increasing paths are:
- Paths with length 1: [1], [2].
- Paths with length 2: [1 -> 2].
The total number of paths is 2 + 1 = 3.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 1000
 * 1 <= m * n <= 105
 * 1 <= grid[i][j] <= 105",Solutions (387),691
FALSE,0,0,2408,,Number of People Aware of a Secret,number-of-people-aware-of-a-secret,FALSE,16848,37605,2327,FALSE,2,"Can you solve this real interview question? Number of People Aware of a Secret - On day 1, one person discovers a secret.

You are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards.

Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:


Input: n = 6, delay = 2, forget = 4
Output: 5
Explanation:
Day 1: Suppose the first person is named A. (1 person)
Day 2: A is the only person who knows the secret. (1 person)
Day 3: A shares the secret with a new person, B. (2 people)
Day 4: A shares the secret with a new person, C. (3 people)
Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)
Day 6: B shares the secret with E, and C shares the secret with F. (5 people)


Example 2:


Input: n = 4, delay = 1, forget = 3
Output: 6
Explanation:
Day 1: The first person is named A. (1 person)
Day 2: A shares the secret with B. (2 people)
Day 3: A and B share the secret with 2 new people, C and D. (4 people)
Day 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)


 

Constraints:

 * 2 <= n <= 1000
 * 1 <= delay < forget <= n",Solutions (351),665
FALSE,0,0,2406,,Decode the Message,decode-the-message,FALSE,54025,63877,2325,FALSE,1,"Can you solve this real interview question? Decode the Message - You are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows:

 1. Use the first appearance of all 26 lowercase English letters in key as the order of the substitution table.
 2. Align the substitution table with the regular English alphabet.
 3. Each letter in message is then substituted using the table.
 4. Spaces ' ' are transformed to themselves.

 * For example, given key = ""happy boy"" (actual key would have at least one instance of each letter in the alphabet), we have the partial substitution table of ('h' -> 'a', 'a' -> 'b', 'p' -> 'c', 'y' -> 'd', 'b' -> 'e', 'o' -> 'f').

Return the decoded message.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/05/08/ex1new4.jpg]


Input: key = ""the quick brown fox jumps over the lazy dog"", message = ""vkbs bs t suepuv""
Output: ""this is a secret""
Explanation: The diagram above shows the substitution table.
It is obtained by taking the first appearance of each letter in ""the quick brown fox jumps over the lazy dog"".


Example 2:

[https://assets.leetcode.com/uploads/2022/05/08/ex2new.jpg]


Input: key = ""eljuxhpwnyrdgtqkviszcfmabo"", message = ""zwx hnfx lqantp mnoeius ycgk vcnjrdb""
Output: ""the five boxing wizards jump quickly""
Explanation: The diagram above shows the substitution table.
It is obtained by taking the first appearance of each letter in ""eljuxhpwnyrdgtqkviszcfmabo"".


 

Constraints:

 * 26 <= key.length <= 2000
 * key consists of lowercase English letters and ' '.
 * key contains every letter in the English alphabet ('a' to 'z') at least once.
 * 1 <= message.length <= 2000
 * message consists of lowercase English letters and ' '.",Solutions (1.1K),618
FALSE,0,0,2404,,Number of Distinct Roll Sequences,number-of-distinct-roll-sequences,FALSE,8363,14871,2318,FALSE,3,"Can you solve this real interview question? Number of Distinct Roll Sequences - You are given an integer n. You roll a fair 6-sided dice n times. Determine the total number of distinct sequences of rolls possible such that the following conditions are satisfied:

 1. The greatest common divisor of any adjacent values in the sequence is equal to 1.
 2. There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2.

Return the total number of distinct sequences possible. Since the answer may be very large, return it modulo 109 + 7.

Two sequences are considered distinct if at least one element is different.

 

Example 1:


Input: n = 4
Output: 184
Explanation: Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc.
Some invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6).
(1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).
(1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3.
There are a total of 184 distinct sequences possible, so we return 184.

Example 2:


Input: n = 2
Output: 22
Explanation: Some of the possible sequences are (1, 2), (2, 1), (3, 2).
Some invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1.
There are a total of 22 distinct sequences possible, so we return 22.


 

Constraints:

 * 1 <= n <= 104",Solutions (216),366
FALSE,0,0,2403,count-unreachable-pairs-of-nodes-in-an-undirected-graph,Count Unreachable Pairs of Nodes in an Undirected Graph,count-unreachable-pairs-of-nodes-in-an-undirected-graph,FALSE,21770,56038,2316,FALSE,2,"Can you solve this real interview question? Count Unreachable Pairs of Nodes in an Undirected Graph - You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.

Return the number of pairs of different nodes that are unreachable from each other.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/05/05/tc-3.png]


Input: n = 3, edges = [[0,1],[0,2],[1,2]]
Output: 0
Explanation: There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.


Example 2:

[https://assets.leetcode.com/uploads/2022/05/05/tc-2.png]


Input: n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]
Output: 14
Explanation: There are 14 pairs of nodes that are unreachable from each other:
[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].
Therefore, we return 14.


 

Constraints:

 * 1 <= n <= 105
 * 0 <= edges.length <= 2 * 105
 * edges[i].length == 2
 * 0 <= ai, bi < n
 * ai != bi
 * There are no repeated edges.",Solutions (1.3K),1.7K
FALSE,0,0,2402,,Maximum XOR After Operations ,maximum-xor-after-operations,FALSE,16912,21363,2317,FALSE,2,"Can you solve this real interview question? Maximum XOR After Operations  - You are given a 0-indexed integer array nums. In one operation, select any non-negative integer x and an index i, then update nums[i] to be equal to nums[i] AND (nums[i] XOR x).

Note that AND is the bitwise AND operation and XOR is the bitwise XOR operation.

Return the maximum possible bitwise XOR of all elements of nums after applying the operation any number of times.

 

Example 1:


Input: nums = [3,2,4,6]
Output: 7
Explanation: Apply the operation with x = 4 and i = 3, num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2.
Now, nums = [3, 2, 4, 2] and the bitwise XOR of all the elements = 3 XOR 2 XOR 4 XOR 2 = 7.
It can be shown that 7 is the maximum possible bitwise XOR.
Note that other operations may be used to achieve a bitwise XOR of 7.

Example 2:


Input: nums = [1,2,3,9,2]
Output: 11
Explanation: Apply the operation zero times.
The bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11.
It can be shown that 11 is the maximum possible bitwise XOR.

 

Constraints:

 * 1 <= nums.length <= 105
 * 0 <= nums[i] <= 108",Solutions (266),461
FALSE,0,0,2401,,Count Asterisks,count-asterisks,FALSE,42790,52079,2315,FALSE,1,"Can you solve this real interview question? Count Asterisks - You are given a string s, where every two consecutive vertical bars '|' are grouped into a pair. In other words, the 1st and 2nd '|' make a pair, the 3rd and 4th '|' make a pair, and so forth.

Return the number of '*' in s, excluding the '*' between each pair of '|'.

Note that each '|' will belong to exactly one pair.

 

Example 1:


Input: s = ""l|*e*et|c**o|*de|""
Output: 2
Explanation: The considered characters are underlined: ""l|*e*et|c**o|*de|"".
The characters between the first and second '|' are excluded from the answer.
Also, the characters between the third and fourth '|' are excluded from the answer.
There are 2 asterisks considered. Therefore, we return 2.

Example 2:


Input: s = ""iamprogrammer""
Output: 0
Explanation: In this example, there are no asterisks in s. Therefore, we return 0.


Example 3:


Input: s = ""yo|uar|e**|b|e***au|tifu|l""
Output: 5
Explanation: The considered characters are underlined: ""yo|uar|e**|b|e***au|tifu|l"". There are 5 asterisks considered. Therefore, we return 5.

 

Constraints:

 * 1 <= s.length <= 1000
 * s consists of lowercase English letters, vertical bars '|', and asterisks '*'.
 * s contains an even number of vertical bars '|'.",Solutions (1K),432
FALSE,0,0,2400,,Minimum Score After Removals on a Tree,minimum-score-after-removals-on-a-tree,FALSE,5394,10619,2322,FALSE,3,"Can you solve this real interview question? Minimum Score After Removals on a Tree - There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.

You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

Remove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:

 1. Get the XOR of all the values of the nodes for each of the three components respectively.
 2. The difference between the largest XOR value and the smallest XOR value is the score of the pair.

 * For example, say the three components have the node values: [4,5,7], [1,9], and [3,3,3]. The three XOR values are 4 ^ 5 ^ 7 = 6, 1 ^ 9 = 8, and 3 ^ 3 ^ 3 = 3. The largest XOR value is 8 and the smallest XOR value is 3. The score is then 8 - 3 = 5.

Return the minimum score of any possible pair of edge removals on the given tree.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png]


Input: nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]
Output: 9
Explanation: The diagram above shows a way to make a pair of removals.
- The 1st component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10.
- The 2nd component has node [0] with value [1]. Its XOR value is 1 = 1.
- The 3rd component has node [2] with value [5]. Its XOR value is 5 = 5.
The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.
It can be shown that no other pair of removals will obtain a smaller score than 9.


Example 2:

[https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png]


Input: nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]
Output: 0
Explanation: The diagram above shows a way to make a pair of removals.
- The 1st component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0.
- The 2nd component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0.
- The 3rd component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0.
The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.
We cannot obtain a smaller score than 0.


 

Constraints:

 * n == nums.length
 * 3 <= n <= 1000
 * 1 <= nums[i] <= 108
 * edges.length == n - 1
 * edges[i].length == 2
 * 0 <= ai, bi < n
 * ai != bi
 * edges represents a valid tree.",Solutions (116),371
FALSE,0,0,2398,,Check if Matrix Is X-Matrix,check-if-matrix-is-x-matrix,FALSE,36833,55231,2319,FALSE,1,"Can you solve this real interview question? Check if Matrix Is X-Matrix - A square matrix is said to be an X-Matrix if both of the following conditions hold:

 1. All the elements in the diagonals of the matrix are non-zero.
 2. All other elements are 0.

Given a 2D integer array grid of size n x n representing a square matrix, return true if grid is an X-Matrix. Otherwise, return false.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/05/03/ex1.jpg]


Input: grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]
Output: true
Explanation: Refer to the diagram above. 
An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.
Thus, grid is an X-Matrix.


Example 2:

[https://assets.leetcode.com/uploads/2022/05/03/ex2.jpg]


Input: grid = [[5,7,0],[0,3,1],[0,5,0]]
Output: false
Explanation: Refer to the diagram above.
An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.
Thus, grid is not an X-Matrix.


 

Constraints:

 * n == grid.length == grid[i].length
 * 3 <= n <= 100
 * 0 <= grid[i][j] <= 105",Solutions (596),348
FALSE,0,0,2397,,Count Number of Ways to Place Houses,count-number-of-ways-to-place-houses,FALSE,21822,53694,2320,FALSE,2,"Can you solve this real interview question? Count Number of Ways to Place Houses - There is a street with n * 2 plots, where there are n plots on each side of the street. The plots on each side are numbered from 1 to n. On each plot, a house can be placed.

Return the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street. Since the answer may be very large, return it modulo 109 + 7.

Note that if a house is placed on the ith plot on one side of the street, a house can also be placed on the ith plot on the other side of the street.

 

Example 1:


Input: n = 1
Output: 4
Explanation: 
Possible arrangements:
1. All plots are empty.
2. A house is placed on one side of the street.
3. A house is placed on the other side of the street.
4. Two houses are placed, one on each side of the street.


Example 2:

[https://assets.leetcode.com/uploads/2022/05/12/arrangements.png]


Input: n = 2
Output: 9
Explanation: The 9 possible arrangements are shown in the diagram above.


 

Constraints:

 * 1 <= n <= 104",Solutions (381),442
FALSE,0,0,2395,,Longest Binary Subsequence Less Than or Equal to K,longest-binary-subsequence-less-than-or-equal-to-k,FALSE,18258,49140,2311,FALSE,2,"Can you solve this real interview question? Longest Binary Subsequence Less Than or Equal to K - You are given a binary string s and a positive integer k.

Return the length of the longest subsequence of s that makes up a binary number less than or equal to k.

Note:

 * The subsequence can contain leading zeroes.
 * The empty string is considered to be equal to 0.
 * A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

 

Example 1:


Input: s = ""1001010"", k = 5
Output: 5
Explanation: The longest subsequence of s that makes up a binary number less than or equal to 5 is ""00010"", as this number is equal to 2 in decimal.
Note that ""00100"" and ""00101"" are also possible, which are equal to 4 and 5 in decimal, respectively.
The length of this subsequence is 5, so 5 is returned.


Example 2:


Input: s = ""00101001"", k = 1
Output: 6
Explanation: ""000001"" is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal.
The length of this subsequence is 6, so 6 is returned.


 

Constraints:

 * 1 <= s.length <= 1000
 * s[i] is either '0' or '1'.
 * 1 <= k <= 109",Solutions (393),582
FALSE,0,0,2394,,Count Subarrays With Score Less Than K,count-subarrays-with-score-less-than-k,FALSE,16227,31022,2302,FALSE,3,"Can you solve this real interview question? Count Subarrays With Score Less Than K - The score of an array is defined as the product of its sum and its length.

 * For example, the score of [1, 2, 3, 4, 5] is (1 + 2 + 3 + 4 + 5) * 5 = 75.

Given a positive integer array nums and an integer k, return the number of non-empty subarrays of nums whose score is strictly less than k.

A subarray is a contiguous sequence of elements within an array.

 

Example 1:


Input: nums = [2,1,4,3,5], k = 10
Output: 6
Explanation:
The 6 subarrays having scores less than 10 are:
- [2] with score 2 * 1 = 2.
- [1] with score 1 * 1 = 1.
- [4] with score 4 * 1 = 4.
- [3] with score 3 * 1 = 3. 
- [5] with score 5 * 1 = 5.
- [2,1] with score (2 + 1) * 2 = 6.
Note that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.

Example 2:


Input: nums = [1,1,1], k = 5
Output: 5
Explanation:
Every subarray except [1,1,1] has a score less than 5.
[1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5.
Thus, there are 5 subarrays having scores less than 5.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 105
 * 1 <= k <= 1015",Solutions (348),721
FALSE,0,0,2393,,Match Substring After Replacement,match-substring-after-replacement,FALSE,11199,28376,2301,FALSE,3,"Can you solve this real interview question? Match Substring After Replacement - You are given two strings s and sub. You are also given a 2D character array mappings where mappings[i] = [oldi, newi] indicates that you may perform the following operation any number of times:

 * Replace a character oldi of sub with newi.

Each character in sub cannot be replaced more than once.

Return true if it is possible to make sub a substring of s by replacing zero or more characters according to mappings. Otherwise, return false.

A substring is a contiguous non-empty sequence of characters within a string.

 

Example 1:


Input: s = ""fool3e7bar"", sub = ""leet"", mappings = [[""e"",""3""],[""t"",""7""],[""t"",""8""]]
Output: true
Explanation: Replace the first 'e' in sub with '3' and 't' in sub with '7'.
Now sub = ""l3e7"" is a substring of s, so we return true.

Example 2:


Input: s = ""fooleetbar"", sub = ""f00l"", mappings = [[""o"",""0""]]
Output: false
Explanation: The string ""f00l"" is not a substring of s and no replacements can be made.
Note that we cannot replace '0' with 'o'.


Example 3:


Input: s = ""Fool33tbaR"", sub = ""leetd"", mappings = [[""e"",""3""],[""t"",""7""],[""t"",""8""],[""d"",""b""],[""p"",""b""]]
Output: true
Explanation: Replace the first and second 'e' in sub with '3' and 'd' in sub with 'b'.
Now sub = ""l33tb"" is a substring of s, so we return true.



 

Constraints:

 * 1 <= sub.length <= s.length <= 5000
 * 0 <= mappings.length <= 1000
 * mappings[i].length == 2
 * oldi != newi
 * s and sub consist of uppercase and lowercase English letters and digits.
 * oldi and newi are either uppercase or lowercase English letters or digits.",Solutions (215),324
FALSE,0,0,2392,successful-pairs-of-spells-and-potions,Successful Pairs of Spells and Potions,successful-pairs-of-spells-and-potions,FALSE,22430,69001,2300,FALSE,2,"Can you solve this real interview question? Successful Pairs of Spells and Potions - You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.

You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.

Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.

 

Example 1:


Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7
Output: [4,0,3]
Explanation:
- 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.
- 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
- 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.
Thus, [4,0,3] is returned.


Example 2:


Input: spells = [3,1,2], potions = [8,5,8], success = 16
Output: [2,0,2]
Explanation:
- 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.
- 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. 
- 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. 
Thus, [2,0,2] is returned.


 

Constraints:

 * n == spells.length
 * m == potions.length
 * 1 <= n, m <= 105
 * 1 <= spells[i], potions[i] <= 105
 * 1 <= success <= 1010",Solutions (419),484
FALSE,0,0,2391,,Strong Password Checker II,strong-password-checker-ii,FALSE,30007,53283,2299,FALSE,1,"Can you solve this real interview question? Strong Password Checker II - A password is said to be strong if it satisfies all the following criteria:

 * It has at least 8 characters.
 * It contains at least one lowercase letter.
 * It contains at least one uppercase letter.
 * It contains at least one digit.
 * It contains at least one special character. The special characters are the characters in the following string: ""!@#$%^&*()-+"".
 * It does not contain 2 of the same character in adjacent positions (i.e., ""aab"" violates this condition, but ""aba"" does not).

Given a string password, return true if it is a strong password. Otherwise, return false.

 

Example 1:


Input: password = ""IloveLe3tcode!""
Output: true
Explanation: The password meets all the requirements. Therefore, we return true.


Example 2:


Input: password = ""Me+You--IsMyDream""
Output: false
Explanation: The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false.


Example 3:


Input: password = ""1aB!""
Output: false
Explanation: The password does not meet the length requirement. Therefore, we return false.

 

Constraints:

 * 1 <= password.length <= 100
 * password consists of letters, digits, and special characters: ""!@#$%^&*()-+"".",Solutions (557),262
FALSE,0,0,2390,naming-a-company,Naming a Company,naming-a-company,FALSE,54728,116251,2306,FALSE,3,"Can you solve this real interview question? Naming a Company - You are given an array of strings ideas that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:

 1. Choose 2 distinct names from ideas, call them ideaA and ideaB.
 2. Swap the first letters of ideaA and ideaB with each other.
 3. If both of the new names are not found in the original ideas, then the name ideaA ideaB (the concatenation of ideaA and ideaB, separated by a space) is a valid company name.
 4. Otherwise, it is not a valid name.

Return the number of distinct valid names for the company.

 

Example 1:


Input: ideas = [""coffee"",""donuts"",""time"",""toffee""]
Output: 6
Explanation: The following selections are valid:
- (""coffee"", ""donuts""): The company name created is ""doffee conuts"".
- (""donuts"", ""coffee""): The company name created is ""conuts doffee"".
- (""donuts"", ""time""): The company name created is ""tonuts dime"".
- (""donuts"", ""toffee""): The company name created is ""tonuts doffee"".
- (""time"", ""donuts""): The company name created is ""dime tonuts"".
- (""toffee"", ""donuts""): The company name created is ""doffee tonuts"".
Therefore, there are a total of 6 distinct company names.

The following are some examples of invalid selections:
- (""coffee"", ""time""): The name ""toffee"" formed after swapping already exists in the original array.
- (""time"", ""toffee""): Both names are still the same after swapping and exist in the original array.
- (""coffee"", ""toffee""): Both names formed after swapping already exist in the original array.


Example 2:


Input: ideas = [""lack"",""back""]
Output: 0
Explanation: There are no valid selections. Therefore, 0 is returned.


 

Constraints:

 * 2 <= ideas.length <= 5 * 104
 * 1 <= ideas[i].length <= 10
 * ideas[i] consists of lowercase English letters.
 * All the strings in ideas are unique.",Solutions (606),1.8K
FALSE,0,0,2389,,Design a Text Editor,design-a-text-editor,FALSE,15780,38720,2296,FALSE,3,"Can you solve this real interview question? Design a Text Editor - Design a text editor with a cursor that can do the following:

 * Add text to where the cursor is.
 * Delete text from where the cursor is (simulating the backspace key).
 * Move the cursor either left or right.

When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.

Implement the TextEditor class:

 * TextEditor() Initializes the object with empty text.
 * void addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.
 * int deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.
 * string cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.
 * string cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.

 

Example 1:


Input
[""TextEditor"", ""addText"", ""deleteText"", ""addText"", ""cursorRight"", ""cursorLeft"", ""deleteText"", ""cursorLeft"", ""cursorRight""]
[[], [""leetcode""], [4], [""practice""], [3], [8], [10], [2], [6]]
Output
[null, null, 4, null, ""etpractice"", ""leet"", 4, """", ""practi""]

Explanation
TextEditor textEditor = new TextEditor(); // The current text is ""|"". (The '|' character represents the cursor)
textEditor.addText(""leetcode""); // The current text is ""leetcode|"".
textEditor.deleteText(4); // return 4
                          // The current text is ""leet|"". 
                          // 4 characters were deleted.
textEditor.addText(""practice""); // The current text is ""leetpractice|"". 
textEditor.cursorRight(3); // return ""etpractice""
                           // The current text is ""leetpractice|"". 
                           // The cursor cannot be moved beyond the actual text and thus did not move.
                           // ""etpractice"" is the last 10 characters to the left of the cursor.
textEditor.cursorLeft(8); // return ""leet""
                          // The current text is ""leet|practice"".
                          // ""leet"" is the last min(10, 4) = 4 characters to the left of the cursor.
textEditor.deleteText(10); // return 4
                           // The current text is ""|practice"".
                           // Only 4 characters were deleted.
textEditor.cursorLeft(2); // return """"
                          // The current text is ""|practice"".
                          // The cursor cannot be moved beyond the actual text and thus did not move. 
                          // """" is the last min(10, 0) = 0 characters to the left of the cursor.
textEditor.cursorRight(6); // return ""practi""
                           // The current text is ""practi|ce"".
                           // ""practi"" is the last min(10, 6) = 6 characters to the left of the cursor.


 

Constraints:

 * 1 <= text.length, k <= 40
 * text consists of lowercase English letters.
 * At most 2 * 104 calls in total will be made to addText, deleteText, cursorLeft and cursorRight.

 

Follow-up: Could you find a solution with time complexity of O(k) per call?",Solutions (343),427
FALSE,0,0,2388,,Replace Elements in an Array,replace-elements-in-an-array,FALSE,27656,48017,2295,FALSE,2,"Can you solve this real interview question? Replace Elements in an Array - You are given a 0-indexed array nums that consists of n distinct positive integers. Apply m operations to this array, where in the ith operation you replace the number operations[i][0] with operations[i][1].

It is guaranteed that in the ith operation:

 * operations[i][0] exists in nums.
 * operations[i][1] does not exist in nums.

Return the array obtained after applying all the operations.

 

Example 1:


Input: nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]
Output: [3,2,7,1]
Explanation: We perform the following operations on nums:
- Replace the number 1 with 3. nums becomes [3,2,4,6].
- Replace the number 4 with 7. nums becomes [3,2,7,6].
- Replace the number 6 with 1. nums becomes [3,2,7,1].
We return the final array [3,2,7,1].


Example 2:


Input: nums = [1,2], operations = [[1,3],[2,1],[3,2]]
Output: [2,1]
Explanation: We perform the following operations to nums:
- Replace the number 1 with 3. nums becomes [3,2].
- Replace the number 2 with 1. nums becomes [3,1].
- Replace the number 3 with 2. nums becomes [2,1].
We return the array [2,1].


 

Constraints:

 * n == nums.length
 * m == operations.length
 * 1 <= n, m <= 105
 * All the values of nums are distinct.
 * operations[i].length == 2
 * 1 <= nums[i], operations[i][0], operations[i][1] <= 106
 * operations[i][0] will exist in nums when applying the ith operation.
 * operations[i][1] will not exist in nums when applying the ith operation.",Solutions (515),506
FALSE,0,0,2387,,Partition Array Such That Maximum Difference Is K,partition-array-such-that-maximum-difference-is-k,FALSE,30548,42052,2294,FALSE,2,"Can you solve this real interview question? Partition Array Such That Maximum Difference Is K - You are given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences.

Return the minimum number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is at most k.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:


Input: nums = [3,6,1,2,5], k = 2
Output: 2
Explanation:
We can partition nums into the two subsequences [3,1,2] and [6,5].
The difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.
The difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.
Since two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.


Example 2:


Input: nums = [1,2,3], k = 1
Output: 2
Explanation:
We can partition nums into the two subsequences [1,2] and [3].
The difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.
The difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.
Since two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3].


Example 3:


Input: nums = [2,2,4,5], k = 0
Output: 3
Explanation:
We can partition nums into the three subsequences [2,2], [4], and [5].
The difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.
The difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.
The difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.
Since three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.


 

Constraints:

 * 1 <= nums.length <= 105
 * 0 <= nums[i] <= 105
 * 0 <= k <= 105",Solutions (586),581
FALSE,0,0,2386,,Min Max Game,min-max-game,FALSE,35576,55824,2293,FALSE,1,"Can you solve this real interview question? Min Max Game - You are given a 0-indexed integer array nums whose length is a power of 2.

Apply the following algorithm on nums:

 1. Let n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2.
 2. For every even index i where 0 <= i < n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]).
 3. For every odd index i where 0 <= i < n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]).
 4. Replace the array nums with newNums.
 5. Repeat the entire process starting from step 1.

Return the last number that remains in nums after applying the algorithm.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/04/13/example1drawio-1.png]


Input: nums = [1,3,5,2,4,8,2,2]
Output: 1
Explanation: The following arrays are the results of applying the algorithm repeatedly.
First: nums = [1,5,4,2]
Second: nums = [1,4]
Third: nums = [1]
1 is the last remaining number, so we return 1.


Example 2:


Input: nums = [3]
Output: 3
Explanation: 3 is already the last remaining number, so we return 3.


 

Constraints:

 * 1 <= nums.length <= 1024
 * 1 <= nums[i] <= 109
 * nums.length is a power of 2.",Solutions (638),411
FALSE,0,0,2384,,Root Equals Sum of Children,root-equals-sum-of-children,FALSE,116163,137172,2236,FALSE,1,"Can you solve this real interview question? Root Equals Sum of Children - You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.

Return true if the value of the root is equal to the sum of the values of its two children, or false otherwise.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png]


Input: root = [10,4,6]
Output: true
Explanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.
10 is equal to 4 + 6, so we return true.


Example 2:

[https://assets.leetcode.com/uploads/2022/04/08/graph3drawio-1.png]


Input: root = [5,3,1]
Output: false
Explanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.
5 is not equal to 3 + 1, so we return false.


 

Constraints:

 * The tree consists only of the root, its left child, and its right child.
 * -100 <= Node.val <= 100",Solutions (1.1K),797
FALSE,0,0,2383,,Add Two Integers,add-two-integers,FALSE,248820,281158,2235,FALSE,1,"Can you solve this real interview question? Add Two Integers - Given two integers num1 and num2, return the sum of the two integers.

 

Example 1:


Input: num1 = 12, num2 = 5
Output: 17
Explanation: num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.


Example 2:


Input: num1 = -10, num2 = 4
Output: -6
Explanation: num1 + num2 = -6, so -6 is returned.


 

Constraints:

 * -100 <= num1, num2 <= 100",Solutions (920),958
FALSE,0,0,2380,,Booking Concert Tickets in Groups,booking-concert-tickets-in-groups,FALSE,4431,29085,2286,FALSE,3,"Can you solve this real interview question? Booking Concert Tickets in Groups - A concert hall has n rows numbered from 0 to n - 1, each with m seats, numbered from 0 to m - 1. You need to design a ticketing system that can allocate seats in the following cases:

 * If a group of k spectators can sit together in a row.
 * If every member of a group of k spectators can get a seat. They may or may not sit together.

Note that the spectators are very picky. Hence:

 * They will book seats only if each member of their group can get a seat with row number less than or equal to maxRow. maxRow can vary from group to group.
 * In case there are multiple rows to choose from, the row with the smallest number is chosen. If there are multiple seats to choose in the same row, the seat with the smallest number is chosen.

Implement the BookMyShow class:

 * BookMyShow(int n, int m) Initializes the object with n as number of rows and m as number of seats per row.
 * int[] gather(int k, int maxRow) Returns an array of length 2 denoting the row and seat number (respectively) of the first seat being allocated to the k members of the group, who must sit together. In other words, it returns the smallest possible r and c such that all [c, c + k - 1] seats are valid and empty in row r, and r <= maxRow. Returns [] in case it is not possible to allocate seats to the group.
 * boolean scatter(int k, int maxRow) Returns true if all k members of the group can be allocated seats in rows 0 to maxRow, who may or may not sit together. If the seats can be allocated, it allocates k seats to the group with the smallest row numbers, and the smallest possible seat numbers in each row. Otherwise, returns false.

 

Example 1:


Input
[""BookMyShow"", ""gather"", ""gather"", ""scatter"", ""scatter""]
[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]
Output
[null, [0, 0], [], true, false]

Explanation
BookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each 
bms.gather(4, 0); // return [0, 0]
                  // The group books seats [0, 3] of row 0. 
bms.gather(2, 0); // return []
                  // There is only 1 seat left in row 0,
                  // so it is not possible to book 2 consecutive seats. 
bms.scatter(5, 1); // return True
                   // The group books seat 4 of row 0 and seats [0, 3] of row 1. 
bms.scatter(5, 1); // return False
                   // There is only one seat left in the hall.


 

Constraints:

 * 1 <= n <= 5 * 104
 * 1 <= m, k <= 109
 * 0 <= maxRow <= n - 1
 * At most 5 * 104 calls in total will be made to gather and scatter.",Solutions (122),262
FALSE,0,0,2379,,Maximum Total Importance of Roads,maximum-total-importance-of-roads,FALSE,24478,40287,2285,FALSE,2,"Can you solve this real interview question? Maximum Total Importance of Roads - You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.

You are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.

You need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.

Return the maximum total importance of all roads possible after assigning the values optimally.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/04/07/ex1drawio.png]


Input: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
Output: 43
Explanation: The figure above shows the country and the assigned values of [2,4,5,3,1].
- The road (0,1) has an importance of 2 + 4 = 6.
- The road (1,2) has an importance of 4 + 5 = 9.
- The road (2,3) has an importance of 5 + 3 = 8.
- The road (0,2) has an importance of 2 + 5 = 7.
- The road (1,3) has an importance of 4 + 3 = 7.
- The road (2,4) has an importance of 5 + 1 = 6.
The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.
It can be shown that we cannot obtain a greater total importance than 43.


Example 2:

[https://assets.leetcode.com/uploads/2022/04/07/ex2drawio.png]


Input: n = 5, roads = [[0,3],[2,4],[1,3]]
Output: 20
Explanation: The figure above shows the country and the assigned values of [4,3,2,5,1].
- The road (0,3) has an importance of 4 + 5 = 9.
- The road (2,4) has an importance of 2 + 1 = 3.
- The road (1,3) has an importance of 3 + 5 = 8.
The total importance of all roads is 9 + 3 + 8 = 20.
It can be shown that we cannot obtain a greater total importance than 20.


 

Constraints:

 * 2 <= n <= 5 * 104
 * 1 <= roads.length <= 5 * 104
 * roads[i].length == 2
 * 0 <= ai, bi <= n - 1
 * ai != bi
 * There are no duplicate roads.",Solutions (508),572
FALSE,0,0,2378,,Sender With Largest Word Count,sender-with-largest-word-count,FALSE,25913,46180,2284,FALSE,2,"Can you solve this real interview question? Sender With Largest Word Count - You have a chat log of n messages. You are given two string arrays messages and senders where messages[i] is a message sent by senders[i].

A message is list of words that are separated by a single space with no leading or trailing spaces. The word count of a sender is the total number of words sent by the sender. Note that a sender may send more than one message.

Return the sender with the largest word count. If there is more than one sender with the largest word count, return the one with the lexicographically largest name.

Note:

 * Uppercase letters come before lowercase letters in lexicographical order.
 * ""Alice"" and ""alice"" are distinct.

 

Example 1:


Input: messages = [""Hello userTwooo"",""Hi userThree"",""Wonderful day Alice"",""Nice day userThree""], senders = [""Alice"",""userTwo"",""userThree"",""Alice""]
Output: ""Alice""
Explanation: Alice sends a total of 2 + 3 = 5 words.
userTwo sends a total of 2 words.
userThree sends a total of 3 words.
Since Alice has the largest word count, we return ""Alice"".


Example 2:


Input: messages = [""How is leetcode for everyone"",""Leetcode is useful for practice""], senders = [""Bob"",""Charlie""]
Output: ""Charlie""
Explanation: Bob sends a total of 5 words.
Charlie sends a total of 5 words.
Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie.

 

Constraints:

 * n == messages.length == senders.length
 * 1 <= n <= 104
 * 1 <= messages[i].length <= 100
 * 1 <= senders[i].length <= 10
 * messages[i] consists of uppercase and lowercase English letters and ' '.
 * All the words in messages[i] are separated by a single space.
 * messages[i] does not have leading or trailing spaces.
 * senders[i] consists of uppercase and lowercase English letters only.",Solutions (538),310
FALSE,0,0,2377,,Check if Number Has Equal Digit Count and Digit Value,check-if-number-has-equal-digit-count-and-digit-value,FALSE,37862,51723,2283,FALSE,1,"Can you solve this real interview question? Check if Number Has Equal Digit Count and Digit Value - You are given a 0-indexed string num of length n consisting of digits.

Return true if for every index i in the range 0 <= i < n, the digit i occurs num[i] times in num, otherwise return false.

 

Example 1:


Input: num = ""1210""
Output: true
Explanation:
num[0] = '1'. The digit 0 occurs once in num.
num[1] = '2'. The digit 1 occurs twice in num.
num[2] = '1'. The digit 2 occurs once in num.
num[3] = '0'. The digit 3 occurs zero times in num.
The condition holds true for every index in ""1210"", so return true.


Example 2:


Input: num = ""030""
Output: false
Explanation:
num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.
num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.
num[2] = '0'. The digit 2 occurs zero times in num.
The indices 0 and 1 both violate the condition, so return false.


 

Constraints:

 * n == num.length
 * 1 <= n <= 10
 * num consists of digits.",Solutions (741),426
FALSE,0,0,2375,,Minimum Obstacle Removal to Reach Corner,minimum-obstacle-removal-to-reach-corner,FALSE,15884,32075,2290,FALSE,3,"Can you solve this real interview question? Minimum Obstacle Removal to Reach Corner - You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:

 * 0 represents an empty cell,
 * 1 represents an obstacle that may be removed.

You can move up, down, left, or right from and to an empty cell.

Return the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).

 

Example 1:

[https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png]


Input: grid = [[0,1,1],[1,1,0],[1,1,0]]
Output: 2
Explanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).
It can be shown that we need to remove at least 2 obstacles, so we return 2.
Note that there may be other ways to remove 2 obstacles to create a path.


Example 2:

[https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png]


Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
Output: 0
Explanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 105
 * 2 <= m * n <= 105
 * grid[i][j] is either 0 or 1.
 * grid[0][0] == grid[m - 1][n - 1] == 0",Solutions (301),712
FALSE,0,0,2374,,Steps to Make Array Non-decreasing,steps-to-make-array-non-decreasing,FALSE,14192,67430,2289,FALSE,2,"Can you solve this real interview question? Steps to Make Array Non-decreasing - You are given a 0-indexed integer array nums. In one step, remove all elements nums[i] where nums[i - 1] > nums[i] for all 0 < i < nums.length.

Return the number of steps performed until nums becomes a non-decreasing array.

 

Example 1:


Input: nums = [5,3,4,4,7,3,6,11,8,5,11]
Output: 3
Explanation: The following are the steps performed:
- Step 1: [5,3,4,4,7,3,6,11,8,5,11] becomes [5,4,4,7,6,11,11]
- Step 2: [5,4,4,7,6,11,11] becomes [5,4,7,11,11]
- Step 3: [5,4,7,11,11] becomes [5,7,11,11]
[5,7,11,11] is a non-decreasing array. Therefore, we return 3.


Example 2:


Input: nums = [4,5,7,7,13]
Output: 0
Explanation: nums is already a non-decreasing array. Therefore, we return 0.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109",Solutions (169),1K
FALSE,0,0,2373,,Apply Discount to Prices,apply-discount-to-prices,FALSE,17203,61642,2288,FALSE,2,"Can you solve this real interview question? Apply Discount to Prices - A sentence is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign '$'. A word represents a price if it is a sequence of digits preceded by a dollar sign.

 * For example, ""$100"", ""$23"", and ""$6"" represent prices while ""100"", ""$"", and ""$1e5"" do not.

You are given a string sentence representing a sentence and an integer discount. For each word representing a price, apply a discount of discount% on the price and update the word in the sentence. All updated prices should be represented with exactly two decimal places.

Return a string representing the modified sentence.

Note that all prices will contain at most 10 digits.

 

Example 1:


Input: sentence = ""there are $1 $2 and 5$ candies in the shop"", discount = 50
Output: ""there are $0.50 $1.00 and 5$ candies in the shop""
Explanation: 
The words which represent prices are ""$1"" and ""$2"". 
- A 50% discount on ""$1"" yields ""$0.50"", so ""$1"" is replaced by ""$0.50"".
- A 50% discount on ""$2"" yields ""$1"". Since we need to have exactly 2 decimal places after a price, we replace ""$2"" with ""$1.00"".


Example 2:


Input: sentence = ""1 2 $3 4 $5 $6 7 8$ $9 $10$"", discount = 100
Output: ""1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$""
Explanation: 
Applying a 100% discount on any price will result in 0.
The words representing prices are ""$3"", ""$5"", ""$6"", and ""$9"".
Each of them is replaced by ""$0.00"".


 

Constraints:

 * 1 <= sentence.length <= 105
 * sentence consists of lowercase English letters, digits, ' ', and '$'.
 * sentence does not have leading or trailing spaces.
 * All words in sentence are separated by a single space.
 * All prices will be positive numbers without leading zeros.
 * All prices will have at most 10 digits.
 * 0 <= discount <= 100",Solutions (392),152
FALSE,0,0,2372,,Rearrange Characters to Make Target String,rearrange-characters-to-make-target-string,FALSE,30216,52017,2287,FALSE,1,"Can you solve this real interview question? Rearrange Characters to Make Target String - You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings.

Return the maximum number of copies of target that can be formed by taking letters from s and rearranging them.

 

Example 1:


Input: s = ""ilovecodingonleetcode"", target = ""code""
Output: 2
Explanation:
For the first copy of ""code"", take the letters at indices 4, 5, 6, and 7.
For the second copy of ""code"", take the letters at indices 17, 18, 19, and 20.
The strings that are formed are ""ecod"" and ""code"" which can both be rearranged into ""code"".
We can make at most two copies of ""code"", so we return 2.


Example 2:


Input: s = ""abcba"", target = ""abc""
Output: 1
Explanation:
We can make one copy of ""abc"" by taking the letters at indices 0, 1, and 2.
We can make at most one copy of ""abc"", so we return 1.
Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of ""abc"".


Example 3:


Input: s = ""abbaccaddaeea"", target = ""aaaaa""
Output: 1
Explanation:
We can make one copy of ""aaaaa"" by taking the letters at indices 0, 3, 6, 9, and 12.
We can make at most one copy of ""aaaaa"", so we return 1.


 

Constraints:

 * 1 <= s.length <= 100
 * 1 <= target.length <= 10
 * s and target consist of lowercase English letters.",Solutions (528),359
FALSE,0,0,2368,sum-of-total-strength-of-wizards,Sum of Total Strength of Wizards,sum-of-total-strength-of-wizards,FALSE,13922,50872,2281,FALSE,3,"Can you solve this real interview question? Sum of Total Strength of Wizards - As the ruler of a kingdom, you have an army of wizards at your command.

You are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:

 * The strength of the weakest wizard in the group.
 * The total of all the individual strengths of the wizards in the group.

Return the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: strength = [1,3,1,2]
Output: 44
Explanation: The following are all the contiguous groups of wizards:
- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9
- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4
- [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4
- [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4
- [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3
- [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5
- [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6
- [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7
The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.


Example 2:


Input: strength = [5,4,6]
Output: 213
Explanation: The following are all the contiguous groups of wizards: 
- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25
- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16
- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36
- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36
- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40
- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60
The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.


 

Constraints:

 * 1 <= strength.length <= 105
 * 1 <= strength[i] <= 109",Solutions (114),933
FALSE,0,0,2367,,Minimum Lines to Represent a Line Chart,minimum-lines-to-represent-a-line-chart,FALSE,21892,90136,2280,FALSE,2,"Can you solve this real interview question? Minimum Lines to Represent a Line Chart - You are given a 2D integer array stockPrices where stockPrices[i] = [dayi, pricei] indicates the price of the stock on day dayi is pricei. A line chart is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:

[https://assets.leetcode.com/uploads/2022/03/30/1920px-pushkin_population_historysvg.png]

Return the minimum number of lines needed to represent the line chart.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/30/ex0.png]


Input: stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]
Output: 3
Explanation:
The diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.
The following 3 lines can be drawn to represent the line chart:
- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).
- Line 2 (in blue) from (4,4) to (5,4).
- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).
It can be shown that it is not possible to represent the line chart using less than 3 lines.


Example 2:

[https://assets.leetcode.com/uploads/2022/03/30/ex1.png]


Input: stockPrices = [[3,4],[1,2],[7,8],[2,3]]
Output: 1
Explanation:
As shown in the diagram above, the line chart can be represented with a single line.


 

Constraints:

 * 1 <= stockPrices.length <= 105
 * stockPrices[i].length == 2
 * 1 <= dayi, pricei <= 109
 * All dayi are distinct.",Solutions (413),303
FALSE,0,0,2366,maximum-bags-with-full-capacity-of-rocks,Maximum Bags With Full Capacity of Rocks,maximum-bags-with-full-capacity-of-rocks,FALSE,84072,124096,2279,FALSE,2,"Can you solve this real interview question? Maximum Bags With Full Capacity of Rocks - You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.

Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.

 

Example 1:


Input: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2
Output: 3
Explanation:
Place 1 rock in bag 0 and 1 rock in bag 1.
The number of rocks in each bag are now [2,3,4,4].
Bags 0, 1, and 2 have full capacity.
There are 3 bags at full capacity, so we return 3.
It can be shown that it is not possible to have more than 3 bags at full capacity.
Note that there may be other ways of placing the rocks that result in an answer of 3.


Example 2:


Input: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100
Output: 3
Explanation:
Place 8 rocks in bag 0 and 2 rocks in bag 2.
The number of rocks in each bag are now [10,2,2].
Bags 0, 1, and 2 have full capacity.
There are 3 bags at full capacity, so we return 3.
It can be shown that it is not possible to have more than 3 bags at full capacity.
Note that we did not use all of the additional rocks.


 

Constraints:

 * n == capacity.length == rocks.length
 * 1 <= n <= 5 * 104
 * 1 <= capacity[i] <= 109
 * 0 <= rocks[i] <= capacity[i]
 * 1 <= additionalRocks <= 109",Solutions (2K),1.5K
FALSE,0,0,2365,,Percentage of Letter in String,percentage-of-letter-in-string,FALSE,47230,63876,2278,FALSE,1,"Can you solve this real interview question? Percentage of Letter in String - Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.

 

Example 1:


Input: s = ""foobar"", letter = ""o""
Output: 33
Explanation:
The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.


Example 2:


Input: s = ""jjjj"", letter = ""k""
Output: 0
Explanation:
The percentage of characters in s that equal the letter 'k' is 0%, so we return 0.

 

Constraints:

 * 1 <= s.length <= 100
 * s consists of lowercase English letters.
 * letter is a lowercase English letter.",Solutions (916),365
FALSE,0,0,2364,longest-path-with-different-adjacent-characters,Longest Path With Different Adjacent Characters,longest-path-with-different-adjacent-characters,FALSE,65241,116884,2246,FALSE,3,"Can you solve this real interview question? Longest Path With Different Adjacent Characters - You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 consisting of n nodes numbered from 0 to n - 1. The tree is represented by a 0-indexed array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1.

You are also given a string s of length n, where s[i] is the character assigned to node i.

Return the length of the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png]


Input: parent = [-1,0,0,1,1,2], s = ""abacbe""
Output: 3
Explanation: The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.
It can be proven that there is no longer path that satisfies the conditions. 


Example 2:

[https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png]


Input: parent = [-1,0,0,0], s = ""aabc""
Output: 3
Explanation: The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned.


 

Constraints:

 * n == parent.length == s.length
 * 1 <= n <= 105
 * 0 <= parent[i] <= n - 1 for all i >= 1
 * parent[0] == -1
 * parent represents a valid tree.
 * s consists of only lowercase English letters.",Solutions (936),2.2K
FALSE,0,0,2363,,Maximum Trailing Zeros in a Cornered Path,maximum-trailing-zeros-in-a-cornered-path,FALSE,6902,19700,2245,FALSE,2,"Can you solve this real interview question? Maximum Trailing Zeros in a Cornered Path - You are given a 2D integer array grid of size m x n, where each cell contains a positive integer.

A cornered path is defined as a set of adjacent cells with at most one turn. More specifically, the path should exclusively move either horizontally or vertically up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the alternate direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.

The product of a path is defined as the product of all the values in the path.

Return the maximum number of trailing zeros in the product of a cornered path found in grid.

Note:

 * Horizontal movement means moving in either the left or right direction.
 * Vertical movement means moving in either the up or down direction.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg]


Input: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]
Output: 3
Explanation: The grid on the left shows a valid cornered path.
It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.
It can be shown that this is the maximum trailing zeros in the product of a cornered path.

The grid in the middle is not a cornered path as it has more than one turn.
The grid on the right is not a cornered path as it requires a return to a previously visited cell.


Example 2:

[https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg]


Input: grid = [[4,3,2],[7,6,1],[8,8,8]]
Output: 0
Explanation: The grid is shown in the figure above.
There are no cornered paths in the grid that result in a product with a trailing zero.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 105
 * 1 <= m * n <= 105
 * 1 <= grid[i][j] <= 1000",Solutions (174),155
FALSE,0,0,2362,minimum-rounds-to-complete-all-tasks,Minimum Rounds to Complete All Tasks,minimum-rounds-to-complete-all-tasks,FALSE,130561,207446,2244,FALSE,2,"Can you solve this real interview question? Minimum Rounds to Complete All Tasks - You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.

Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.

 

Example 1:


Input: tasks = [2,2,3,3,2,4,4,4,4,4]
Output: 4
Explanation: To complete all the tasks, a possible plan is:
- In the first round, you complete 3 tasks of difficulty level 2. 
- In the second round, you complete 2 tasks of difficulty level 3. 
- In the third round, you complete 3 tasks of difficulty level 4. 
- In the fourth round, you complete 2 tasks of difficulty level 4.  
It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.


Example 2:


Input: tasks = [2,3,3]
Output: -1
Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.


 

Constraints:

 * 1 <= tasks.length <= 105
 * 1 <= tasks[i] <= 109",Solutions (2.5K),2.5K
FALSE,0,0,2361,,Calculate Digit Sum of a String,calculate-digit-sum-of-a-string,FALSE,28987,43671,2243,FALSE,1,"Can you solve this real interview question? Calculate Digit Sum of a String - You are given a string s consisting of digits and an integer k.

A round can be completed if the length of s is greater than k. In one round, do the following:

 1. Divide s into consecutive groups of size k such that the first k characters are in the first group, the next k characters are in the second group, and so on. Note that the size of the last group can be smaller than k.
 2. Replace each group of s with a string representing the sum of all its digits. For example, ""346"" is replaced with ""13"" because 3 + 4 + 6 = 13.
 3. Merge consecutive groups together to form a new string. If the length of the string is greater than k, repeat from step 1.

Return s after all rounds have been completed.

 

Example 1:


Input: s = ""11111222223"", k = 3
Output: ""135""
Explanation: 
- For the first round, we divide s into groups of size 3: ""111"", ""112"", ""222"", and ""23"".
  ​​​​​Then we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. 
  So, s becomes ""3"" + ""4"" + ""6"" + ""5"" = ""3465"" after the first round.
- For the second round, we divide s into ""346"" and ""5"".
  Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. 
  So, s becomes ""13"" + ""5"" = ""135"" after second round. 
Now, s.length <= k, so we return ""135"" as the answer.


Example 2:


Input: s = ""00000000"", k = 3
Output: ""000""
Explanation: 
We divide s into ""000"", ""000"", and ""00"".
Then we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. 
s becomes ""0"" + ""0"" + ""0"" = ""000"", whose length is equal to k, so we return ""000"".


 

Constraints:

 * 1 <= s.length <= 100
 * 2 <= k <= 100
 * s consists of digits only.",Solutions (563),430
FALSE,0,0,2360,,Substring With Largest Variance,substring-with-largest-variance,FALSE,23534,63648,2272,FALSE,3,"Can you solve this real interview question? Substring With Largest Variance - The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.

Given a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.

A substring is a contiguous sequence of characters within a string.

 

Example 1:


Input: s = ""aababbb""
Output: 3
Explanation:
All possible variances along with their respective substrings are listed below:
- Variance 0 for substrings ""a"", ""aa"", ""ab"", ""abab"", ""aababb"", ""ba"", ""b"", ""bb"", and ""bbb"".
- Variance 1 for substrings ""aab"", ""aba"", ""abb"", ""aabab"", ""ababb"", ""aababbb"", and ""bab"".
- Variance 2 for substrings ""aaba"", ""ababbb"", ""abbb"", and ""babb"".
- Variance 3 for substring ""babbb"".
Since the largest possible variance is 3, we return it.


Example 2:


Input: s = ""abcde""
Output: 0
Explanation:
No letter occurs more than once in s, so the variance of every substring is 0.


 

Constraints:

 * 1 <= s.length <= 104
 * s consists of lowercase English letters.",Solutions (137),698
FALSE,0,0,2359,,Maximum White Tiles Covered by a Carpet,maximum-white-tiles-covered-by-a-carpet,FALSE,13087,39697,2271,FALSE,2,"Can you solve this real interview question? Maximum White Tiles Covered by a Carpet - You are given a 2D integer array tiles where tiles[i] = [li, ri] represents that every tile j in the range li <= j <= ri is colored white.

You are also given an integer carpetLen, the length of a single carpet that can be placed anywhere.

Return the maximum number of white tiles that can be covered by the carpet.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/25/example1drawio3.png]


Input: tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10
Output: 9
Explanation: Place the carpet starting on tile 10. 
It covers 9 white tiles, so we return 9.
Note that there may be other places where the carpet covers 9 white tiles.
It can be shown that the carpet cannot cover more than 9 white tiles.


Example 2:

[https://assets.leetcode.com/uploads/2022/03/24/example2drawio.png]


Input: tiles = [[10,11],[1,1]], carpetLen = 2
Output: 2
Explanation: Place the carpet starting on tile 10. 
It covers 2 white tiles, so we return 2.


 

Constraints:

 * 1 <= tiles.length <= 5 * 104
 * tiles[i].length == 2
 * 1 <= li <= ri <= 109
 * 1 <= carpetLen <= 109
 * The tiles are non-overlapping.",Solutions (209),651
FALSE,0,0,2358,,Number of Ways to Split Array,number-of-ways-to-split-array,FALSE,25448,55710,2270,FALSE,2,"Can you solve this real interview question? Number of Ways to Split Array - You are given a 0-indexed integer array nums of length n.

nums contains a valid split at index i if the following are true:

 * The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.
 * There is at least one element to the right of i. That is, 0 <= i < n - 1.

Return the number of valid splits in nums.

 

Example 1:


Input: nums = [10,4,-8,7]
Output: 2
Explanation: 
There are three ways of splitting nums into two non-empty parts:
- Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split.
- Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, i = 1 is a valid split.
- Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split.
Thus, the number of valid splits in nums is 2.


Example 2:


Input: nums = [2,3,1,0]
Output: 2
Explanation: 
There are two valid splits in nums:
- Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split. 
- Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split.


 

Constraints:

 * 2 <= nums.length <= 105
 * -105 <= nums[i] <= 105",Solutions (401),411
FALSE,0,0,2357,,Count Integers in Intervals,count-integers-in-intervals,FALSE,12826,37304,2276,FALSE,3,"Can you solve this real interview question? Count Integers in Intervals - Given an empty set of intervals, implement a data structure that can:

 * Add an interval to the set of intervals.
 * Count the number of integers that are present in at least one interval.

Implement the CountIntervals class:

 * CountIntervals() Initializes the object with an empty set of intervals.
 * void add(int left, int right) Adds the interval [left, right] to the set of intervals.
 * int count() Returns the number of integers that are present in at least one interval.

Note that an interval [left, right] denotes all the integers x where left <= x <= right.

 

Example 1:


Input
[""CountIntervals"", ""add"", ""add"", ""count"", ""add"", ""count""]
[[], [2, 3], [7, 10], [], [5, 8], []]
Output
[null, null, null, 6, null, 8]

Explanation
CountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals. 
countIntervals.add(2, 3);  // add [2, 3] to the set of intervals.
countIntervals.add(7, 10); // add [7, 10] to the set of intervals.
countIntervals.count();    // return 6
                           // the integers 2 and 3 are present in the interval [2, 3].
                           // the integers 7, 8, 9, and 10 are present in the interval [7, 10].
countIntervals.add(5, 8);  // add [5, 8] to the set of intervals.
countIntervals.count();    // return 8
                           // the integers 2 and 3 are present in the interval [2, 3].
                           // the integers 5 and 6 are present in the interval [5, 8].
                           // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10].
                           // the integers 9 and 10 are present in the interval [7, 10].


 

Constraints:

 * 1 <= left <= right <= 109
 * At most 105 calls in total will be made to add and count.
 * At least one call will be made to count.",Solutions (157),461
FALSE,0,0,2356,,Largest Combination With Bitwise AND Greater Than Zero,largest-combination-with-bitwise-and-greater-than-zero,FALSE,20312,28071,2275,FALSE,2,"Can you solve this real interview question? Largest Combination With Bitwise AND Greater Than Zero - The bitwise AND of an array nums is the bitwise AND of all integers in nums.

 * For example, for nums = [1, 5, 3], the bitwise AND is equal to 1 & 5 & 3 = 1.
 * Also, for nums = [7], the bitwise AND is 7.

You are given an array of positive integers candidates. Evaluate the bitwise AND of every combination of numbers of candidates. Each number in candidates may only be used once in each combination.

Return the size of the largest combination of candidates with a bitwise AND greater than 0.

 

Example 1:


Input: candidates = [16,17,71,62,12,24,14]
Output: 4
Explanation: The combination [16,17,62,24] has a bitwise AND of 16 & 17 & 62 & 24 = 16 > 0.
The size of the combination is 4.
It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.
Note that more than one combination may have the largest size.
For example, the combination [62,12,24,14] has a bitwise AND of 62 & 12 & 24 & 14 = 8 > 0.


Example 2:


Input: candidates = [8,8]
Output: 2
Explanation: The largest combination [8,8] has a bitwise AND of 8 & 8 = 8 > 0.
The size of the combination is 2, so we return 2.


 

Constraints:

 * 1 <= candidates.length <= 105
 * 1 <= candidates[i] <= 107",Solutions (304),450
FALSE,0,0,2355,,Maximum Consecutive Floors Without Special Floors,maximum-consecutive-floors-without-special-floors,FALSE,25333,48587,2274,FALSE,2,"Can you solve this real interview question? Maximum Consecutive Floors Without Special Floors - Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be special floors, used for relaxation only.

You are given two integers bottom and top, which denote that Alice has rented all the floors from bottom to top (inclusive). You are also given the integer array special, where special[i] denotes a special floor that Alice has designated for relaxation.

Return the maximum number of consecutive floors without a special floor.

 

Example 1:


Input: bottom = 2, top = 9, special = [4,6]
Output: 3
Explanation: The following are the ranges (inclusive) of consecutive floors without a special floor:
- (2, 3) with a total amount of 2 floors.
- (5, 5) with a total amount of 1 floor.
- (7, 9) with a total amount of 3 floors.
Therefore, we return the maximum number which is 3 floors.


Example 2:


Input: bottom = 6, top = 8, special = [7,6,8]
Output: 0
Explanation: Every floor rented is a special floor, so we return 0.


 

Constraints:

 * 1 <= special.length <= 105
 * 1 <= bottom <= special[i] <= top <= 109
 * All the values of special are unique.",Solutions (429),315
FALSE,0,0,2353,,Maximum Score of a Node Sequence,maximum-score-of-a-node-sequence,FALSE,9517,25111,2242,FALSE,3,"Can you solve this real interview question? Maximum Score of a Node Sequence - There is an undirected graph with n nodes, numbered from 0 to n - 1.

You are given a 0-indexed integer array scores of length n where scores[i] denotes the score of node i. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.

A node sequence is valid if it meets the following conditions:

 * There is an edge connecting every pair of adjacent nodes in the sequence.
 * No node appears more than once in the sequence.

The score of a node sequence is defined as the sum of the scores of the nodes in the sequence.

Return the maximum score of a valid node sequence with a length of 4. If no such sequence exists, return -1.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png]


Input: scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
Output: 24
Explanation: The figure above shows the graph and the chosen node sequence [0,1,2,3].
The score of the node sequence is 5 + 2 + 9 + 8 = 24.
It can be shown that no other node sequence has a score of more than 24.
Note that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24.
The sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3.


Example 2:

[https://assets.leetcode.com/uploads/2022/03/17/ex2.png]


Input: scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]
Output: -1
Explanation: The figure above shows the graph.
There are no valid node sequences of length 4, so we return -1.


 

Constraints:

 * n == scores.length
 * 4 <= n <= 5 * 104
 * 1 <= scores[i] <= 108
 * 0 <= edges.length <= 5 * 104
 * edges[i].length == 2
 * 0 <= ai, bi <= n - 1
 * ai != bi
 * There are no duplicate edges.",Solutions (91),441
FALSE,0,0,2352,,Design an ATM Machine,design-an-atm-machine,FALSE,13268,34110,2241,FALSE,2,"Can you solve this real interview question? Design an ATM Machine - There is an ATM machine that stores banknotes of 5 denominations: 20, 50, 100, 200, and 500 dollars. Initially the ATM is empty. The user can use the machine to deposit or withdraw any amount of money.

When withdrawing, the machine prioritizes using banknotes of larger values.

 * For example, if you want to withdraw $300 and there are 2 $50 banknotes, 1 $100 banknote, and 1 $200 banknote, then the machine will use the $100 and $200 banknotes.
 * However, if you try to withdraw $600 and there are 3 $200 banknotes and 1 $500 banknote, then the withdraw request will be rejected because the machine will first try to use the $500 banknote and then be unable to use banknotes to complete the remaining $100. Note that the machine is not allowed to use the $200 banknotes instead of the $500 banknote.

Implement the ATM class:

 * ATM() Initializes the ATM object.
 * void deposit(int[] banknotesCount) Deposits new banknotes in the order $20, $50, $100, $200, and $500.
 * int[] withdraw(int amount) Returns an array of length 5 of the number of banknotes that will be handed to the user in the order $20, $50, $100, $200, and $500, and update the number of banknotes in the ATM after withdrawing. Returns [-1] if it is not possible (do not withdraw any banknotes in this case).

 

Example 1:


Input
[""ATM"", ""deposit"", ""withdraw"", ""deposit"", ""withdraw"", ""withdraw""]
[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]
Output
[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]

Explanation
ATM atm = new ATM();
atm.deposit([0,0,1,2,1]); // Deposits 1 $100 banknote, 2 $200 banknotes,
                          // and 1 $500 banknote.
atm.withdraw(600);        // Returns [0,0,1,0,1]. The machine uses 1 $100 banknote
                          // and 1 $500 banknote. The banknotes left over in the
                          // machine are [0,0,0,2,0].
atm.deposit([0,1,0,1,1]); // Deposits 1 $50, $200, and $500 banknote.
                          // The banknotes in the machine are now [0,1,0,3,1].
atm.withdraw(600);        // Returns [-1]. The machine will try to use a $500 banknote
                          // and then be unable to complete the remaining $100,
                          // so the withdraw request will be rejected.
                          // Since the request is rejected, the number of banknotes
                          // in the machine is not modified.
atm.withdraw(550);        // Returns [0,1,0,0,1]. The machine uses 1 $50 banknote
                          // and 1 $500 banknote.

 

Constraints:

 * banknotesCount.length == 5
 * 0 <= banknotesCount[i] <= 109
 * 1 <= amount <= 109
 * At most 5000 calls in total will be made to withdraw and deposit.
 * At least one call will be made to each function withdraw and deposit.",Solutions (245),174
FALSE,0,0,2351,,Number of Ways to Buy Pens and Pencils,number-of-ways-to-buy-pens-and-pencils,FALSE,20150,35446,2240,FALSE,2,"Can you solve this real interview question? Number of Ways to Buy Pens and Pencils - You are given an integer total indicating the amount of money you have. You are also given two integers cost1 and cost2 indicating the price of a pen and pencil respectively. You can spend part or all of your money to buy multiple quantities (or none) of each kind of writing utensil.

Return the number of distinct ways you can buy some number of pens and pencils.

 

Example 1:


Input: total = 20, cost1 = 10, cost2 = 5
Output: 9
Explanation: The price of a pen is 10 and the price of a pencil is 5.
- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.
- If you buy 1 pen, you can buy 0, 1, or 2 pencils.
- If you buy 2 pens, you cannot buy any pencils.
The total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.


Example 2:


Input: total = 5, cost1 = 10, cost2 = 10
Output: 1
Explanation: The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils.


 

Constraints:

 * 1 <= total, cost1, cost2 <= 106",Solutions (383),344
FALSE,0,0,2350,,Find Closest Number to Zero,find-closest-number-to-zero,FALSE,37720,82942,2239,FALSE,1,"Can you solve this real interview question? Find Closest Number to Zero - Given an integer array nums of size n, return the number with the value closest to 0 in nums. If there are multiple answers, return the number with the largest value.

 

Example 1:


Input: nums = [-4,-2,1,4,8]
Output: 1
Explanation:
The distance from -4 to 0 is |-4| = 4.
The distance from -2 to 0 is |-2| = 2.
The distance from 1 to 0 is |1| = 1.
The distance from 4 to 0 is |4| = 4.
The distance from 8 to 0 is |8| = 8.
Thus, the closest number to 0 in the array is 1.


Example 2:


Input: nums = [2,-1,1]
Output: 1
Explanation: 1 and -1 are both the closest numbers to 0, so 1 being larger is returned.


 

Constraints:

 * 1 <= n <= 1000
 * -105 <= nums[i] <= 105",Solutions (598),425
FALSE,0,0,2349,, Check if There Is a Valid Parentheses String Path,check-if-there-is-a-valid-parentheses-string-path,FALSE,12431,32739,2267,FALSE,3,"Can you solve this real interview question?  Check if There Is a Valid Parentheses String Path - A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:

 * It is ().
 * It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.
 * It can be written as (A), where A is a valid parentheses string.

You are given an m x n matrix of parentheses grid. A valid parentheses string path in the grid is a path satisfying all of the following conditions:

 * The path starts from the upper left cell (0, 0).
 * The path ends at the bottom-right cell (m - 1, n - 1).
 * The path only ever moves down or right.
 * The resulting parentheses string formed by the path is valid.

Return true if there exists a valid parentheses string path in the grid. Otherwise, return false.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png]


Input: grid = [[""("",""("",""(""],["")"",""("","")""],[""("",""("","")""],[""("",""("","")""]]
Output: true
Explanation: The above diagram shows two possible paths that form valid parentheses strings.
The first path shown results in the valid parentheses string ""()(())"".
The second path shown results in the valid parentheses string ""((()))"".
Note that there may be other valid parentheses string paths.


Example 2:

[https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png]


Input: grid = [["")"","")""],[""("",""(""]]
Output: false
Explanation: The two possible paths form the parentheses strings ""))("" and "")(("". Since neither of them are valid parentheses strings, we return false.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 100
 * grid[i][j] is either '(' or ')'.",Solutions (221),431
FALSE,0,0,2348,,Count Number of Texts,count-number-of-texts,FALSE,14986,31844,2266,FALSE,2,"Can you solve this real interview question? Count Number of Texts - Alice is texting Bob using her phone. The mapping of digits to letters is shown in the figure below.

[https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png]

In order to add a letter, Alice has to press the key of the corresponding digit i times, where i is the position of the letter in the key.

 * For example, to add the letter 's', Alice has to press '7' four times. Similarly, to add the letter 'k', Alice has to press '5' twice.
 * Note that the digits '0' and '1' do not map to any letters, so Alice does not use them.

However, due to an error in transmission, Bob did not receive Alice's text message but received a string of pressed keys instead.

 * For example, when Alice sent the message ""bob"", Bob received the string ""2266622"".

Given a string pressedKeys representing the string received by Bob, return the total number of possible text messages Alice could have sent.

Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:


Input: pressedKeys = ""22233""
Output: 8
Explanation:
The possible text messages Alice could have sent are:
""aaadd"", ""abdd"", ""badd"", ""cdd"", ""aaae"", ""abe"", ""bae"", and ""ce"".
Since there are 8 possible messages, we return 8.


Example 2:


Input: pressedKeys = ""222222222222222222222222222222222222""
Output: 82876089
Explanation:
There are 2082876103 possible text messages Alice could have sent.
Since we need to return the answer modulo 109 + 7, we return 2082876103 % (109 + 7) = 82876089.


 

Constraints:

 * 1 <= pressedKeys.length <= 105
 * pressedKeys only consists of digits from '2' - '9'.",Solutions (281),685
FALSE,0,0,2347,,Count Nodes Equal to Average of Subtree,count-nodes-equal-to-average-of-subtree,FALSE,37877,44471,2265,FALSE,2,"Can you solve this real interview question? Count Nodes Equal to Average of Subtree - Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.

Note:

 * The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
 * A subtree of root is a tree consisting of root and all of its descendants.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png]


Input: root = [4,8,5,0,1,null,6]
Output: 5
Explanation: 
For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.
For the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.
For the node with value 0: The average of its subtree is 0 / 1 = 0.
For the node with value 1: The average of its subtree is 1 / 1 = 1.
For the node with value 6: The average of its subtree is 6 / 1 = 6.


Example 2:

[https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png]


Input: root = [1]
Output: 1
Explanation: For the node with value 1: The average of its subtree is 1 / 1 = 1.


 

Constraints:

 * The number of nodes in the tree is in the range [1, 1000].
 * 0 <= Node.val <= 1000",Solutions (978),1.1K
FALSE,0,0,2346,,Largest 3-Same-Digit Number in String,largest-3-same-digit-number-in-string,FALSE,30903,51914,2264,FALSE,1,"Can you solve this real interview question? Largest 3-Same-Digit Number in String - You are given a string num representing a large integer. An integer is good if it meets the following conditions:

 * It is a substring of num with length 3.
 * It consists of only one unique digit.

Return the maximum good integer as a string or an empty string """" if no such integer exists.

Note:

 * A substring is a contiguous sequence of characters within a string.
 * There may be leading zeroes in num or a good integer.

 

Example 1:


Input: num = ""6777133339""
Output: ""777""
Explanation: There are two distinct good integers: ""777"" and ""333"".
""777"" is the largest, so we return ""777"".


Example 2:


Input: num = ""2300019""
Output: ""000""
Explanation: ""000"" is the only good integer.


Example 3:


Input: num = ""42352338""
Output: """"
Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.


 

Constraints:

 * 3 <= num.length <= 1000
 * num only consists of digits.",Solutions (605),292
FALSE,0,0,2345,,Minimum Number of Operations to Convert Time,minimum-number-of-operations-to-convert-time,FALSE,31607,48353,2224,FALSE,1,"Can you solve this real interview question? Minimum Number of Operations to Convert Time - You are given two strings current and correct representing two 24-hour times.

24-hour times are formatted as ""HH:MM"", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.

In one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times.

Return the minimum number of operations needed to convert current to correct.

 

Example 1:


Input: current = ""02:30"", correct = ""04:35""
Output: 3
Explanation:
We can convert current to correct in 3 operations as follows:
- Add 60 minutes to current. current becomes ""03:30"".
- Add 60 minutes to current. current becomes ""04:30"".
- Add 5 minutes to current. current becomes ""04:35"".
It can be proven that it is not possible to convert current to correct in fewer than 3 operations.

Example 2:


Input: current = ""11:00"", correct = ""11:01""
Output: 1
Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1.


 

Constraints:

 * current and correct are in the format ""HH:MM""
 * current <= correct",Solutions (597),356
FALSE,0,0,2344,,Escape the Spreading Fire,escape-the-spreading-fire,FALSE,6803,19402,2258,FALSE,3,"Can you solve this real interview question? Escape the Spreading Fire - You are given a 0-indexed 2D integer array grid of size m x n which represents a field. Each cell has one of three values:

 * 0 represents grass,
 * 1 represents fire,
 * 2 represents a wall that you and fire cannot pass through.

You are situated in the top-left cell, (0, 0), and you want to travel to the safehouse at the bottom-right cell, (m - 1, n - 1). Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.

Return the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse. If this is impossible, return -1. If you can always reach the safehouse regardless of the minutes stayed, return 109.

Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.

A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg]


Input: grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
Output: 3
Explanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.
You will still be able to safely reach the safehouse.
Staying for more than 3 minutes will not allow you to safely reach the safehouse.

Example 2:

[https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg]


Input: grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
Output: -1
Explanation: The figure above shows the scenario where you immediately move towards the safehouse.
Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.
Thus, -1 is returned.


Example 3:

[https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg]


Input: grid = [[0,0,0],[2,2,0],[1,2,0]]
Output: 1000000000
Explanation: The figure above shows the initial grid.
Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.
Thus, 109 is returned.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 2 <= m, n <= 300
 * 4 <= m * n <= 2 * 104
 * grid[i][j] is either 0, 1, or 2.
 * grid[0][0] == grid[m - 1][n - 1] == 0",Solutions (150),513
FALSE,0,0,2343,,Count Unguarded Cells in the Grid,count-unguarded-cells-in-the-grid,FALSE,13245,25387,2257,FALSE,2,"Can you solve this real interview question? Count Unguarded Cells in the Grid - You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.

A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.

Return the number of unoccupied cells that are not guarded.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png]


Input: m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]
Output: 7
Explanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.
There are a total of 7 unguarded cells, so we return 7.


Example 2:

[https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png]


Input: m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]
Output: 4
Explanation: The unguarded cells are shown in green in the above diagram.
There are a total of 4 unguarded cells, so we return 4.


 

Constraints:

 * 1 <= m, n <= 105
 * 2 <= m * n <= 105
 * 1 <= guards.length, walls.length <= 5 * 104
 * 2 <= guards.length + walls.length <= m * n
 * guards[i].length == walls[j].length == 2
 * 0 <= rowi, rowj < m
 * 0 <= coli, colj < n
 * All the positions in guards and walls are unique.",Solutions (325),345
FALSE,0,0,2342,minimum-average-difference,Minimum Average Difference,minimum-average-difference,FALSE,74772,173472,2256,FALSE,2,"Can you solve this real interview question? Minimum Average Difference - You are given a 0-indexed integer array nums of length n.

The average difference of the index i is the absolute difference between the average of the first i + 1 elements of nums and the average of the last n - i - 1 elements. Both averages should be rounded down to the nearest integer.

Return the index with the minimum average difference. If there are multiple such indices, return the smallest one.

Note:

 * The absolute difference of two numbers is the absolute value of their difference.
 * The average of n elements is the sum of the n elements divided (integer division) by n.
 * The average of 0 elements is considered to be 0.

 

Example 1:


Input: nums = [2,5,3,9,5,3]
Output: 3
Explanation:
- The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.
- The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.
- The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.
- The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.
- The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.
- The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.
The average difference of index 3 is the minimum average difference so return 3.


Example 2:


Input: nums = [0]
Output: 0
Explanation:
The only index is 0 so return 0.
The average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0.


 

Constraints:

 * 1 <= nums.length <= 105
 * 0 <= nums[i] <= 105",Solutions (1.4K),1.4K
FALSE,0,0,2341,,Count Prefixes of a Given String,count-prefixes-of-a-given-string,FALSE,38928,53382,2255,FALSE,1,"Can you solve this real interview question? Count Prefixes of a Given String - You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.

Return the number of strings in words that are a prefix of s.

A prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.

 

Example 1:


Input: words = [""a"",""b"",""c"",""ab"",""bc"",""abc""], s = ""abc""
Output: 3
Explanation:
The strings in words which are a prefix of s = ""abc"" are:
""a"", ""ab"", and ""abc"".
Thus the number of strings in words which are a prefix of s is 3.

Example 2:


Input: words = [""a"",""a""], s = ""aa""
Output: 2
Explanation:
Both of the strings are a prefix of s. 
Note that the same string can occur multiple times in words, and it should be counted each time.

 

Constraints:

 * 1 <= words.length <= 1000
 * 1 <= words[i].length, s.length <= 10
 * words[i] and s consist of lowercase English letters only.",Solutions (831),399
FALSE,0,0,2340,,Total Appeal of A String,total-appeal-of-a-string,FALSE,22583,39796,2262,FALSE,3,"Can you solve this real interview question? Total Appeal of A String - The appeal of a string is the number of distinct characters found in the string.

 * For example, the appeal of ""abbca"" is 3 because it has 3 distinct characters: 'a', 'b', and 'c'.

Given a string s, return the total appeal of all of its substrings.

A substring is a contiguous sequence of characters within a string.

 

Example 1:


Input: s = ""abbca""
Output: 28
Explanation: The following are the substrings of ""abbca"":
- Substrings of length 1: ""a"", ""b"", ""b"", ""c"", ""a"" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5.
- Substrings of length 2: ""ab"", ""bb"", ""bc"", ""ca"" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7.
- Substrings of length 3: ""abb"", ""bbc"", ""bca"" have an appeal of 2, 2, and 3 respectively. The sum is 7.
- Substrings of length 4: ""abbc"", ""bbca"" have an appeal of 3 and 3 respectively. The sum is 6.
- Substrings of length 5: ""abbca"" has an appeal of 3. The sum is 3.
The total sum is 5 + 7 + 7 + 6 + 3 = 28.


Example 2:


Input: s = ""code""
Output: 20
Explanation: The following are the substrings of ""code"":
- Substrings of length 1: ""c"", ""o"", ""d"", ""e"" have an appeal of 1, 1, 1, and 1 respectively. The sum is 4.
- Substrings of length 2: ""co"", ""od"", ""de"" have an appeal of 2, 2, and 2 respectively. The sum is 6.
- Substrings of length 3: ""cod"", ""ode"" have an appeal of 3 and 3 respectively. The sum is 6.
- Substrings of length 4: ""code"" has an appeal of 4. The sum is 4.
The total sum is 4 + 6 + 6 + 4 = 20.


 

Constraints:

 * 1 <= s.length <= 105
 * s consists of lowercase English letters.",Solutions (310),825
FALSE,0,0,2339,,K Divisible Elements Subarrays,k-divisible-elements-subarrays,FALSE,20582,42797,2261,FALSE,2,"Can you solve this real interview question? K Divisible Elements Subarrays - Given an integer array nums and two integers k and p, return the number of distinct subarrays which have at most k elements divisible by p.

Two arrays nums1 and nums2 are said to be distinct if:

 * They are of different lengths, or
 * There exists at least one index i where nums1[i] != nums2[i].

A subarray is defined as a non-empty contiguous sequence of elements in an array.

 

Example 1:


Input: nums = [2,3,3,2,2], k = 2, p = 2
Output: 11
Explanation:
The elements at indices 0, 3, and 4 are divisible by p = 2.
The 11 distinct subarrays which have at most k = 2 elements divisible by 2 are:
[2], [2,3], [2,3,3], [2,3,3,2], [3], [3,3], [3,3,2], [3,3,2,2], [3,2], [3,2,2], and [2,2].
Note that the subarrays [2] and [3] occur more than once in nums, but they should each be counted only once.
The subarray [2,3,3,2,2] should not be counted because it has 3 elements that are divisible by 2.


Example 2:


Input: nums = [1,2,3,4], k = 4, p = 1
Output: 10
Explanation:
All element of nums are divisible by p = 1.
Also, every subarray of nums will have at most 4 elements that are divisible by 1.
Since all subarrays are distinct, the total number of subarrays satisfying all the constraints is 10.


 

Constraints:

 * 1 <= nums.length <= 200
 * 1 <= nums[i], p <= 200
 * 1 <= k <= nums.length

 

Follow up:

Can you solve this problem in O(n2) time complexity?",Solutions (285),465
FALSE,0,0,2338,,Minimum Consecutive Cards to Pick Up,minimum-consecutive-cards-to-pick-up,FALSE,40345,78823,2260,FALSE,2,"Can you solve this real interview question? Minimum Consecutive Cards to Pick Up - You are given an integer array cards where cards[i] represents the value of the ith card. A pair of cards are matching if the cards have the same value.

Return the minimum number of consecutive cards you have to pick up to have a pair of matching cards among the picked cards. If it is impossible to have matching cards, return -1.

 

Example 1:


Input: cards = [3,4,2,3,4,7]
Output: 4
Explanation: We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal.


Example 2:


Input: cards = [1,0,5,3]
Output: -1
Explanation: There is no way to pick up a set of consecutive cards that contain a pair of matching cards.


 

Constraints:

 * 1 <= cards.length <= 105
 * 0 <= cards[i] <= 106",Solutions (693),647
FALSE,0,0,2337,,Remove Digit From Number to Maximize Result,remove-digit-from-number-to-maximize-result,FALSE,48681,105253,2259,FALSE,1,"Can you solve this real interview question? Remove Digit From Number to Maximize Result - You are given a string number representing a positive integer and a character digit.

Return the resulting string after removing exactly one occurrence of digit from number such that the value of the resulting string in decimal form is maximized. The test cases are generated such that digit occurs at least once in number.

 

Example 1:


Input: number = ""123"", digit = ""3""
Output: ""12""
Explanation: There is only one '3' in ""123"". After removing '3', the result is ""12"".


Example 2:


Input: number = ""1231"", digit = ""1""
Output: ""231""
Explanation: We can remove the first '1' to get ""231"" or remove the second '1' to get ""123"".
Since 231 > 123, we return ""231"".


Example 3:


Input: number = ""551"", digit = ""5""
Output: ""51""
Explanation: We can remove either the first or second '5' from ""551"".
Both result in the string ""51"".


 

Constraints:

 * 2 <= number.length <= 100
 * number consists of digits from '1' to '9'.
 * digit is a digit from '1' to '9'.
 * digit occurs at least once in number.",Solutions (652),579
FALSE,0,0,2334,,Number of Flowers in Full Bloom,number-of-flowers-in-full-bloom,FALSE,12619,24654,2251,FALSE,3,"Can you solve this real interview question? Number of Flowers in Full Bloom - You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). You are also given a 0-indexed integer array people of size n, where poeple[i] is the time that the ith person will arrive to see the flowers.

Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg]


Input: flowers = [[1,6],[3,7],[9,12],[4,13]], poeple = [2,3,7,11]
Output: [1,2,2,2]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.


Example 2:

[https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg]


Input: flowers = [[1,10],[3,3]], poeple = [3,3,2]
Output: [2,2,1]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.


 

Constraints:

 * 1 <= flowers.length <= 5 * 104
 * flowers[i].length == 2
 * 1 <= starti <= endi <= 109
 * 1 <= people.length <= 5 * 104
 * 1 <= people[i] <= 109",Solutions (253),499
FALSE,0,0,2333,,Count Number of Rectangles Containing Each Point,count-number-of-rectangles-containing-each-point,FALSE,11881,34817,2250,FALSE,2,"Can you solve this real interview question? Count Number of Rectangles Containing Each Point - You are given a 2D integer array rectangles where rectangles[i] = [li, hi] indicates that ith rectangle has a length of li and a height of hi. You are also given a 2D integer array points where points[j] = [xj, yj] is a point with coordinates (xj, yj).

The ith rectangle has its bottom-left corner point at the coordinates (0, 0) and its top-right corner point at (li, hi).

Return an integer array count of length points.length where count[j] is the number of rectangles that contain the jth point.

The ith rectangle contains the jth point if 0 <= xj <= li and 0 <= yj <= hi. Note that points that lie on the edges of a rectangle are also considered to be contained by that rectangle.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/02/example1.png]


Input: rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]
Output: [2,1]
Explanation: 
The first rectangle contains no points.
The second rectangle contains only the point (2, 1).
The third rectangle contains the points (2, 1) and (1, 4).
The number of rectangles that contain the point (2, 1) is 2.
The number of rectangles that contain the point (1, 4) is 1.
Therefore, we return [2, 1].


Example 2:

[https://assets.leetcode.com/uploads/2022/03/02/example2.png]


Input: rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]
Output: [1,3]
Explanation:
The first rectangle contains only the point (1, 1).
The second rectangle contains only the point (1, 1).
The third rectangle contains the points (1, 3) and (1, 1).
The number of rectangles that contain the point (1, 3) is 1.
The number of rectangles that contain the point (1, 1) is 3.
Therefore, we return [1, 3].


 

Constraints:

 * 1 <= rectangles.length, points.length <= 5 * 104
 * rectangles[i].length == points[j].length == 2
 * 1 <= li, xj <= 109
 * 1 <= hi, yj <= 100
 * All the rectangles are unique.
 * All the points are unique.",Solutions (180),407
FALSE,0,0,2332,,Count Lattice Points Inside a Circle,count-lattice-points-inside-a-circle,FALSE,18288,36151,2249,FALSE,2,"Can you solve this real interview question? Count Lattice Points Inside a Circle - Given a 2D integer array circles where circles[i] = [xi, yi, ri] represents the center (xi, yi) and radius ri of the ith circle drawn on a grid, return the number of lattice points that are present inside at least one circle.

Note:

 * A lattice point is a point with integer coordinates.
 * Points that lie on the circumference of a circle are also considered to be inside it.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/03/02/exa-11.png]


Input: circles = [[2,2,1]]
Output: 5
Explanation:
The figure above shows the given circle.
The lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.
Other points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.
Hence, the number of lattice points present inside at least one circle is 5.

Example 2:

[https://assets.leetcode.com/uploads/2022/03/02/exa-22.png]


Input: circles = [[2,2,2],[3,4,1]]
Output: 16
Explanation:
The figure above shows the given circles.
There are exactly 16 lattice points which are present inside at least one circle. 
Some of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).


 

Constraints:

 * 1 <= circles.length <= 200
 * circles[i].length == 3
 * 1 <= xi, yi <= 100
 * 1 <= ri <= min(xi, yi)",Solutions (240),179
FALSE,0,0,2331,,Intersection of Multiple Arrays,intersection-of-multiple-arrays,FALSE,46880,68260,2248,FALSE,1,"Can you solve this real interview question? Intersection of Multiple Arrays - Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.

 

Example 1:


Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
Output: [3,4]
Explanation: 
The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].

Example 2:


Input: nums = [[1,2,3],[4,5,6]]
Output: []
Explanation: 
There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= sum(nums[i].length) <= 1000
 * 1 <= nums[i][j] <= 1000
 * All the values of nums[i] are unique.",Solutions (821),483
FALSE,0,0,2330,,Maximum Total Beauty of the Gardens,maximum-total-beauty-of-the-gardens,FALSE,5322,18681,2234,FALSE,3,"Can you solve this real interview question? Maximum Total Beauty of the Gardens - Alice is a caretaker of n gardens and she wants to plant flowers to maximize the total beauty of all her gardens.

You are given a 0-indexed integer array flowers of size n, where flowers[i] is the number of flowers already planted in the ith garden. Flowers that are already planted cannot be removed. You are then given another integer newFlowers, which is the maximum number of flowers that Alice can additionally plant. You are also given the integers target, full, and partial.

A garden is considered complete if it has at least target flowers. The total beauty of the gardens is then determined as the sum of the following:

 * The number of complete gardens multiplied by full.
 * The minimum number of flowers in any of the incomplete gardens multiplied by partial. If there are no incomplete gardens, then this value will be 0.

Return the maximum total beauty that Alice can obtain after planting at most newFlowers flowers.

 

Example 1:


Input: flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1
Output: 14
Explanation: Alice can plant
- 2 flowers in the 0th garden
- 3 flowers in the 1st garden
- 1 flower in the 2nd garden
- 1 flower in the 3rd garden
The gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.
There is 1 garden that is complete.
The minimum number of flowers in the incomplete gardens is 2.
Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14.
No other way of planting flowers can obtain a total beauty higher than 14.


Example 2:


Input: flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6
Output: 30
Explanation: Alice can plant
- 3 flowers in the 0th garden
- 0 flowers in the 1st garden
- 0 flowers in the 2nd garden
- 2 flowers in the 3rd garden
The gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.
There are 3 gardens that are complete.
The minimum number of flowers in the incomplete gardens is 4.
Thus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30.
No other way of planting flowers can obtain a total beauty higher than 30.
Note that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.


 

Constraints:

 * 1 <= flowers.length <= 105
 * 1 <= flowers[i], target <= 105
 * 1 <= newFlowers <= 1010
 * 1 <= full, partial <= 105",Solutions (83),353
FALSE,0,0,2329,,Maximum Product After K Increments,maximum-product-after-k-increments,FALSE,22710,55230,2233,FALSE,2,"Can you solve this real interview question? Maximum Product After K Increments - You are given an array of non-negative integers nums and an integer k. In one operation, you may choose any element from nums and increment it by 1.

Return the maximum product of nums after at most k operations. Since the answer may be very large, return it modulo 109 + 7. Note that you should maximize the product before taking the modulo. 

 

Example 1:


Input: nums = [0,4], k = 5
Output: 20
Explanation: Increment the first number 5 times.
Now nums = [5, 4], with a product of 5 * 4 = 20.
It can be shown that 20 is maximum product possible, so we return 20.
Note that there may be other ways to increment nums to have the maximum product.


Example 2:


Input: nums = [6,3,3,2], k = 2
Output: 216
Explanation: Increment the second number 1 time and increment the fourth number 1 time.
Now nums = [6, 4, 3, 3], with a product of 6 * 4 * 3 * 3 = 216.
It can be shown that 216 is maximum product possible, so we return 216.
Note that there may be other ways to increment nums to have the maximum product.


 

Constraints:

 * 1 <= nums.length, k <= 105
 * 0 <= nums[i] <= 106",Solutions (439),534
FALSE,0,0,2328,,Minimize Result by Adding Parentheses to Expression,minimize-result-by-adding-parentheses-to-expression,FALSE,15165,23154,2232,FALSE,2,"Can you solve this real interview question? Minimize Result by Adding Parentheses to Expression - You are given a 0-indexed string expression of the form ""<num1>+<num2>"" where <num1> and <num2> represent positive integers.

Add a pair of parentheses to expression such that after the addition of parentheses, expression is a valid mathematical expression and evaluates to the smallest possible value. The left parenthesis must be added to the left of '+' and the right parenthesis must be added to the right of '+'.

Return expression after adding a pair of parentheses such that expression evaluates to the smallest possible value. If there are multiple answers that yield the same result, return any of them.

The input has been generated such that the original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.

 

Example 1:


Input: expression = ""247+38""
Output: ""2(47+38)""
Explanation: The expression evaluates to 2 * (47 + 38) = 2 * 85 = 170.
Note that ""2(4)7+38"" is invalid because the right parenthesis must be to the right of the '+'.
It can be shown that 170 is the smallest possible value.


Example 2:


Input: expression = ""12+34""
Output: ""1(2+3)4""
Explanation: The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20.


Example 3:


Input: expression = ""999+999""
Output: ""(999+999)""
Explanation: The expression evaluates to 999 + 999 = 1998.


 

Constraints:

 * 3 <= expression.length <= 10
 * expression consists of digits from '1' to '9' and '+'.
 * expression starts and ends with digits.
 * expression contains exactly one '+'.
 * The original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.",Solutions (311),160
FALSE,0,0,2327,,Largest Number After Digit Swaps by Parity,largest-number-after-digit-swaps-by-parity,FALSE,30755,50366,2231,FALSE,1,"Can you solve this real interview question? Largest Number After Digit Swaps by Parity - You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).

Return the largest possible value of num after any number of swaps.

 

Example 1:


Input: num = 1234
Output: 3412
Explanation: Swap the digit 3 with the digit 1, this results in the number 3214.
Swap the digit 2 with the digit 4, this results in the number 3412.
Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.
Also note that we may not swap the digit 4 with the digit 1 since they are of different parities.


Example 2:


Input: num = 65875
Output: 87655
Explanation: Swap the digit 8 with the digit 6, this results in the number 85675.
Swap the first digit 5 with the digit 7, this results in the number 87655.
Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.


 

Constraints:

 * 1 <= num <= 109",Solutions (581),429
FALSE,0,0,2326,,Sum of Scores of Built Strings,sum-of-scores-of-built-strings,FALSE,5201,13938,2223,FALSE,3,"Can you solve this real interview question? Sum of Scores of Built Strings - You are building a string s of length n one character at a time, prepending each new character to the front of the string. The strings are labeled from 1 to n, where the string with length i is labeled si.

 * For example, for s = ""abaca"", s1 == ""a"", s2 == ""ca"", s3 == ""aca"", etc.

The score of si is the length of the longest common prefix between si and sn (Note that s == sn).

Given the final string s, return the sum of the score of every si.

 

Example 1:


Input: s = ""babab""
Output: 9
Explanation:
For s1 == ""b"", the longest common prefix is ""b"" which has a score of 1.
For s2 == ""ab"", there is no common prefix so the score is 0.
For s3 == ""bab"", the longest common prefix is ""bab"" which has a score of 3.
For s4 == ""abab"", there is no common prefix so the score is 0.
For s5 == ""babab"", the longest common prefix is ""babab"" which has a score of 5.
The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9.

Example 2:


Input: s = ""azbazbzaz""
Output: 14
Explanation: 
For s2 == ""az"", the longest common prefix is ""az"" which has a score of 2.
For s6 == ""azbzaz"", the longest common prefix is ""azb"" which has a score of 3.
For s9 == ""azbazbzaz"", the longest common prefix is ""azbazbzaz"" which has a score of 9.
For all other si, the score is 0.
The sum of the scores is 2 + 3 + 9 = 14, so we return 14.


 

Constraints:

 * 1 <= s.length <= 105
 * s consists of lowercase English letters.",Solutions (66),187
FALSE,0,0,2325,,Number of Ways to Select Buildings,number-of-ways-to-select-buildings,FALSE,25803,50294,2222,FALSE,2,"Can you solve this real interview question? Number of Ways to Select Buildings - You are given a 0-indexed binary string s which represents the types of buildings along a street where:

 * s[i] = '0' denotes that the ith building is an office and
 * s[i] = '1' denotes that the ith building is a restaurant.

As a city official, you would like to select 3 buildings for random inspection. However, to ensure variety, no two consecutive buildings out of the selected buildings can be of the same type.

 * For example, given s = ""001101"", we cannot select the 1st, 3rd, and 5th buildings as that would form ""011"" which is not allowed due to having two consecutive buildings of the same type.

Return the number of valid ways to select 3 buildings.

 

Example 1:


Input: s = ""001101""
Output: 6
Explanation: 
The following sets of indices selected are valid:
- [0,2,4] from ""001101"" forms ""010""
- [0,3,4] from ""001101"" forms ""010""
- [1,2,4] from ""001101"" forms ""010""
- [1,3,4] from ""001101"" forms ""010""
- [2,4,5] from ""001101"" forms ""101""
- [3,4,5] from ""001101"" forms ""101""
No other selection is valid. Thus, there are 6 total ways.


Example 2:


Input: s = ""11100""
Output: 0
Explanation: It can be shown that there are no valid selections.


 

Constraints:

 * 3 <= s.length <= 105
 * s[i] is either '0' or '1'.",Solutions (453),782
FALSE,0,0,2324,,Find Triangular Sum of an Array,find-triangular-sum-of-an-array,FALSE,52730,67122,2221,FALSE,2,"Can you solve this real interview question? Find Triangular Sum of an Array - You are given a 0-indexed integer array nums, where nums[i] is a digit between 0 and 9 (inclusive).

The triangular sum of nums is the value of the only element present in nums after the following process terminates:

 1. Let nums comprise of n elements. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n - 1.
 2. For each index i, where 0 <= i < n - 1, assign the value of newNums[i] as (nums[i] + nums[i+1]) % 10, where % denotes modulo operator.
 3. Replace the array nums with newNums.
 4. Repeat the entire process starting from step 1.

Return the triangular sum of nums.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/02/22/ex1drawio.png]


Input: nums = [1,2,3,4,5]
Output: 8
Explanation:
The above diagram depicts the process from which we obtain the triangular sum of the array.

Example 2:


Input: nums = [5]
Output: 5
Explanation:
Since there is only one element in nums, the triangular sum is the value of that element itself.

 

Constraints:

 * 1 <= nums.length <= 1000
 * 0 <= nums[i] <= 9",Solutions (979),803
FALSE,0,0,2323,,Minimum Bit Flips to Convert Number,minimum-bit-flips-to-convert-number,FALSE,36947,44898,2220,FALSE,1,"Can you solve this real interview question? Minimum Bit Flips to Convert Number - A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.

 * For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.

Given two integers start and goal, return the minimum number of bit flips to convert start to goal.

 

Example 1:


Input: start = 10, goal = 7
Output: 3
Explanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:
- Flip the first bit from the right: 1010 -> 1011.
- Flip the third bit from the right: 1011 -> 1111.
- Flip the fourth bit from the right: 1111 -> 0111.
It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.

Example 2:


Input: start = 3, goal = 4
Output: 3
Explanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:
- Flip the first bit from the right: 011 -> 010.
- Flip the second bit from the right: 010 -> 000.
- Flip the third bit from the right: 000 -> 100.
It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.


 

Constraints:

 * 0 <= start, goal <= 109",Solutions (775),478
FALSE,0,0,2321,,Minimum Weighted Subgraph With the Required Paths,minimum-weighted-subgraph-with-the-required-paths,FALSE,9026,25068,2203,FALSE,3,"Can you solve this real interview question? Minimum Weighted Subgraph With the Required Paths - You are given an integer n denoting the number of nodes of a weighted directed graph. The nodes are numbered from 0 to n - 1.

You are also given a 2D integer array edges where edges[i] = [fromi, toi, weighti] denotes that there exists a directed edge from fromi to toi with weight weighti.

Lastly, you are given three distinct integers src1, src2, and dest denoting three distinct nodes of the graph.

Return the minimum weight of a subgraph of the graph such that it is possible to reach dest from both src1 and src2 via a set of edges of this subgraph. In case such a subgraph does not exist, return -1.

A subgraph is a graph whose vertices and edges are subsets of the original graph. The weight of a subgraph is the sum of weights of its constituent edges.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png]


Input: n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5
Output: 9
Explanation:
The above figure represents the input graph.
The blue edges represent one of the subgraphs that yield the optimal answer.
Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.


Example 2:

[https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png]


Input: n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2
Output: -1
Explanation:
The above figure represents the input graph.
It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.


 

Constraints:

 * 3 <= n <= 105
 * 0 <= edges.length <= 105
 * edges[i].length == 3
 * 0 <= fromi, toi, src1, src2, dest <= n - 1
 * fromi != toi
 * src1, src2, and dest are pairwise distinct.
 * 1 <= weight[i] <= 105",Solutions (131),551
FALSE,0,0,2320,,Find All K-Distant Indices in an Array,find-all-k-distant-indices-in-an-array,FALSE,31053,47762,2200,FALSE,1,"Can you solve this real interview question? Find All K-Distant Indices in an Array - You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key.

Return a list of all k-distant indices sorted in increasing order.

 

Example 1:


Input: nums = [3,4,9,1,3,9,5], key = 9, k = 1
Output: [1,2,3,4,5,6]
Explanation: Here, nums[2] == key and nums[5] == key.
- For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j where |0 - j| <= k and nums[j] == key. Thus, 0 is not a k-distant index.
- For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index.
- For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index.
- For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index.
- For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index.
- For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index.
- For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index.
Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. 


Example 2:


Input: nums = [2,2,2,2,2], key = 2, k = 2
Output: [0,1,2,3,4]
Explanation: For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. 
Hence, we return [0,1,2,3,4].


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i] <= 1000
 * key is an integer from the array nums.
 * 1 <= k <= nums.length",Solutions (425),325
FALSE,0,0,2319,,Longest Substring of One Repeating Character,longest-substring-of-one-repeating-character,FALSE,3427,11094,2213,FALSE,3,"Can you solve this real interview question? Longest Substring of One Repeating Character - You are given a 0-indexed string s. You are also given a 0-indexed string queryCharacters of length k and a 0-indexed array of integer indices queryIndices of length k, both of which are used to describe k queries.

The ith query updates the character in s at index queryIndices[i] to the character queryCharacters[i].

Return an array lengths of length k where lengths[i] is the length of the longest substring of s consisting of only one repeating character after the ith query is performed.

 

Example 1:


Input: s = ""babacc"", queryCharacters = ""bcb"", queryIndices = [1,3,3]
Output: [3,3,4]
Explanation: 
- 1st query updates s = ""bbbacc"". The longest substring consisting of one repeating character is ""bbb"" with length 3.
- 2nd query updates s = ""bbbccc"". 
  The longest substring consisting of one repeating character can be ""bbb"" or ""ccc"" with length 3.
- 3rd query updates s = ""bbbbcc"". The longest substring consisting of one repeating character is ""bbbb"" with length 4.
Thus, we return [3,3,4].


Example 2:


Input: s = ""abyzz"", queryCharacters = ""aa"", queryIndices = [2,1]
Output: [2,3]
Explanation:
- 1st query updates s = ""abazz"". The longest substring consisting of one repeating character is ""zz"" with length 2.
- 2nd query updates s = ""aaazz"". The longest substring consisting of one repeating character is ""aaa"" with length 3.
Thus, we return [2,3].


 

Constraints:

 * 1 <= s.length <= 105
 * s consists of lowercase English letters.
 * k == queryCharacters.length == queryIndices.length
 * 1 <= k <= 105
 * queryCharacters consists of lowercase English letters.
 * 0 <= queryIndices[i] < s.length",Solutions (86),234
FALSE,0,0,2318,,Maximum Points in an Archery Competition,maximum-points-in-an-archery-competition,FALSE,12472,25206,2212,FALSE,2,"Can you solve this real interview question? Maximum Points in an Archery Competition - Alice and Bob are opponents in an archery competition. The competition has set the following rules:

 1. Alice first shoots numArrows arrows and then Bob shoots numArrows arrows.
 2. The points are then calculated as follows:
    1. The target has integer scoring sections ranging from 0 to 11 inclusive.
    2. For each section of the target with score k (in between 0 to 11), say Alice and Bob have shot ak and bk arrows on that section respectively. If ak >= bk, then Alice takes k points. If ak < bk, then Bob takes k points.
    3. However, if ak == bk == 0, then nobody takes k points.

 * For example, if Alice and Bob both shot 2 arrows on the section with score 11, then Alice takes 11 points. On the other hand, if Alice shot 0 arrows on the section with score 11 and Bob shot 2 arrows on that same section, then Bob takes 11 points.

You are given the integer numArrows and an integer array aliceArrows of size 12, which represents the number of arrows Alice shot on each scoring section from 0 to 11. Now, Bob wants to maximize the total number of points he can obtain.

Return the array bobArrows which represents the number of arrows Bob shot on each scoring section from 0 to 11. The sum of the values in bobArrows should equal numArrows.

If there are multiple ways for Bob to earn the maximum total points, return any one of them.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/02/24/ex1.jpg]


Input: numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]
Output: [0,0,0,0,1,1,0,0,1,2,3,1]
Explanation: The table above shows how the competition is scored. 
Bob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.
It can be shown that Bob cannot obtain a score higher than 47 points.


Example 2:

[https://assets.leetcode.com/uploads/2022/02/24/ex2new.jpg]


Input: numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]
Output: [0,0,0,0,0,0,0,0,1,1,1,0]
Explanation: The table above shows how the competition is scored.
Bob earns a total point of 8 + 9 + 10 = 27.
It can be shown that Bob cannot obtain a score higher than 27 points.


 

Constraints:

 * 1 <= numArrows <= 105
 * aliceArrows.length == bobArrows.length == 12
 * 0 <= aliceArrows[i], bobArrows[i] <= numArrows
 * sum(aliceArrows[i]) == numArrows",Solutions (280),418
FALSE,0,0,2317,,Count Collisions on a Road,count-collisions-on-a-road,FALSE,19401,45829,2211,FALSE,2,"Can you solve this real interview question? Count Collisions on a Road - There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.

You are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the ith car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.

The number of collisions can be calculated as follows:

 * When two cars moving in opposite directions collide with each other, the number of collisions increases by 2.
 * When a moving car collides with a stationary car, the number of collisions increases by 1.

After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.

Return the total number of collisions that will happen on the road.

 

Example 1:


Input: directions = ""RLRSLL""
Output: 5
Explanation:
The collisions that will happen on the road are:
- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.
- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.
- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.
- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.
Thus, the total number of collisions that will happen on the road is 5. 


Example 2:


Input: directions = ""LLRR""
Output: 0
Explanation:
No cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.

 

Constraints:

 * 1 <= directions.length <= 105
 * directions[i] is either 'L', 'R', or 'S'.",Solutions (427),460
FALSE,0,0,2316,,Count Hills and Valleys in an Array,count-hills-and-valleys-in-an-array,FALSE,30579,52409,2210,FALSE,1,"Can you solve this real interview question? Count Hills and Valleys in an Array - You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].

Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.

Return the number of hills and valleys in nums.

 

Example 1:


Input: nums = [2,4,1,1,6,5]
Output: 3
Explanation:
At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.
At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. 
At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.
At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.
At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.
At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. 
There are 3 hills and valleys so we return 3.


Example 2:


Input: nums = [6,6,5,5,4,1]
Output: 0
Explanation:
At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.
At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.
At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.
At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.
At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.
At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.
There are 0 hills and valleys so we return 0.


 

Constraints:

 * 3 <= nums.length <= 100
 * 1 <= nums[i] <= 100",Solutions (486),475
FALSE,0,0,2312,,Most Frequent Number Following Key In an Array,most-frequent-number-following-key-in-an-array,FALSE,26264,43768,2190,FALSE,1,"Can you solve this real interview question? Most Frequent Number Following Key In an Array - You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums.

For every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that:

 * 0 <= i <= nums.length - 2,
 * nums[i] == key and,
 * nums[i + 1] == target.

Return the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.

 

Example 1:


Input: nums = [1,100,200,1,100], key = 1
Output: 100
Explanation: For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.
No other integers follow an occurrence of key, so we return 100.


Example 2:


Input: nums = [2,2,2,2,3], key = 2
Output: 2
Explanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.
For target = 3, there is only one occurrence at index 4 which follows an occurrence of key.
target = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.


 

Constraints:

 * 2 <= nums.length <= 1000
 * 1 <= nums[i] <= 1000
 * The test cases will be generated such that the answer is unique.",Solutions (461),285
FALSE,0,0,2311,,Minimum White Tiles After Covering With Carpets,minimum-white-tiles-after-covering-with-carpets,FALSE,9641,28193,2209,FALSE,3,"Can you solve this real interview question? Minimum White Tiles After Covering With Carpets - You are given a 0-indexed binary string floor, which represents the colors of tiles on a floor:

 * floor[i] = '0' denotes that the ith tile of the floor is colored black.
 * On the other hand, floor[i] = '1' denotes that the ith tile of the floor is colored white.

You are also given numCarpets and carpetLen. You have numCarpets black carpets, each of length carpetLen tiles. Cover the tiles with the given carpets such that the number of white tiles still visible is minimum. Carpets may overlap one another.

Return the minimum number of white tiles still visible.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png]


Input: floor = ""10110101"", numCarpets = 2, carpetLen = 2
Output: 2
Explanation: 
The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.
No other way of covering the tiles with the carpets can leave less than 2 white tiles visible.


Example 2:

[https://assets.leetcode.com/uploads/2022/02/10/ex2.png]


Input: floor = ""11111"", numCarpets = 2, carpetLen = 3
Output: 0
Explanation: 
The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.
Note that the carpets are able to overlap one another.


 

Constraints:

 * 1 <= carpetLen <= floor.length <= 1000
 * floor[i] is either '0' or '1'.
 * 1 <= numCarpets <= 1000",Solutions (174),425
FALSE,0,0,2310,,Minimum Operations to Halve Array Sum,minimum-operations-to-halve-array-sum,FALSE,20230,44610,2208,FALSE,2,"Can you solve this real interview question? Minimum Operations to Halve Array Sum - You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.)

Return the minimum number of operations to reduce the sum of nums by at least half.

 

Example 1:


Input: nums = [5,19,8,1]
Output: 3
Explanation: The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.
The following is one of the ways to reduce the sum by at least half:
Pick the number 19 and reduce it to 9.5.
Pick the number 9.5 and reduce it to 4.75.
Pick the number 8 and reduce it to 4.
The final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. 
The sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.
Overall, 3 operations were used so we return 3.
It can be shown that we cannot reduce the sum by at least half in less than 3 operations.


Example 2:


Input: nums = [3,8,20]
Output: 3
Explanation: The initial sum of nums is equal to 3 + 8 + 20 = 31.
The following is one of the ways to reduce the sum by at least half:
Pick the number 20 and reduce it to 10.
Pick the number 10 and reduce it to 5.
Pick the number 3 and reduce it to 1.5.
The final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. 
The sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5.
Overall, 3 operations were used so we return 3.
It can be shown that we cannot reduce the sum by at least half in less than 3 operations.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 107",Solutions (443),455
FALSE,0,0,2309,,Maximize Number of Subsequences in a String,maximize-number-of-subsequences-in-a-string,FALSE,15419,46261,2207,FALSE,2,"Can you solve this real interview question? Maximize Number of Subsequences in a String - You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.

You can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.

Return the maximum number of times pattern can occur as a subsequence of the modified text.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

 

Example 1:


Input: text = ""abdcdbc"", pattern = ""ac""
Output: 4
Explanation:
If we add pattern[0] = 'a' in between text[1] and text[2], we get ""abadcdbc"". Now, the number of times ""ac"" occurs as a subsequence is 4.
Some other strings which have 4 subsequences ""ac"" after adding a character to text are ""aabdcdbc"" and ""abdacdbc"".
However, strings such as ""abdcadbc"", ""abdccdbc"", and ""abdcdbcc"", although obtainable, have only 3 subsequences ""ac"" and are thus suboptimal.
It can be shown that it is not possible to get more than 4 subsequences ""ac"" by adding only one character.


Example 2:


Input: text = ""aabb"", pattern = ""ab""
Output: 6
Explanation:
Some of the strings which can be obtained from text and have 6 subsequences ""ab"" are ""aaabb"", ""aaabb"", and ""aabbb"".


 

Constraints:

 * 1 <= text.length <= 105
 * pattern.length == 2
 * text and pattern consist only of lowercase English letters.",Solutions (251),397
FALSE,0,0,2308,,Divide Array Into Equal Pairs,divide-array-into-equal-pairs,FALSE,51745,70042,2206,FALSE,1,"Can you solve this real interview question? Divide Array Into Equal Pairs - You are given an integer array nums consisting of 2 * n integers.

You need to divide nums into n pairs such that:

 * Each element belongs to exactly one pair.
 * The elements present in a pair are equal.

Return true if nums can be divided into n pairs, otherwise return false.

 

Example 1:


Input: nums = [3,2,3,2,2,2]
Output: true
Explanation: 
There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.
If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.


Example 2:


Input: nums = [1,2,3,4]
Output: false
Explanation: 
There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.


 

Constraints:

 * nums.length == 2 * n
 * 1 <= n <= 500
 * 1 <= nums[i] <= 500",Solutions (1.1K),527
FALSE,0,0,2307,,Replace Non-Coprime Numbers in Array,replace-non-coprime-numbers-in-array,FALSE,11554,29941,2197,FALSE,3,"Can you solve this real interview question? Replace Non-Coprime Numbers in Array - You are given an array of integers nums. Perform the following steps:

 1. Find any two adjacent numbers in nums that are non-coprime.
 2. If no such numbers are found, stop the process.
 3. Otherwise, delete the two numbers and replace them with their LCM (Least Common Multiple).
 4. Repeat this process as long as you keep finding two adjacent non-coprime numbers.

Return the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.

The test cases are generated such that the values in the final array are less than or equal to 108.

Two values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.

 

Example 1:


Input: nums = [6,4,3,2,7,6,2]
Output: [12,7,6]
Explanation: 
- (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [12,3,2,7,6,2].
- (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [12,2,7,6,2].
- (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [12,7,6,2].
- (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,6].
There are no more adjacent non-coprime numbers in nums.
Thus, the final modified array is [12,7,6].
Note that there are other ways to obtain the same resultant array.


Example 2:


Input: nums = [2,2,1,1,3,3,3]
Output: [2,1,1,3]
Explanation: 
- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3,3].
- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3].
- (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [2,1,1,3].
There are no more adjacent non-coprime numbers in nums.
Thus, the final modified array is [2,1,1,3].
Note that there are other ways to obtain the same resultant array.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 105
 * The test cases are generated such that the values in the final array are less than or equal to 108.",Solutions (181),366
FALSE,0,0,2306,,Create Binary Tree From Descriptions,create-binary-tree-from-descriptions,FALSE,25852,35729,2196,FALSE,2,"Can you solve this real interview question? Create Binary Tree From Descriptions - You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,

 * If isLefti == 1, then childi is the left child of parenti.
 * If isLefti == 0, then childi is the right child of parenti.

Construct the binary tree described by descriptions and return its root.

The test cases will be generated such that the binary tree is valid.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png]


Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]
Output: [50,20,80,15,17,19]
Explanation: The root node is the node with value 50 since it has no parent.
The resulting binary tree is shown in the diagram.


Example 2:

[https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png]


Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]]
Output: [1,2,null,null,3,4]
Explanation: The root node is the node with value 1 since it has no parent.
The resulting binary tree is shown in the diagram.


 

Constraints:

 * 1 <= descriptions.length <= 104
 * descriptions[i].length == 3
 * 1 <= parenti, childi <= 105
 * 0 <= isLefti <= 1
 * The binary tree described by descriptions is valid.",Solutions (593),762
FALSE,0,0,2305,,Append K Integers With Minimal Sum,append-k-integers-with-minimal-sum,FALSE,25625,102475,2195,FALSE,2,"Can you solve this real interview question? Append K Integers With Minimal Sum - You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum.

Return the sum of the k integers appended to nums.

 

Example 1:


Input: nums = [1,4,25,10,25], k = 2
Output: 5
Explanation: The two unique positive integers that do not appear in nums which we append are 2 and 3.
The resulting sum of nums is 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum.
The sum of the two integers appended is 2 + 3 = 5, so we return 5.

Example 2:


Input: nums = [5,6], k = 6
Output: 25
Explanation: The six unique positive integers that do not appear in nums which we append are 1, 2, 3, 4, 7, and 8.
The resulting sum of nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the minimum. 
The sum of the six integers appended is 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 109
 * 1 <= k <= 108",Solutions (451),580
FALSE,0,0,2304,,Cells in a Range on an Excel Sheet,cells-in-a-range-on-an-excel-sheet,FALSE,46357,54476,2194,FALSE,1,"Can you solve this real interview question? Cells in a Range on an Excel Sheet - A cell (r, c) of an excel sheet is represented as a string ""<col><row>"" where:

 * <col> denotes the column number c of the cell. It is represented by alphabetical letters.
   * For example, the 1st column is denoted by 'A', the 2nd by 'B', the 3rd by 'C', and so on.
 * <row> is the row number r of the cell. The rth row is represented by the integer r.

You are given a string s in the format ""<col1><row1>:<col2><row2>"", where <col1> represents the column c1, <row1> represents the row r1, <col2> represents the column c2, and <row2> represents the row r2, such that r1 <= r2 and c1 <= c2.

Return the list of cells (x, y) such that r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as strings in the format mentioned above and be sorted in non-decreasing order first by columns and then by rows.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/02/08/ex1drawio.png]


Input: s = ""K1:L2""
Output: [""K1"",""K2"",""L1"",""L2""]
Explanation:
The above diagram shows the cells which should be present in the list.
The red arrows denote the order in which the cells should be presented.


Example 2:

[https://assets.leetcode.com/uploads/2022/02/09/exam2drawio.png]


Input: s = ""A1:F1""
Output: [""A1"",""B1"",""C1"",""D1"",""E1"",""F1""]
Explanation:
The above diagram shows the cells which should be present in the list.
The red arrow denotes the order in which the cells should be presented.


 

Constraints:

 * s.length == 5
 * 'A' <= s[0] <= s[3] <= 'Z'
 * '1' <= s[1] <= s[4] <= '9'
 * s consists of uppercase English letters, digits and ':'.",Solutions (775),421
FALSE,0,0,2301,,Count Array Pairs Divisible by K,count-array-pairs-divisible-by-k,FALSE,11723,41317,2183,FALSE,3,"Can you solve this real interview question? Count Array Pairs Divisible by K - Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that:

 * 0 <= i < j <= n - 1 and
 * nums[i] * nums[j] is divisible by k.

 

Example 1:


Input: nums = [1,2,3,4,5], k = 2
Output: 7
Explanation: 
The 7 pairs of indices whose corresponding products are divisible by 2 are
(0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4).
Their products are 2, 4, 6, 8, 10, 12, and 20 respectively.
Other pairs such as (0, 2) and (2, 4) have products 3 and 15 respectively, which are not divisible by 2.    


Example 2:


Input: nums = [1,2,3,4], k = 5
Output: 0
Explanation: There does not exist any pair of indices whose corresponding product is divisible by 5.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i], k <= 105",Solutions (139),670
FALSE,0,0,2300,,Construct String With Repeat Limit,construct-string-with-repeat-limit,FALSE,16866,32311,2182,FALSE,2,"Can you solve this real interview question? Construct String With Repeat Limit - You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s.

Return the lexicographically largest repeatLimitedString possible.

A string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the longer string is the lexicographically larger one.

 

Example 1:


Input: s = ""cczazcc"", repeatLimit = 3
Output: ""zzcccac""
Explanation: We use all of the characters from s to construct the repeatLimitedString ""zzcccac"".
The letter 'a' appears at most 1 time in a row.
The letter 'c' appears at most 3 times in a row.
The letter 'z' appears at most 2 times in a row.
Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.
The string is the lexicographically largest repeatLimitedString possible so we return ""zzcccac"".
Note that the string ""zzcccca"" is lexicographically larger but the letter 'c' appears more than 3 times in a row, so it is not a valid repeatLimitedString.


Example 2:


Input: s = ""aababab"", repeatLimit = 2
Output: ""bbabaa""
Explanation: We use only some of the characters from s to construct the repeatLimitedString ""bbabaa"". 
The letter 'a' appears at most 2 times in a row.
The letter 'b' appears at most 2 times in a row.
Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.
The string is the lexicographically largest repeatLimitedString possible so we return ""bbabaa"".
Note that the string ""bbabaaa"" is lexicographically larger but the letter 'a' appears more than 2 times in a row, so it is not a valid repeatLimitedString.


 

Constraints:

 * 1 <= repeatLimit <= s.length <= 105
 * s consists of lowercase English letters.",Solutions (381),516
FALSE,0,0,2299,,Merge Nodes in Between Zeros,merge-nodes-in-between-zeros,FALSE,70227,81311,2181,FALSE,2,"Can you solve this real interview question? Merge Nodes in Between Zeros - You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.

For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.

Return the head of the modified linked list.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png]


Input: head = [0,3,1,0,4,5,2,0]
Output: [4,11]
Explanation: 
The above figure represents the given linked list. The modified list contains
- The sum of the nodes marked in green: 3 + 1 = 4.
- The sum of the nodes marked in red: 4 + 5 + 2 = 11.


Example 2:

[https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png]


Input: head = [0,1,0,3,0,2,2,0]
Output: [1,3,4]
Explanation: 
The above figure represents the given linked list. The modified list contains
- The sum of the nodes marked in green: 1 = 1.
- The sum of the nodes marked in red: 3 = 3.
- The sum of the nodes marked in yellow: 2 + 2 = 4.


 

Constraints:

 * The number of nodes in the list is in the range [3, 2 * 105].
 * 0 <= Node.val <= 1000
 * There are no two consecutive nodes with Node.val == 0.
 * The beginning and end of the linked list have Node.val == 0.",Solutions (1.5K),1.2K
FALSE,0,0,2298,,Count Integers With Even Digit Sum,count-integers-with-even-digit-sum,FALSE,40932,62597,2180,FALSE,1,"Can you solve this real interview question? Count Integers With Even Digit Sum - Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even.

The digit sum of a positive integer is the sum of all its digits.

 

Example 1:


Input: num = 4
Output: 2
Explanation:
The only integers less than or equal to 4 whose digit sums are even are 2 and 4.    


Example 2:


Input: num = 30
Output: 14
Explanation:
The 14 integers less than or equal to 30 whose digit sums are even are
2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28.


 

Constraints:

 * 1 <= num <= 1000",Solutions (698),471
FALSE,0,0,2295,,Minimum Time to Finish the Race,minimum-time-to-finish-the-race,FALSE,9760,23404,2188,FALSE,3,"Can you solve this real interview question? Minimum Time to Finish the Race - You are given a 0-indexed 2D integer array tires where tires[i] = [fi, ri] indicates that the ith tire can finish its xth successive lap in fi * ri(x-1) seconds.

 * For example, if fi = 3 and ri = 2, then the tire would finish its 1st lap in 3 seconds, its 2nd lap in 3 * 2 = 6 seconds, its 3rd lap in 3 * 22 = 12 seconds, etc.

You are also given an integer changeTime and an integer numLaps.

The race consists of numLaps laps and you may start the race with any tire. You have an unlimited supply of each tire and after every lap, you may change to any given tire (including the current tire type) if you wait changeTime seconds.

Return the minimum time to finish the race.

 

Example 1:


Input: tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4
Output: 21
Explanation: 
Lap 1: Start with tire 0 and finish the lap in 2 seconds.
Lap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.
Lap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds.
Lap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.
Total time = 2 + 6 + 5 + 2 + 6 = 21 seconds.
The minimum time to complete the race is 21 seconds.


Example 2:


Input: tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5
Output: 25
Explanation: 
Lap 1: Start with tire 1 and finish the lap in 2 seconds.
Lap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.
Lap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds.
Lap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.
Lap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second.
Total time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds.
The minimum time to complete the race is 25 seconds. 


 

Constraints:

 * 1 <= tires.length <= 105
 * tires[i].length == 2
 * 1 <= fi, changeTime <= 105
 * 2 <= ri <= 105
 * 1 <= numLaps <= 1000",Solutions (98),479
FALSE,0,0,2294,minimum-time-to-complete-trips,Minimum Time to Complete Trips,minimum-time-to-complete-trips,FALSE,93897,239525,2187,FALSE,2,"Can you solve this real interview question? Minimum Time to Complete Trips - You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.

Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.

You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.

 

Example 1:


Input: time = [1,2,3], totalTrips = 5
Output: 3
Explanation:
- At time t = 1, the number of trips completed by each bus are [1,0,0]. 
  The total number of trips completed is 1 + 0 + 0 = 1.
- At time t = 2, the number of trips completed by each bus are [2,1,0]. 
  The total number of trips completed is 2 + 1 + 0 = 3.
- At time t = 3, the number of trips completed by each bus are [3,1,1]. 
  The total number of trips completed is 3 + 1 + 1 = 5.
So the minimum time needed for all buses to complete at least 5 trips is 3.


Example 2:


Input: time = [2], totalTrips = 1
Output: 2
Explanation:
There is only one bus, and it will complete its first trip at t = 2.
So the minimum time needed to complete 1 trip is 2.


 

Constraints:

 * 1 <= time.length <= 105
 * 1 <= time[i], totalTrips <= 107",Solutions (1.2K),2.4K
FALSE,0,0,2293,,Minimum Number of Steps to Make Two Strings Anagram II,minimum-number-of-steps-to-make-two-strings-anagram-ii,FALSE,31185,43291,2186,FALSE,2,"Can you solve this real interview question? Minimum Number of Steps to Make Two Strings Anagram II - You are given two strings s and t. In one step, you can append any character to either s or t.

Return the minimum number of steps to make s and t anagrams of each other.

An anagram of a string is a string that contains the same characters with a different (or the same) ordering.

 

Example 1:


Input: s = ""leetcode"", t = ""coats""
Output: 7
Explanation: 
- In 2 steps, we can append the letters in ""as"" onto s = ""leetcode"", forming s = ""leetcodeas"".
- In 5 steps, we can append the letters in ""leede"" onto t = ""coats"", forming t = ""coatsleede"".
""leetcodeas"" and ""coatsleede"" are now anagrams of each other.
We used a total of 2 + 5 = 7 steps.
It can be shown that there is no way to make them anagrams of each other with less than 7 steps.


Example 2:


Input: s = ""night"", t = ""thing""
Output: 0
Explanation: The given strings are already anagrams of each other. Thus, we do not need any further steps.


 

Constraints:

 * 1 <= s.length, t.length <= 2 * 105
 * s and t consist of lowercase English letters.",Solutions (614),432
FALSE,0,0,2292,,Counting Words With a Given Prefix,counting-words-with-a-given-prefix,FALSE,60333,78072,2185,FALSE,1,"Can you solve this real interview question? Counting Words With a Given Prefix - You are given an array of strings words and a string pref.

Return the number of strings in words that contain pref as a prefix.

A prefix of a string s is any leading contiguous substring of s.

 

Example 1:


Input: words = [""pay"",""attention"",""practice"",""attend""], pref = ""at""
Output: 2
Explanation: The 2 strings that contain ""at"" as a prefix are: ""attention"" and ""attend"".


Example 2:


Input: words = [""leetcode"",""win"",""loops"",""success""], pref = ""code""
Output: 0
Explanation: There are no strings that contain ""code"" as a prefix.


 

Constraints:

 * 1 <= words.length <= 100
 * 1 <= words[i].length, pref.length <= 100
 * words[i] and pref consist of lowercase English letters.",Solutions (1.2K),519
FALSE,0,0,2291,,Maximum AND Sum of Array,maximum-and-sum-of-array,FALSE,10551,21867,2172,FALSE,3,"Can you solve this real interview question? Maximum AND Sum of Array - You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots.

You have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number.

 * For example, the AND sum of placing the numbers [1, 3] into slot 1 and [4, 6] into slot 2 is equal to (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4.

Return the maximum possible AND sum of nums given numSlots slots.

 

Example 1:


Input: nums = [1,2,3,4,5,6], numSlots = 3
Output: 9
Explanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3. 
This gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.


Example 2:


Input: nums = [1,3,10,4,7,1], numSlots = 9
Output: 24
Explanation: One possible placement is [1, 1] into slot 1, [3] into slot 3, [4] into slot 4, [7] into slot 7, and [10] into slot 9.
This gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.
Note that slots 2, 5, 6, and 8 are empty which is permitted.


 

Constraints:

 * n == nums.length
 * 1 <= numSlots <= 9
 * 1 <= n <= 2 * numSlots
 * 1 <= nums[i] <= 15",Solutions (132),402
FALSE,0,0,2290,,Removing Minimum Number of Magic Beans,removing-minimum-number-of-magic-beans,FALSE,21050,50020,2171,FALSE,2,"Can you solve this real interview question? Removing Minimum Number of Magic Beans - You are given an array of positive integers beans, where each integer represents the number of magic beans found in a particular magic bag.

Remove any number of beans (possibly none) from each bag such that the number of beans in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it to any of the bags.

Return the minimum number of magic beans that you have to remove.

 

Example 1:


Input: beans = [4,1,6,5]
Output: 4
Explanation: 
- We remove 1 bean from the bag with only 1 bean.
  This results in the remaining bags: [4,0,6,5]
- Then we remove 2 beans from the bag with 6 beans.
  This results in the remaining bags: [4,0,4,5]
- Then we remove 1 bean from the bag with 5 beans.
  This results in the remaining bags: [4,0,4,4]
We removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.
There are no other solutions that remove 4 beans or fewer.


Example 2:


Input: beans = [2,10,3,2]
Output: 7
Explanation:
- We remove 2 beans from one of the bags with 2 beans.
  This results in the remaining bags: [0,10,3,2]
- Then we remove 2 beans from the other bag with 2 beans.
  This results in the remaining bags: [0,10,3,0]
- Then we remove 3 beans from the bag with 3 beans. 
  This results in the remaining bags: [0,10,0,0]
We removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.
There are no other solutions that removes 7 beans or fewer.


 

Constraints:

 * 1 <= beans.length <= 105
 * 1 <= beans[i] <= 105",Solutions (306),710
FALSE,0,0,2289,,Minimum Operations to Make the Array Alternating,minimum-operations-to-make-the-array-alternating,FALSE,19055,57433,2170,FALSE,2,"Can you solve this real interview question? Minimum Operations to Make the Array Alternating - You are given a 0-indexed array nums consisting of n positive integers.

The array nums is called alternating if:

 * nums[i - 2] == nums[i], where 2 <= i <= n - 1.
 * nums[i - 1] != nums[i], where 1 <= i <= n - 1.

In one operation, you can choose an index i and change nums[i] into any positive integer.

Return the minimum number of operations required to make the array alternating.

 

Example 1:


Input: nums = [3,1,3,2,4,3]
Output: 3
Explanation:
One way to make the array alternating is by converting it to [3,1,3,1,3,1].
The number of operations required in this case is 3.
It can be proven that it is not possible to make the array alternating in less than 3 operations. 


Example 2:


Input: nums = [1,2,2,2,2]
Output: 2
Explanation:
One way to make the array alternating is by converting it to [1,2,1,2,1].
The number of operations required in this case is 2.
Note that the array cannot be converted to [2,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array.


 

Constraints:

 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 105",Solutions (298),499
FALSE,0,0,2288,,Count Operations to Obtain Zero,count-operations-to-obtain-zero,FALSE,51854,69028,2169,FALSE,1,"Can you solve this real interview question? Count Operations to Obtain Zero - You are given two non-negative integers num1 and num2.

In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.

 * For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.

Return the number of operations required to make either num1 = 0 or num2 = 0.

 

Example 1:


Input: num1 = 2, num2 = 3
Output: 3
Explanation: 
- Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.
- Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we subtract num2 from num1.
- Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1.
Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations.
So the total number of operations required is 3.


Example 2:


Input: num1 = 10, num2 = 10
Output: 1
Explanation: 
- Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0.
Now num1 = 0 and num2 = 10. Since num1 == 0, we are done.
So the total number of operations required is 1.


 

Constraints:

 * 0 <= num1, num2 <= 105",Solutions (768),472
FALSE,0,0,2286,,Minimum Time to Remove All Cars Containing Illegal Goods,minimum-time-to-remove-all-cars-containing-illegal-goods,FALSE,10305,25307,2167,FALSE,3,"Can you solve this real interview question? Minimum Time to Remove All Cars Containing Illegal Goods - You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods.

As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times:

 1. Remove a train car from the left end (i.e., remove s[0]) which takes 1 unit of time.
 2. Remove a train car from the right end (i.e., remove s[s.length - 1]) which takes 1 unit of time.
 3. Remove a train car from anywhere in the sequence which takes 2 units of time.

Return the minimum time to remove all the cars containing illegal goods.

Note that an empty sequence of cars is considered to have no cars containing illegal goods.

 

Example 1:


Input: s = ""1100101""
Output: 5
Explanation: 
One way to remove all the cars containing illegal goods from the sequence is to
- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.
- remove a car from the right end. Time taken is 1.
- remove the car containing illegal goods found in the middle. Time taken is 2.
This obtains a total time of 2 + 1 + 2 = 5. 

An alternative way is to
- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.
- remove a car from the right end 3 times. Time taken is 3 * 1 = 3.
This also obtains a total time of 2 + 3 = 5.

5 is the minimum time taken to remove all the cars containing illegal goods. 
There are no other ways to remove them with less time.


Example 2:


Input: s = ""0010""
Output: 2
Explanation:
One way to remove all the cars containing illegal goods from the sequence is to
- remove a car from the left end 3 times. Time taken is 3 * 1 = 3.
This obtains a total time of 3.

Another way to remove all the cars containing illegal goods from the sequence is to
- remove the car containing illegal goods found in the middle. Time taken is 2.
This obtains a total time of 2.

Another way to remove all the cars containing illegal goods from the sequence is to 
- remove a car from the right end 2 times. Time taken is 2 * 1 = 2. 
This obtains a total time of 2.

2 is the minimum time taken to remove all the cars containing illegal goods. 
There are no other ways to remove them with less time.

 

Constraints:

 * 1 <= s.length <= 2 * 105
 * s[i] is either '0' or '1'.",Solutions (134),601
FALSE,0,0,2285,,Design Bitset,design-bitset,FALSE,18570,58451,2166,FALSE,2,"Can you solve this real interview question? Design Bitset - A Bitset is a data structure that compactly stores bits.

Implement the Bitset class:

 * Bitset(int size) Initializes the Bitset with size bits, all of which are 0.
 * void fix(int idx) Updates the value of the bit at the index idx to 1. If the value was already 1, no change occurs.
 * void unfix(int idx) Updates the value of the bit at the index idx to 0. If the value was already 0, no change occurs.
 * void flip() Flips the values of each bit in the Bitset. In other words, all bits with value 0 will now have value 1 and vice versa.
 * boolean all() Checks if the value of each bit in the Bitset is 1. Returns true if it satisfies the condition, false otherwise.
 * boolean one() Checks if there is at least one bit in the Bitset with value 1. Returns true if it satisfies the condition, false otherwise.
 * int count() Returns the total number of bits in the Bitset which have value 1.
 * String toString() Returns the current composition of the Bitset. Note that in the resultant string, the character at the ith index should coincide with the value at the ith bit of the Bitset.

 

Example 1:


Input
[""Bitset"", ""fix"", ""fix"", ""flip"", ""all"", ""unfix"", ""flip"", ""one"", ""unfix"", ""count"", ""toString""]
[[5], [3], [1], [], [], [0], [], [], [0], [], []]
Output
[null, null, null, null, false, null, null, true, null, 2, ""01010""]

Explanation
Bitset bs = new Bitset(5); // bitset = ""00000"".
bs.fix(3);     // the value at idx = 3 is updated to 1, so bitset = ""00010"".
bs.fix(1);     // the value at idx = 1 is updated to 1, so bitset = ""01010"". 
bs.flip();     // the value of each bit is flipped, so bitset = ""10101"". 
bs.all();      // return False, as not all values of the bitset are 1.
bs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = ""00101"".
bs.flip();     // the value of each bit is flipped, so bitset = ""11010"". 
bs.one();      // return True, as there is at least 1 index with value 1.
bs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = ""01010"".
bs.count();    // return 2, as there are 2 bits with value 1.
bs.toString(); // return ""01010"", which is the composition of bitset.


 

Constraints:

 * 1 <= size <= 105
 * 0 <= idx <= size - 1
 * At most 105 calls will be made in total to fix, unfix, flip, all, one, count, and toString.
 * At least one call will be made to all, one, count, or toString.
 * At most 5 calls will be made to toString.",Solutions (332),490
FALSE,0,0,2284,,Smallest Value of the Rearranged Number,smallest-value-of-the-rearranged-number,FALSE,27871,54243,2165,FALSE,2,"Can you solve this real interview question? Smallest Value of the Rearranged Number - You are given an integer num. Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros.

Return the rearranged number with minimal value.

Note that the sign of the number does not change after rearranging the digits.

 

Example 1:


Input: num = 310
Output: 103
Explanation: The possible arrangements for the digits of 310 are 013, 031, 103, 130, 301, 310. 
The arrangement with the smallest value that does not contain any leading zeros is 103.


Example 2:


Input: num = -7605
Output: -7650
Explanation: Some possible arrangements for the digits of -7605 are -7650, -6705, -5076, -0567.
The arrangement with the smallest value that does not contain any leading zeros is -7650.


 

Constraints:

 * -1015 <= num <= 1015",Solutions (462),518
FALSE,0,0,2283,,Sort Even and Odd Indices Independently,sort-even-and-odd-indices-independently,FALSE,42188,64830,2164,FALSE,1,"Can you solve this real interview question? Sort Even and Odd Indices Independently - You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:

 1. Sort the values at odd indices of nums in non-increasing order.
    * For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.
 2. Sort the values at even indices of nums in non-decreasing order.
    * For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.

Return the array formed after rearranging the values of nums.

 

Example 1:


Input: nums = [4,1,2,3]
Output: [2,3,4,1]
Explanation: 
First, we sort the values present at odd indices (1 and 3) in non-increasing order.
So, nums changes from [4,1,2,3] to [4,3,2,1].
Next, we sort the values present at even indices (0 and 2) in non-decreasing order.
So, nums changes from [4,1,2,3] to [2,3,4,1].
Thus, the array formed after rearranging the values is [2,3,4,1].


Example 2:


Input: nums = [2,1]
Output: [2,1]
Explanation: 
Since there is exactly one odd index and one even index, no rearrangement of values takes place.
The resultant array formed is [2,1], which is the same as the initial array. 


 

Constraints:

 * 1 <= nums.length <= 100
 * 1 <= nums[i] <= 100",Solutions (683),553
FALSE,0,0,2280,,Count Good Triplets in an Array,count-good-triplets-in-an-array,FALSE,5953,15445,2179,FALSE,3,"Can you solve this real interview question? Count Good Triplets in an Array - You are given two 0-indexed arrays nums1 and nums2 of length n, both of which are permutations of [0, 1, ..., n - 1].

A good triplet is a set of 3 distinct values which are present in increasing order by position both in nums1 and nums2. In other words, if we consider pos1v as the index of the value v in nums1 and pos2v as the index of the value v in nums2, then a good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that pos1x < pos1y < pos1z and pos2x < pos2y < pos2z.

Return the total number of good triplets.

 

Example 1:


Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3]
Output: 1
Explanation: 
There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). 
Out of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet.


Example 2:


Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
Output: 4
Explanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2).


 

Constraints:

 * n == nums1.length == nums2.length
 * 3 <= n <= 105
 * 0 <= nums1[i], nums2[i] <= n - 1
 * nums1 and nums2 are permutations of [0, 1, ..., n - 1].",Solutions (114),520
FALSE,0,0,2279,,Maximum Split of Positive Even Integers,maximum-split-of-positive-even-integers,FALSE,38107,64232,2178,FALSE,2,"Can you solve this real interview question? Maximum Split of Positive Even Integers - You are given an integer finalSum. Split it into a sum of a maximum number of unique positive even integers.

 * For example, given finalSum = 12, the following splits are valid (unique positive even integers summing up to finalSum): (12), (2 + 10), (2 + 4 + 6), and (4 + 8). Among them, (2 + 4 + 6) contains the maximum number of integers. Note that finalSum cannot be split into (2 + 2 + 4 + 4) as all the numbers should be unique.

Return a list of integers that represent a valid split containing a maximum number of integers. If no valid split exists for finalSum, return an empty list. You may return the integers in any order.

 

Example 1:


Input: finalSum = 12
Output: [2,4,6]
Explanation: The following are valid splits: (12), (2 + 10), (2 + 4 + 6), and (4 + 8).
(2 + 4 + 6) has the maximum number of integers, which is 3. Thus, we return [2,4,6].
Note that [2,6,4], [6,2,4], etc. are also accepted.


Example 2:


Input: finalSum = 7
Output: []
Explanation: There are no valid splits for the given finalSum.
Thus, we return an empty array.


Example 3:


Input: finalSum = 28
Output: [6,8,2,12]
Explanation: The following are valid splits: (2 + 26), (6 + 8 + 2 + 12), and (4 + 24). 
(6 + 8 + 2 + 12) has the maximum number of integers, which is 4. Thus, we return [6,8,2,12].
Note that [10,2,4,12], [6,2,4,16], etc. are also accepted.


 

Constraints:

 * 1 <= finalSum <= 1010",Solutions (482),651
FALSE,0,0,2278,,Find Three Consecutive Integers That Sum to a Given Number,find-three-consecutive-integers-that-sum-to-a-given-number,FALSE,32581,50935,2177,FALSE,2,"Can you solve this real interview question? Find Three Consecutive Integers That Sum to a Given Number - Given an integer num, return three consecutive integers (as a sorted array) that sum to num. If num cannot be expressed as the sum of three consecutive integers, return an empty array.

 

Example 1:


Input: num = 33
Output: [10,11,12]
Explanation: 33 can be expressed as 10 + 11 + 12 = 33.
10, 11, 12 are 3 consecutive integers, so we return [10, 11, 12].


Example 2:


Input: num = 4
Output: []
Explanation: There is no way to express 4 as the sum of 3 consecutive integers.


 

Constraints:

 * 0 <= num <= 1015",Solutions (756),521
FALSE,0,0,2277,,Count Equal and Divisible Pairs in an Array,count-equal-and-divisible-pairs-in-an-array,FALSE,49344,61901,2176,FALSE,1,"Can you solve this real interview question? Count Equal and Divisible Pairs in an Array - Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.

 

Example 1:


Input: nums = [3,1,2,2,2,1,3], k = 2
Output: 4
Explanation:
There are 4 pairs that meet all the requirements:
- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.


Example 2:


Input: nums = [1,2,3,4], k = 1
Output: 0
Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.


 

Constraints:

 * 1 <= nums.length <= 100
 * 1 <= nums[i], k <= 100",Solutions (722),489
FALSE,0,0,2276,,Groups of Strings,groups-of-strings,FALSE,7527,29328,2157,FALSE,3,"Can you solve this real interview question? Groups of Strings - You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words.

Two strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations:

 * Adding exactly one letter to the set of the letters of s1.
 * Deleting exactly one letter from the set of the letters of s1.
 * Replacing exactly one letter from the set of the letters of s1 with any letter, including itself.

The array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true:

 * It is connected to at least one other string of the group.
 * It is the only string present in the group.

Note that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.

Return an array ans of size 2 where:

 * ans[0] is the maximum number of groups words can be divided into, and
 * ans[1] is the size of the largest group.

 

Example 1:


Input: words = [""a"",""b"",""ab"",""cde""]
Output: [2,3]
Explanation:
- words[0] can be used to obtain words[1] (by replacing 'a' with 'b'), and words[2] (by adding 'b'). So words[0] is connected to words[1] and words[2].
- words[1] can be used to obtain words[0] (by replacing 'b' with 'a'), and words[2] (by adding 'a'). So words[1] is connected to words[0] and words[2].
- words[2] can be used to obtain words[0] (by deleting 'b'), and words[1] (by deleting 'a'). So words[2] is connected to words[0] and words[1].
- words[3] is not connected to any string in words.
Thus, words can be divided into 2 groups [""a"",""b"",""ab""] and [""cde""]. The size of the largest group is 3.  


Example 2:


Input: words = [""a"",""ab"",""abc""]
Output: [1,3]
Explanation:
- words[0] is connected to words[1].
- words[1] is connected to words[0] and words[2].
- words[2] is connected to words[1].
Since all strings are connected to each other, they should be grouped together.
Thus, the size of the largest group is 3.


 

Constraints:

 * 1 <= words.length <= 2 * 104
 * 1 <= words[i].length <= 26
 * words[i] consists of lowercase English letters only.
 * No letter occurs more than once in words[i].",Solutions (101),364
FALSE,0,0,2275,,Find Substring With Given Hash Value,find-substring-with-given-hash-value,FALSE,11178,50232,2156,FALSE,3,"Can you solve this real interview question? Find Substring With Given Hash Value - The hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function:

 * hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.

Where val(s[i]) represents the index of s[i] in the alphabet from val('a') = 1 to val('z') = 26.

You are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue.

The test cases will be generated such that an answer always exists.

A substring is a contiguous non-empty sequence of characters within a string.

 

Example 1:


Input: s = ""leetcode"", power = 7, modulo = 20, k = 2, hashValue = 0
Output: ""ee""
Explanation: The hash of ""ee"" can be computed to be hash(""ee"", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. 
""ee"" is the first substring of length 2 with hashValue 0. Hence, we return ""ee"".


Example 2:


Input: s = ""fbxzaad"", power = 31, modulo = 100, k = 3, hashValue = 32
Output: ""fbx""
Explanation: The hash of ""fbx"" can be computed to be hash(""fbx"", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. 
The hash of ""bxz"" can be computed to be hash(""bxz"", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. 
""fbx"" is the first substring of length 3 with hashValue 32. Hence, we return ""fbx"".
Note that ""bxz"" also has a hash of 32 but it appears later than ""fbx"".


 

Constraints:

 * 1 <= k <= s.length <= 2 * 104
 * 1 <= power, modulo <= 109
 * 0 <= hashValue < modulo
 * s consists of lowercase English letters only.
 * The test cases are generated such that an answer always exists.",Solutions (128),375
FALSE,0,0,2274,,Keep Multiplying Found Values by Two,keep-multiplying-found-values-by-two,FALSE,63116,86948,2154,FALSE,1,"Can you solve this real interview question? Keep Multiplying Found Values by Two - You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.

You then do the following steps:

 1. If original is found in nums, multiply it by two (i.e., set original = 2 * original).
 2. Otherwise, stop the process.
 3. Repeat this process with the new number as long as you keep finding the number.

Return the final value of original.

 

Example 1:


Input: nums = [5,3,6,1,12], original = 3
Output: 24
Explanation: 
- 3 is found in nums. 3 is multiplied by 2 to obtain 6.
- 6 is found in nums. 6 is multiplied by 2 to obtain 12.
- 12 is found in nums. 12 is multiplied by 2 to obtain 24.
- 24 is not found in nums. Thus, 24 is returned.


Example 2:


Input: nums = [2,7,9], original = 4
Output: 4
Explanation:
- 4 is not found in nums. Thus, 4 is returned.


 

Constraints:

 * 1 <= nums.length <= 1000
 * 1 <= nums[i], original <= 1000",Solutions (1.3K),531
FALSE,0,0,2272,,Maximum Good People Based on Statements,maximum-good-people-based-on-statements,FALSE,11078,22507,2151,FALSE,3,"Can you solve this real interview question? Maximum Good People Based on Statements - There are two types of persons:

 * The good person: The person who always tells the truth.
 * The bad person: The person who might tell the truth and might lie.

You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following:

 * 0 which represents a statement made by person i that person j is a bad person.
 * 1 which represents a statement made by person i that person j is a good person.
 * 2 represents that no statement is made by person i about person j.

Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 <= i < n.

Return the maximum number of people who can be good based on the statements made by the n people.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg]


Input: statements = [[2,1,2],[1,2,2],[2,0,2]]
Output: 2
Explanation: Each person makes a single statement.
- Person 0 states that person 1 is good.
- Person 1 states that person 0 is good.
- Person 2 states that person 1 is bad.
Let's take person 2 as the key.
- Assuming that person 2 is a good person:
    - Based on the statement made by person 2, person 1 is a bad person.
    - Now we know for sure that person 1 is bad and person 2 is good.
    - Based on the statement made by person 1, and since person 1 is bad, they could be:
        - telling the truth. There will be a contradiction in this case and this assumption is invalid.
        - lying. In this case, person 0 is also a bad person and lied in their statement.
    - Following that person 2 is a good person, there will be only one good person in the group.
- Assuming that person 2 is a bad person:
    - Based on the statement made by person 2, and since person 2 is bad, they could be:
        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.
            - Following that person 2 is bad but told the truth, there will be no good persons in the group.
        - lying. In this case person 1 is a good person.
            - Since person 1 is a good person, person 0 is also a good person.
            - Following that person 2 is bad and lied, there will be two good persons in the group.
We can see that at most 2 persons are good in the best case, so we return 2.
Note that there is more than one way to arrive at this conclusion.


Example 2:

[https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg]


Input: statements = [[2,0],[0,2]]
Output: 1
Explanation: Each person makes a single statement.
- Person 0 states that person 1 is bad.
- Person 1 states that person 0 is bad.
Let's take person 0 as the key.
- Assuming that person 0 is a good person:
    - Based on the statement made by person 0, person 1 is a bad person and was lying.
    - Following that person 0 is a good person, there will be only one good person in the group.
- Assuming that person 0 is a bad person:
    - Based on the statement made by person 0, and since person 0 is bad, they could be:
        - telling the truth. Following this scenario, person 0 and 1 are both bad.
            - Following that person 0 is bad but told the truth, there will be no good persons in the group.
        - lying. In this case person 1 is a good person.
            - Following that person 0 is bad and lied, there will be only one good person in the group.
We can see that at most, one person is good in the best case, so we return 1.
Note that there is more than one way to arrive at this conclusion.


 

Constraints:

 * n == statements.length == statements[i].length
 * 2 <= n <= 15
 * statements[i][j] is either 0, 1, or 2.
 * statements[i][i] == 2",Solutions (161),426
FALSE,0,0,2271,,Rearrange Array Elements by Sign,rearrange-array-elements-by-sign,FALSE,71593,88594,2149,FALSE,2,"Can you solve this real interview question? Rearrange Array Elements by Sign - You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.

You should rearrange the elements of nums such that the modified array follows the given conditions:

 1. Every consecutive pair of integers have opposite signs.
 2. For all integers with the same sign, the order in which they were present in nums is preserved.
 3. The rearranged array begins with a positive integer.

Return the modified array after rearranging the elements to satisfy the aforementioned conditions.

 

Example 1:


Input: nums = [3,1,-2,-5,2,-4]
Output: [3,-2,1,-5,2,-4]
Explanation:
The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  


Example 2:


Input: nums = [-1,1]
Output: [1,-1]
Explanation:
1 is the only positive integer and -1 the only negative integer in nums.
So nums is rearranged to [1,-1].


 

Constraints:

 * 2 <= nums.length <= 2 * 105
 * nums.length is even
 * 1 <= |nums[i]| <= 105
 * nums consists of equal number of positive and negative integers.",Solutions (1.3K),1.4K
FALSE,0,0,2270,,Find All Lonely Numbers in the Array,find-all-lonely-numbers-in-the-array,FALSE,33770,55797,2150,FALSE,2,"Can you solve this real interview question? Find All Lonely Numbers in the Array - You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.

Return all lonely numbers in nums. You may return the answer in any order.

 

Example 1:


Input: nums = [10,6,5,8]
Output: [10,8]
Explanation: 
- 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.
- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.
- 5 is not a lonely number since 6 appears in nums and vice versa.
Hence, the lonely numbers in nums are [10, 8].
Note that [8, 10] may also be returned.


Example 2:


Input: nums = [1,3,5,3]
Output: [1,5]
Explanation: 
- 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.
- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.
- 3 is not a lonely number since it appears twice.
Hence, the lonely numbers in nums are [1, 5].
Note that [5, 1] may also be returned.


 

Constraints:

 * 1 <= nums.length <= 105
 * 0 <= nums[i] <= 106",Solutions (601),456
FALSE,0,0,2269,,Count Elements With Strictly Smaller and Greater Elements ,count-elements-with-strictly-smaller-and-greater-elements,FALSE,40211,67352,2148,FALSE,1,"Can you solve this real interview question? Count Elements With Strictly Smaller and Greater Elements  - Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.

 

Example 1:


Input: nums = [11,7,2,15]
Output: 2
Explanation: The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.
Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.
In total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.


Example 2:


Input: nums = [-3,3,3,90]
Output: 2
Explanation: The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.
Since there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.


 

Constraints:

 * 1 <= nums.length <= 100
 * -105 <= nums[i] <= 105",Solutions (669),480
FALSE,0,0,2267,,Minimum Difference in Sums After Removal of Elements,minimum-difference-in-sums-after-removal-of-elements,FALSE,7498,15772,2163,FALSE,3,"Can you solve this real interview question? Minimum Difference in Sums After Removal of Elements - You are given a 0-indexed integer array nums consisting of 3 * n elements.

You are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts:

 * The first n elements belonging to the first part and their sum is sumfirst.
 * The next n elements belonging to the second part and their sum is sumsecond.

The difference in sums of the two parts is denoted as sumfirst - sumsecond.

 * For example, if sumfirst = 3 and sumsecond = 2, their difference is 1.
 * Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.

Return the minimum difference possible between the sums of the two parts after the removal of n elements.

 

Example 1:


Input: nums = [3,1,2]
Output: -1
Explanation: Here, nums has 3 elements, so n = 1. 
Thus we have to remove 1 element from nums and divide the array into two equal parts.
- If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1.
- If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1.
- If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2.
The minimum difference between sums of the two parts is min(-1,1,2) = -1. 


Example 2:


Input: nums = [7,9,5,8,1,3]
Output: 1
Explanation: Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.
If we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12.
To obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1.
It can be shown that it is not possible to obtain a difference smaller than 1.


 

Constraints:

 * nums.length == 3 * n
 * 1 <= n <= 105
 * 1 <= nums[i] <= 105",Solutions (130),544
FALSE,0,0,2266,,Minimum Cost to Set Cooking Time,minimum-cost-to-set-cooking-time,FALSE,13356,33477,2162,FALSE,2,"Can you solve this real interview question? Minimum Cost to Set Cooking Time - A generic microwave supports cooking times for:

 * at least 1 second.
 * at most 99 minutes and 99 seconds.

To set the cooking time, you push at most four digits. The microwave normalizes what you push as four digits by prepending zeroes. It interprets the first two digits as the minutes and the last two digits as the seconds. It then adds them up as the cooking time. For example,

 * You push 9 5 4 (three digits). It is normalized as 0954 and interpreted as 9 minutes and 54 seconds.
 * You push 0 0 0 8 (four digits). It is interpreted as 0 minutes and 8 seconds.
 * You push 8 0 9 0. It is interpreted as 80 minutes and 90 seconds.
 * You push 8 1 3 0. It is interpreted as 81 minutes and 30 seconds.

You are given integers startAt, moveCost, pushCost, and targetSeconds. Initially, your finger is on the digit startAt. Moving the finger above any specific digit costs moveCost units of fatigue. Pushing the digit below the finger once costs pushCost units of fatigue.

There can be multiple ways to set the microwave to cook for targetSeconds seconds but you are interested in the way with the minimum cost.

Return the minimum cost to set targetSeconds seconds of cooking time.

Remember that one minute consists of 60 seconds.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/30/1.png]


Input: startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600
Output: 6
Explanation: The following are the possible ways to set the cooking time.
- 1 0 0 0, interpreted as 10 minutes and 0 seconds.
  The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1).
  The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.
- 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds.
  The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).
  The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.
- 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds.
  The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).
  The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.


Example 2:

[https://assets.leetcode.com/uploads/2021/12/30/2.png]


Input: startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76
Output: 6
Explanation: The optimal way is to push two digits: 7 6, interpreted as 76 seconds.
The finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6
Note other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost.


 

Constraints:

 * 0 <= startAt <= 9
 * 1 <= moveCost, pushCost <= 105
 * 1 <= targetSeconds <= 6039",Solutions (208),177
FALSE,0,0,2265,,Partition Array According to Given Pivot,partition-array-according-to-given-pivot,FALSE,46224,54524,2161,FALSE,2,"Can you solve this real interview question? Partition Array According to Given Pivot - You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:

 * Every element less than pivot appears before every element greater than pivot.
 * Every element equal to pivot appears in between the elements less than and greater than pivot.
 * The relative order of the elements less than pivot and the elements greater than pivot is maintained.
   * More formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.

Return nums after the rearrangement.

 

Example 1:


Input: nums = [9,12,5,10,14,3,10], pivot = 10
Output: [9,5,3,10,10,12,14]
Explanation: 
The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.
The elements 12 and 14 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.


Example 2:


Input: nums = [-3,4,3,2], pivot = 2
Output: [-3,2,4,3]
Explanation: 
The element -3 is less than the pivot so it is on the left side of the array.
The elements 4 and 3 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.


 

Constraints:

 * 1 <= nums.length <= 105
 * -106 <= nums[i] <= 106
 * pivot equals to an element of nums.",Solutions (850),770
FALSE,0,0,2264,,Minimum Sum of Four Digit Number After Splitting Digits,minimum-sum-of-four-digit-number-after-splitting-digits,FALSE,79839,91867,2160,FALSE,1,"Can you solve this real interview question? Minimum Sum of Four Digit Number After Splitting Digits - You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used.

 * For example, given num = 2932, you have the following digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329].

Return the minimum possible sum of new1 and new2.

 

Example 1:


Input: num = 2932
Output: 52
Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.
The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52.


Example 2:


Input: num = 4009
Output: 13
Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. 
The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.


 

Constraints:

 * 1000 <= num <= 9999",Solutions (1.5K),1K
FALSE,0,0,2263,,Maximum Running Time of N Computers,maximum-running-time-of-n-computers,FALSE,11115,28385,2141,FALSE,3,"Can you solve this real interview question? Maximum Running Time of N Computers - You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.

Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.

Note that the batteries cannot be recharged.

Return the maximum number of minutes you can run all the n computers simultaneously.

 

Example 1:

[https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png]


Input: n = 2, batteries = [3,3,3]
Output: 4
Explanation: 
Initially, insert battery 0 into the first computer and battery 1 into the second computer.
After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.
At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.
By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.
We can run the two computers simultaneously for at most 4 minutes, so we return 4.



Example 2:

[https://assets.leetcode.com/uploads/2022/01/06/example2.png]


Input: n = 2, batteries = [1,1,1,1]
Output: 2
Explanation: 
Initially, insert battery 0 into the first computer and battery 2 into the second computer. 
After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. 
After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.
We can run the two computers simultaneously for at most 2 minutes, so we return 2.


 

Constraints:

 * 1 <= n <= batteries.length <= 105
 * 1 <= batteries[i] <= 109",Solutions (125),627
FALSE,0,0,2262,,Solving Questions With Brainpower,solving-questions-with-brainpower,FALSE,24870,53638,2140,FALSE,2,"Can you solve this real interview question? Solving Questions With Brainpower - You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].

The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.

 * For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:
   * If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.
   * If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.

Return the maximum points you can earn for the exam.

 

Example 1:


Input: questions = [[3,2],[4,3],[4,4],[2,5]]
Output: 5
Explanation: The maximum points can be earned by solving questions 0 and 3.
- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions
- Unable to solve questions 1 and 2
- Solve question 3: Earn 2 points
Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.


Example 2:


Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
Output: 7
Explanation: The maximum points can be earned by solving questions 1 and 4.
- Skip question 0
- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions
- Unable to solve questions 2 and 3
- Solve question 4: Earn 5 points
Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.


 

Constraints:

 * 1 <= questions.length <= 105
 * questions[i].length == 2
 * 1 <= pointsi, brainpoweri <= 105",Solutions (432),753
FALSE,0,0,2261,,All Divisions With the Highest Score of a Binary Array,all-divisions-with-the-highest-score-of-a-binary-array,FALSE,24663,38807,2155,FALSE,2,"Can you solve this real interview question? All Divisions With the Highest Score of a Binary Array - You are given a 0-indexed binary array nums of length n. nums can be divided at index i (where 0 <= i <= n) into two arrays (possibly empty) numsleft and numsright:

 * numsleft has all the elements of nums between index 0 and i - 1 (inclusive), while numsright has all the elements of nums between index i and n - 1 (inclusive).
 * If i == 0, numsleft is empty, while numsright has all the elements of nums.
 * If i == n, numsleft has all the elements of nums, while numsright is empty.

The division score of an index i is the sum of the number of 0's in numsleft and the number of 1's in numsright.

Return all distinct indices that have the highest possible division score. You may return the answer in any order.

 

Example 1:


Input: nums = [0,0,1,0]
Output: [2,4]
Explanation: Division at index
- 0: numsleft is []. numsright is [0,0,1,0]. The score is 0 + 1 = 1.
- 1: numsleft is [0]. numsright is [0,1,0]. The score is 1 + 1 = 2.
- 2: numsleft is [0,0]. numsright is [1,0]. The score is 2 + 1 = 3.
- 3: numsleft is [0,0,1]. numsright is [0]. The score is 2 + 0 = 2.
- 4: numsleft is [0,0,1,0]. numsright is []. The score is 3 + 0 = 3.
Indices 2 and 4 both have the highest possible division score 3.
Note the answer [4,2] would also be accepted.

Example 2:


Input: nums = [0,0,0]
Output: [3]
Explanation: Division at index
- 0: numsleft is []. numsright is [0,0,0]. The score is 0 + 0 = 0.
- 1: numsleft is [0]. numsright is [0,0]. The score is 1 + 0 = 1.
- 2: numsleft is [0,0]. numsright is [0]. The score is 2 + 0 = 2.
- 3: numsleft is [0,0,0]. numsright is []. The score is 3 + 0 = 3.
Only index 3 has the highest possible division score 3.


Example 3:


Input: nums = [1,1]
Output: [0]
Explanation: Division at index
- 0: numsleft is []. numsright is [1,1]. The score is 0 + 2 = 2.
- 1: numsleft is [1]. numsright is [1]. The score is 0 + 1 = 1.
- 2: numsleft is [1,1]. numsright is []. The score is 0 + 0 = 0.
Only index 0 has the highest possible division score 2.


 

Constraints:

 * n == nums.length
 * 1 <= n <= 105
 * nums[i] is either 0 or 1.",Solutions (364),425
FALSE,0,0,2260,,Divide a String Into Groups of Size k,divide-a-string-into-groups-of-size-k,FALSE,34764,53103,2138,FALSE,1,"Can you solve this real interview question? Divide a String Into Groups of Size k - A string s can be partitioned into groups of size k using the following procedure:

 * The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group.
 * For the last group, if the string does not have k characters remaining, a character fill is used to complete the group.

Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.

Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.

 

Example 1:


Input: s = ""abcdefghi"", k = 3, fill = ""x""
Output: [""abc"",""def"",""ghi""]
Explanation:
The first 3 characters ""abc"" form the first group.
The next 3 characters ""def"" form the second group.
The last 3 characters ""ghi"" form the third group.
Since all groups can be completely filled by characters from the string, we do not need to use fill.
Thus, the groups formed are ""abc"", ""def"", and ""ghi"".


Example 2:


Input: s = ""abcdefghij"", k = 3, fill = ""x""
Output: [""abc"",""def"",""ghi"",""jxx""]
Explanation:
Similar to the previous example, we are forming the first three groups ""abc"", ""def"", and ""ghi"".
For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.
Thus, the 4 groups formed are ""abc"", ""def"", ""ghi"", and ""jxx"".


 

Constraints:

 * 1 <= s.length <= 100
 * s consists of lowercase English letters only.
 * 1 <= k <= 100
 * fill is a lowercase English letter.",Solutions (684),370
FALSE,0,0,2257,earliest-possible-day-of-full-bloom,Earliest Possible Day of Full Bloom,earliest-possible-day-of-full-bloom,FALSE,47068,64160,2136,FALSE,3,"Can you solve this real interview question? Earliest Possible Day of Full Bloom - You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:

 * plantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total.
 * growTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.

From the beginning of day 0, you can plant the seeds in any order.

Return the earliest possible day where all seeds are blooming.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/21/1.png]


Input: plantTime = [1,4,3], growTime = [2,3,1]
Output: 9
Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.
One optimal way is:
On day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.
On days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.
On days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.
Thus, on day 9, all the seeds are blooming.


Example 2:

[https://assets.leetcode.com/uploads/2021/12/21/2.png]


Input: plantTime = [1,2,3,2], growTime = [2,1,2,1]
Output: 9
Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.
One optimal way is:
On day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.
On days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.
On days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.
On days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.
Thus, on day 9, all the seeds are blooming.


Example 3:


Input: plantTime = [1], growTime = [1]
Output: 2
Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.
Thus, on day 2, all the seeds are blooming.


 

Constraints:

 * n == plantTime.length == growTime.length
 * 1 <= n <= 105
 * 1 <= plantTime[i], growTime[i] <= 104",Solutions (708),1.4K
FALSE,0,0,2256,,Count Words Obtained After Adding a Letter,count-words-obtained-after-adding-a-letter,FALSE,29348,68550,2135,FALSE,2,"Can you solve this real interview question? Count Words Obtained After Adding a Letter - You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only.

For each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords.

The conversion operation is described in the following two steps:

 1. Append any lowercase letter that is not present in the string to its end.
    * For example, if the string is ""abc"", the letters 'd', 'e', or 'y' can be added to it, but not 'a'. If 'd' is added, the resulting string will be ""abcd"".
 2. Rearrange the letters of the new string in any arbitrary order.
    * For example, ""abcd"" can be rearranged to ""acbd"", ""bacd"", ""cbda"", and so on. Note that it can also be rearranged to ""abcd"" itself.

Return the number of strings in targetWords that can be obtained by performing the operations on any string of startWords.

Note that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process.

 

Example 1:


Input: startWords = [""ant"",""act"",""tack""], targetWords = [""tack"",""act"",""acti""]
Output: 2
Explanation:
- In order to form targetWords[0] = ""tack"", we use startWords[1] = ""act"", append 'k' to it, and rearrange ""actk"" to ""tack"".
- There is no string in startWords that can be used to obtain targetWords[1] = ""act"".
  Note that ""act"" does exist in startWords, but we must append one letter to the string before rearranging it.
- In order to form targetWords[2] = ""acti"", we use startWords[1] = ""act"", append 'i' to it, and rearrange ""acti"" to ""acti"" itself.


Example 2:


Input: startWords = [""ab"",""a""], targetWords = [""abc"",""abcd""]
Output: 1
Explanation:
- In order to form targetWords[0] = ""abc"", we use startWords[0] = ""ab"", add 'c' to it, and rearrange it to ""abc"".
- There is no string in startWords that can be used to obtain targetWords[1] = ""abcd"".


 

Constraints:

 * 1 <= startWords.length, targetWords.length <= 5 * 104
 * 1 <= startWords[i].length, targetWords[j].length <= 26
 * Each string of startWords and targetWords consists of lowercase English letters only.
 * No letter occurs more than once in any string of startWords or targetWords.",Solutions (327),592
FALSE,0,0,2255,,Minimum Swaps to Group All 1's Together II,minimum-swaps-to-group-all-1s-together-ii,FALSE,21331,41578,2134,FALSE,2,"Can you solve this real interview question? Minimum Swaps to Group All 1's Together II - A swap is defined as taking two distinct positions in an array and swapping the values in them.

A circular array is defined as an array where we consider the first element and the last element to be adjacent.

Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.

 

Example 1:


Input: nums = [0,1,0,1,1,0,0]
Output: 1
Explanation: Here are a few of the ways to group all the 1's together:
[0,0,1,1,1,0,0] using 1 swap.
[0,1,1,1,0,0,0] using 1 swap.
[1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).
There is no way to group all 1's together with 0 swaps.
Thus, the minimum number of swaps required is 1.


Example 2:


Input: nums = [0,1,1,1,0,0,1,1,0]
Output: 2
Explanation: Here are a few of the ways to group all the 1's together:
[1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).
[1,1,1,1,1,0,0,0,0] using 2 swaps.
There is no way to group all 1's together with 0 or 1 swaps.
Thus, the minimum number of swaps required is 2.


Example 3:


Input: nums = [1,1,0,0,1]
Output: 0
Explanation: All the 1's are already grouped together due to the circular property of the array.
Thus, the minimum number of swaps required is 0.


 

Constraints:

 * 1 <= nums.length <= 105
 * nums[i] is either 0 or 1.",Solutions (334),892
FALSE,0,0,2254,,Check if Every Row and Column Contains All Numbers,check-if-every-row-and-column-contains-all-numbers,FALSE,50999,97316,2133,FALSE,1,"Can you solve this real interview question? Check if Every Row and Column Contains All Numbers - An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).

Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png]


Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]
Output: true
Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.
Hence, we return true.


Example 2:

[https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png]


Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]
Output: false
Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.
Hence, we return false.


 

Constraints:

 * n == matrix.length == matrix[i].length
 * 1 <= n <= 100
 * 1 <= matrix[i][j] <= n",Solutions (698),734
FALSE,0,0,2251,,Number of Ways to Divide a Long Corridor,number-of-ways-to-divide-a-long-corridor,FALSE,9506,23823,2147,FALSE,3,"Can you solve this real interview question? Number of Ways to Divide a Long Corridor - Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.

One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.

Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.

Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/04/1.png]


Input: corridor = ""SSPPSPS""
Output: 3
Explanation: There are 3 different ways to divide the corridor.
The black bars in the above image indicate the two room dividers already installed.
Note that in each of the ways, each section has exactly two seats.


Example 2:

[https://assets.leetcode.com/uploads/2021/12/04/2.png]


Input: corridor = ""PPSPSP""
Output: 1
Explanation: There is only 1 way to divide the corridor, by not installing any additional dividers.
Installing any would create some section that does not have exactly two seats.


Example 3:

[https://assets.leetcode.com/uploads/2021/12/12/3.png]


Input: corridor = ""S""
Output: 0
Explanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats.


 

Constraints:

 * n == corridor.length
 * 1 <= n <= 105
 * corridor[i] is either 'S' or 'P'.",Solutions (191),307
FALSE,0,0,2250,,K Highest Ranked Items Within a Price Range,k-highest-ranked-items-within-a-price-range,FALSE,12237,29578,2146,FALSE,2,"Can you solve this real interview question? K Highest Ranked Items Within a Price Range - You are given a 0-indexed 2D integer array grid of size m x n that represents a map of the items in a shop. The integers in the grid represent the following:

 * 0 represents a wall that you cannot pass through.
 * 1 represents an empty cell that you can freely move to and from.
 * All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.

It takes 1 step to travel between adjacent grid cells.

You are also given integer arrays pricing and start where pricing = [low, high] and start = [row, col] indicates that you start at the position (row, col) and are interested only in items with a price in the range of [low, high] (inclusive). You are further given an integer k.

You are interested in the positions of the k highest-ranked items whose prices are within the given price range. The rank is determined by the first of these criteria that is different:

 1. Distance, defined as the length of the shortest path from the start (shorter distance has a higher rank).
 2. Price (lower price has a higher rank, but it must be in the price range).
 3. The row number (smaller row number has a higher rank).
 4. The column number (smaller column number has a higher rank).

Return the k highest-ranked items within the price range sorted by their rank (highest to lowest). If there are fewer than k reachable items within the price range, return all of them.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/16/example1drawio.png]


Input: grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3
Output: [[0,1],[1,1],[2,1]]
Explanation: You start at (0,0).
With a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2).
The ranks of these items are:
- (0,1) with distance 1
- (1,1) with distance 2
- (2,1) with distance 3
- (2,2) with distance 4
Thus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1).


Example 2:

[https://assets.leetcode.com/uploads/2021/12/16/example2drawio1.png]


Input: grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2
Output: [[2,1],[1,2]]
Explanation: You start at (2,3).
With a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1).
The ranks of these items are:
- (2,1) with distance 2, price 2
- (1,2) with distance 2, price 3
- (1,1) with distance 3
- (0,1) with distance 4
Thus, the 2 highest ranked items in the price range are (2,1) and (1,2).


Example 3:

[https://assets.leetcode.com/uploads/2021/12/30/example3.png]


Input: grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3
Output: [[2,1],[2,0]]
Explanation: You start at (0,0).
With a price range of [2,3], we can take items from (2,0) and (2,1). 
The ranks of these items are: 
- (2,1) with distance 5
- (2,0) with distance 6
Thus, the 2 highest ranked items in the price range are (2,1) and (2,0). 
Note that k = 3 but there are only 2 reachable items within the price range.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 105
 * 1 <= m * n <= 105
 * 0 <= grid[i][j] <= 105
 * pricing.length == 2
 * 2 <= low <= high <= 105
 * start.length == 2
 * 0 <= row <= m - 1
 * 0 <= col <= n - 1
 * grid[row][col] > 0
 * 1 <= k <= m * n",Solutions (250),414
FALSE,0,0,2249,,Count the Hidden Sequences,count-the-hidden-sequences,FALSE,14773,40095,2145,FALSE,2,"Can you solve this real interview question? Count the Hidden Sequences - You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i].

You are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain.

 * For example, given differences = [1, -3, 4], lower = 1, upper = 6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6 (inclusive).
   * [3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences.
   * [5, 6, 3, 7] is not possible since it contains an element greater than 6.
   * [1, 2, 3, 4] is not possible since the differences are not correct.

Return the number of possible hidden sequences there are. If there are no possible sequences, return 0.

 

Example 1:


Input: differences = [1,-3,4], lower = 1, upper = 6
Output: 2
Explanation: The possible hidden sequences are:
- [3, 4, 1, 5]
- [4, 5, 2, 6]
Thus, we return 2.


Example 2:


Input: differences = [3,-4,5,1,-2], lower = -4, upper = 5
Output: 4
Explanation: The possible hidden sequences are:
- [-3, 0, -4, 1, 2, 0]
- [-2, 1, -3, 2, 3, 1]
- [-1, 2, -2, 3, 4, 2]
- [0, 3, -1, 4, 5, 3]
Thus, we return 4.


Example 3:


Input: differences = [4,-7,2], lower = 3, upper = 6
Output: 0
Explanation: There are no possible hidden sequences. Thus, we return 0.


 

Constraints:

 * n == differences.length
 * 1 <= n <= 105
 * -105 <= differences[i] <= 105
 * -105 <= lower <= upper <= 105",Solutions (233),452
FALSE,0,0,2248,,Minimum Cost of Buying Candies With Discount,minimum-cost-of-buying-candies-with-discount,FALSE,34857,57113,2144,FALSE,1,"Can you solve this real interview question? Minimum Cost of Buying Candies With Discount - A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.

The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.

 * For example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4.

Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.

 

Example 1:


Input: cost = [1,2,3]
Output: 5
Explanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.
The total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies.
Note that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.
The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.


Example 2:


Input: cost = [6,5,7,9,2,2]
Output: 23
Explanation: The way in which we can get the minimum cost is described below:
- Buy candies with costs 9 and 7
- Take the candy with cost 6 for free
- We buy candies with costs 5 and 2
- Take the last remaining candy with cost 2 for free
Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.


Example 3:


Input: cost = [5,5]
Output: 10
Explanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.
Hence, the minimum cost to buy all candies is 5 + 5 = 10.


 

Constraints:

 * 1 <= cost.length <= 100
 * 1 <= cost[i] <= 100",Solutions (621),443
FALSE,0,0,2246,,Maximum Employees to Be Invited to a Meeting,maximum-employees-to-be-invited-to-a-meeting,FALSE,8270,23931,2127,FALSE,3,"Can you solve this real interview question? Maximum Employees to Be Invited to a Meeting - A company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.

The employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.

Given a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/14/ex1.png]


Input: favorite = [2,2,1,2]
Output: 3
Explanation:
The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.
All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.
Note that the company can also invite employees 1, 2, and 3, and give them their desired seats.
The maximum number of employees that can be invited to the meeting is 3. 


Example 2:


Input: favorite = [1,2,0]
Output: 3
Explanation: 
Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.
The seating arrangement will be the same as that in the figure given in example 1:
- Employee 0 will sit between employees 2 and 1.
- Employee 1 will sit between employees 0 and 2.
- Employee 2 will sit between employees 1 and 0.
The maximum number of employees that can be invited to the meeting is 3.


Example 3:

[https://assets.leetcode.com/uploads/2021/12/14/ex2.png]


Input: favorite = [3,0,1,4,1]
Output: 4
Explanation:
The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.
Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.
So the company leaves them out of the meeting.
The maximum number of employees that can be invited to the meeting is 4.


 

Constraints:

 * n == favorite.length
 * 2 <= n <= 105
 * 0 <= favorite[i] <= n - 1
 * favorite[i] != i",Solutions (93),776
FALSE,0,0,2245,,Destroying Asteroids,destroying-asteroids,FALSE,27267,54552,2126,FALSE,2,"Can you solve this real interview question? Destroying Asteroids - You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid.

You can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed.

Return true if all asteroids can be destroyed. Otherwise, return false.

 

Example 1:


Input: mass = 10, asteroids = [3,9,19,5,21]
Output: true
Explanation: One way to order the asteroids is [9,19,5,3,21]:
- The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19
- The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38
- The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43
- The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46
- The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67
All asteroids are destroyed.


Example 2:


Input: mass = 5, asteroids = [4,9,23,4]
Output: false
Explanation: 
The planet cannot ever gain enough mass to destroy the asteroid with a mass of 23.
After the planet destroys the other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22.
This is less than 23, so a collision would not destroy the last asteroid.

 

Constraints:

 * 1 <= mass <= 105
 * 1 <= asteroids.length <= 105
 * 1 <= asteroids[i] <= 105",Solutions (422),370
FALSE,0,0,2244,,Number of Laser Beams in a Bank,number-of-laser-beams-in-a-bank,FALSE,44514,54160,2125,FALSE,2,"Can you solve this real interview question? Number of Laser Beams in a Bank - Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.

There is one laser beam between any two security devices if both conditions are met:

 * The two devices are located on two different rows: r1 and r2, where r1 < r2.
 * For each row i where r1 < i < r2, there are no security devices in the ith row.

Laser beams are independent, i.e., one beam does not interfere nor join with another.

Return the total number of laser beams in the bank.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/24/laser1.jpg]


Input: bank = [""011001"",""000000"",""010100"",""001000""]
Output: 8
Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:
 * bank[0][1] -- bank[2][1]
 * bank[0][1] -- bank[2][3]
 * bank[0][2] -- bank[2][1]
 * bank[0][2] -- bank[2][3]
 * bank[0][5] -- bank[2][1]
 * bank[0][5] -- bank[2][3]
 * bank[2][1] -- bank[3][2]
 * bank[2][3] -- bank[3][2]
Note that there is no beam between any device on the 0th row with any on the 3rd row.
This is because the 2nd row contains security devices, which breaks the second condition.


Example 2:

[https://assets.leetcode.com/uploads/2021/12/24/laser2.jpg]


Input: bank = [""000"",""111"",""000""]
Output: 0
Explanation: There does not exist two devices located on two different rows.


 

Constraints:

 * m == bank.length
 * n == bank[i].length
 * 1 <= m, n <= 500
 * bank[i][j] is either '0' or '1'.",Solutions (855),674
FALSE,0,0,2243,,Check if All A's Appears Before All B's,check-if-all-as-appears-before-all-bs,FALSE,51502,72385,2124,FALSE,1,"Can you solve this real interview question? Check if All A's Appears Before All B's - Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, return false.

 

Example 1:


Input: s = ""aaabbb""
Output: true
Explanation:
The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5.
Hence, every 'a' appears before every 'b' and we return true.


Example 2:


Input: s = ""abab""
Output: false
Explanation:
There is an 'a' at index 2 and a 'b' at index 1.
Hence, not every 'a' appears before every 'b' and we return false.


Example 3:


Input: s = ""bbb""
Output: true
Explanation:
There are no 'a's, hence, every 'a' appears before every 'b' and we return true.


 

Constraints:

 * 1 <= s.length <= 100
 * s[i] is either 'a' or 'b'.",Solutions (1.2K),573
FALSE,0,0,2241,,Recover the Original Array,recover-the-original-array,FALSE,8743,22713,2122,FALSE,3,"Can you solve this real interview question? Recover the Original Array - Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner:

 1. lower[i] = arr[i] - k, for every index i where 0 <= i < n
 2. higher[i] = arr[i] + k, for every index i where 0 <= i < n

Unfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. Help Alice and recover the original array.

Given an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. In case the answer is not unique, return any valid array.

Note: The test cases are generated such that there exists at least one valid array arr.

 

Example 1:


Input: nums = [2,10,6,4,8,12]
Output: [3,7,11]
Explanation:
If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12].
Combining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums.
Another valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. 


Example 2:


Input: nums = [1,1,3,3]
Output: [2,2]
Explanation:
If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3].
Combining lower and higher gives us [1,1,3,3], which is equal to nums.
Note that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0.
This is invalid since k must be positive.


Example 3:


Input: nums = [5,435]
Output: [220]
Explanation:
The only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435].


 

Constraints:

 * 2 * n == nums.length
 * 1 <= n <= 1000
 * 1 <= nums[i] <= 109
 * The test cases are generated such that there exists at least one valid array arr.",Solutions (100),331
FALSE,0,0,2240,,Intervals Between Identical Elements,intervals-between-identical-elements,FALSE,15227,35253,2121,FALSE,2,"Can you solve this real interview question? Intervals Between Identical Elements - You are given a 0-indexed array of n integers arr.

The interval between two elements in arr is defined as the absolute difference between their indices. More formally, the interval between arr[i] and arr[j] is |i - j|.

Return an array intervals of length n where intervals[i] is the sum of intervals between arr[i] and each element in arr with the same value as arr[i].

Note: |x| is the absolute value of x.

 

Example 1:


Input: arr = [2,1,3,1,2,3,3]
Output: [4,2,7,2,4,4,5]
Explanation:
- Index 0: Another 2 is found at index 4. |0 - 4| = 4
- Index 1: Another 1 is found at index 3. |1 - 3| = 2
- Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7
- Index 3: Another 1 is found at index 1. |3 - 1| = 2
- Index 4: Another 2 is found at index 0. |4 - 0| = 4
- Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4
- Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5


Example 2:


Input: arr = [10,5,10,10]
Output: [5,0,3,4]
Explanation:
- Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5
- Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.
- Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3
- Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4


 

Constraints:

 * n == arr.length
 * 1 <= n <= 105
 * 1 <= arr[i] <= 105",Solutions (282),729
FALSE,0,0,2239,,Execution of All Suffix Instructions Staying in a Grid,execution-of-all-suffix-instructions-staying-in-a-grid,FALSE,22974,27575,2120,FALSE,2,"Can you solve this real interview question? Execution of All Suffix Instructions Staying in a Grid - There is an n x n grid, with the top-left cell at (0, 0) and the bottom-right cell at (n - 1, n - 1). You are given the integer n and an integer array startPos where startPos = [startrow, startcol] indicates that a robot is initially at cell (startrow, startcol).

You are also given a 0-indexed string s of length m where s[i] is the ith instruction for the robot: 'L' (move left), 'R' (move right), 'U' (move up), and 'D' (move down).

The robot can begin executing from any ith instruction in s. It executes the instructions one by one towards the end of s but it stops if either of these conditions is met:

 * The next instruction will move the robot off the grid.
 * There are no more instructions left to execute.

Return an array answer of length m where answer[i] is the number of instructions the robot can execute if the robot begins executing from the ith instruction in s.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/09/1.png]


Input: n = 3, startPos = [0,1], s = ""RRDDLU""
Output: [1,5,4,3,1,0]
Explanation: Starting from startPos and beginning execution from the ith instruction:
- 0th: ""RRDDLU"". Only one instruction ""R"" can be executed before it moves off the grid.
- 1st:  ""RDDLU"". All five instructions can be executed while it stays in the grid and ends at (1, 1).
- 2nd:   ""DDLU"". All four instructions can be executed while it stays in the grid and ends at (1, 0).
- 3rd:    ""DLU"". All three instructions can be executed while it stays in the grid and ends at (0, 0).
- 4th:     ""LU"". Only one instruction ""L"" can be executed before it moves off the grid.
- 5th:      ""U"". If moving up, it would move off the grid.


Example 2:

[https://assets.leetcode.com/uploads/2021/12/09/2.png]


Input: n = 2, startPos = [1,1], s = ""LURD""
Output: [4,1,0,0]
Explanation:
- 0th: ""LURD"".
- 1st:  ""URD"".
- 2nd:   ""RD"".
- 3rd:    ""D"".


Example 3:

[https://assets.leetcode.com/uploads/2021/12/09/3.png]


Input: n = 1, startPos = [0,0], s = ""LRUD""
Output: [0,0,0,0]
Explanation: No matter which instruction the robot begins execution from, it would move off the grid.


 

Constraints:

 * m == s.length
 * 1 <= n, m <= 500
 * startPos.length == 2
 * 0 <= startrow, startcol < n
 * s consists of 'L', 'R', 'U', and 'D'.",Solutions (396),419
FALSE,0,0,2238,,A Number After a Double Reversal,a-number-after-a-double-reversal,FALSE,54132,70331,2119,FALSE,1,"Can you solve this real interview question? A Number After a Double Reversal - Reversing an integer means to reverse all its digits.

 * For example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.

Given an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.

 

Example 1:


Input: num = 526
Output: true
Explanation: Reverse num to get 625, then reverse 625 to get 526, which equals num.


Example 2:


Input: num = 1800
Output: false
Explanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num.


Example 3:


Input: num = 0
Output: true
Explanation: Reverse num to get 0, then reverse 0 to get 0, which equals num.


 

Constraints:

 * 0 <= num <= 106",Solutions (1.2K),485
FALSE,0,0,2237,longest-palindrome-by-concatenating-two-letter-words,Longest Palindrome by Concatenating Two Letter Words,longest-palindrome-by-concatenating-two-letter-words,FALSE,98566,203318,2131,FALSE,2,"Can you solve this real interview question? Longest Palindrome by Concatenating Two Letter Words - You are given an array of strings words. Each element of words consists of two lowercase English letters.

Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.

Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.

A palindrome is a string that reads the same forward and backward.

 

Example 1:


Input: words = [""lc"",""cl"",""gg""]
Output: 6
Explanation: One longest palindrome is ""lc"" + ""gg"" + ""cl"" = ""lcggcl"", of length 6.
Note that ""clgglc"" is another longest palindrome that can be created.


Example 2:


Input: words = [""ab"",""ty"",""yt"",""lc"",""cl"",""ab""]
Output: 8
Explanation: One longest palindrome is ""ty"" + ""lc"" + ""cl"" + ""yt"" = ""tylcclyt"", of length 8.
Note that ""lcyttycl"" is another longest palindrome that can be created.


Example 3:


Input: words = [""cc"",""ll"",""xx""]
Output: 2
Explanation: One longest palindrome is ""cc"", of length 2.
Note that ""ll"" is another longest palindrome that can be created, and so is ""xx"".


 

Constraints:

 * 1 <= words.length <= 105
 * words[i].length == 2
 * words[i] consists of lowercase English letters.",Solutions (1.3K),2.2K
FALSE,0,0,2236,,Maximum Twin Sum of a Linked List,maximum-twin-sum-of-a-linked-list,FALSE,87487,108531,2130,FALSE,2,"Can you solve this real interview question? Maximum Twin Sum of a Linked List - In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.

 * For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.

The twin sum is defined as the sum of a node and its twin.

Given the head of a linked list with even length, return the maximum twin sum of the linked list.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png]


Input: head = [5,4,2,1]
Output: 6
Explanation:
Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6. 


Example 2:

[https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png]


Input: head = [4,2,2,3]
Output: 7
Explanation:
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
Thus, the maximum twin sum of the linked list is max(7, 4) = 7. 


Example 3:

[https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png]


Input: head = [1,100000]
Output: 100001
Explanation:
There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.


 

Constraints:

 * The number of nodes in the list is an even integer in the range [2, 105].
 * 1 <= Node.val <= 105",Solutions (1.6K),1.6K
FALSE,0,0,2235,,Capitalize the Title,capitalize-the-title,FALSE,42644,68732,2129,FALSE,1,"Can you solve this real interview question? Capitalize the Title - You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:

 * If the length of the word is 1 or 2 letters, change all letters to lowercase.
 * Otherwise, change the first letter to uppercase and the remaining letters to lowercase.

Return the capitalized title.

 

Example 1:


Input: title = ""capiTalIze tHe titLe""
Output: ""Capitalize The Title""
Explanation:
Since all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.


Example 2:


Input: title = ""First leTTeR of EACH Word""
Output: ""First Letter of Each Word""
Explanation:
The word ""of"" has length 2, so it is all lowercase.
The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.


Example 3:


Input: title = ""i lOve leetcode""
Output: ""i Love Leetcode""
Explanation:
The word ""i"" has length 1, so it is lowercase.
The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.


 

Constraints:

 * 1 <= title.length <= 100
 * title consists of words separated by a single space without any leading or trailing spaces.
 * Each word consists of uppercase and lowercase English letters and is non-empty.",Solutions (906),569
FALSE,0,0,2234,,Minimum Operations to Make the Array K-Increasing,minimum-operations-to-make-the-array-k-increasing,FALSE,10781,28664,2111,FALSE,3,"Can you solve this real interview question? Minimum Operations to Make the Array K-Increasing - You are given a 0-indexed array arr consisting of n positive integers, and a positive integer k.

The array arr is called K-increasing if arr[i-k] <= arr[i] holds for every index i, where k <= i <= n-1.

 * For example, arr = [4, 1, 5, 2, 6, 2] is K-increasing for k = 2 because:
   * arr[0] <= arr[2] (4 <= 5)
   * arr[1] <= arr[3] (1 <= 2)
   * arr[2] <= arr[4] (5 <= 6)
   * arr[3] <= arr[5] (2 <= 2)
 * However, the same arr is not K-increasing for k = 1 (because arr[0] > arr[1]) or k = 3 (because arr[0] > arr[3]).

In one operation, you can choose an index i and change arr[i] into any positive integer.

Return the minimum number of operations required to make the array K-increasing for the given k.

 

Example 1:


Input: arr = [5,4,3,2,1], k = 1
Output: 4
Explanation:
For k = 1, the resultant array has to be non-decreasing.
Some of the K-increasing arrays that can be formed are [5,6,7,8,9], [1,1,1,1,1], [2,2,3,4,4]. All of them require 4 operations.
It is suboptimal to change the array to, for example, [6,7,8,9,10] because it would take 5 operations.
It can be shown that we cannot make the array K-increasing in less than 4 operations.


Example 2:


Input: arr = [4,1,5,2,6,2], k = 2
Output: 0
Explanation:
This is the same example as the one in the problem description.
Here, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i].
Since the given array is already K-increasing, we do not need to perform any operations.

Example 3:


Input: arr = [4,1,5,2,6,2], k = 3
Output: 2
Explanation:
Indices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5.
One of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5.
The array will now be [4,1,5,4,6,5].
Note that there can be other ways to make the array K-increasing, but none of them require less than 2 operations.


 

Constraints:

 * 1 <= arr.length <= 105
 * 1 <= arr[i], k <= arr.length",Solutions (143),610
FALSE,0,0,2233,,Number of Smooth Descent Periods of a Stock,number-of-smooth-descent-periods-of-a-stock,FALSE,28325,48903,2110,FALSE,2,"Can you solve this real interview question? Number of Smooth Descent Periods of a Stock - You are given an integer array prices representing the daily price history of a stock, where prices[i] is the stock price on the ith day.

A smooth descent period of a stock consists of one or more contiguous days such that the price on each day is lower than the price on the preceding day by exactly 1. The first day of the period is exempted from this rule.

Return the number of smooth descent periods.

 

Example 1:


Input: prices = [3,2,1,4]
Output: 7
Explanation: There are 7 smooth descent periods:
[3], [2], [1], [4], [3,2], [2,1], and [3,2,1]
Note that a period with one day is a smooth descent period by the definition.


Example 2:


Input: prices = [8,6,7,7]
Output: 4
Explanation: There are 4 smooth descent periods: [8], [6], [7], and [7]
Note that [8,6] is not a smooth descent period as 8 - 6 ≠ 1.


Example 3:


Input: prices = [1]
Output: 1
Explanation: There is 1 smooth descent period: [1]


 

Constraints:

 * 1 <= prices.length <= 105
 * 1 <= prices[i] <= 105",Solutions (495),551
FALSE,0,0,2232,,Adding Spaces to a String,adding-spaces-to-a-string,FALSE,30469,53937,2109,FALSE,2,"Can you solve this real interview question? Adding Spaces to a String - You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index.

 * For example, given s = ""EnjoyYourCoffee"" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain ""Enjoy Your Coffee"".

Return the modified string after the spaces have been added.

 

Example 1:


Input: s = ""LeetcodeHelpsMeLearn"", spaces = [8,13,15]
Output: ""Leetcode Helps Me Learn""
Explanation: 
The indices 8, 13, and 15 correspond to the underlined characters in ""LeetcodeHelpsMeLearn"".
We then place spaces before those characters.


Example 2:


Input: s = ""icodeinpython"", spaces = [1,5,7,9]
Output: ""i code in py thon""
Explanation:
The indices 1, 5, 7, and 9 correspond to the underlined characters in ""icodeinpython"".
We then place spaces before those characters.


Example 3:


Input: s = ""spacing"", spaces = [0,1,2,3,4,5,6]
Output: "" s p a c i n g""
Explanation:
We are also able to place spaces before the first character of the string.


 

Constraints:

 * 1 <= s.length <= 3 * 105
 * s consists only of lowercase and uppercase English letters.
 * 1 <= spaces.length <= 3 * 105
 * 0 <= spaces[i] <= s.length - 1
 * All the values of spaces are strictly increasing.",Solutions (511),433
FALSE,0,0,2231,,Find First Palindromic String in the Array,find-first-palindromic-string-in-the-array,FALSE,81684,103783,2108,FALSE,1,"Can you solve this real interview question? Find First Palindromic String in the Array - Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string """".

A string is palindromic if it reads the same forward and backward.

 

Example 1:


Input: words = [""abc"",""car"",""ada"",""racecar"",""cool""]
Output: ""ada""
Explanation: The first string that is palindromic is ""ada"".
Note that ""racecar"" is also palindromic, but it is not the first.


Example 2:


Input: words = [""notapalindrome"",""racecar""]
Output: ""racecar""
Explanation: The first and only string that is palindromic is ""racecar"".


Example 3:


Input: words = [""def"",""ghi""]
Output: """"
Explanation: There are no palindromic strings, so the empty string is returned.


 

Constraints:

 * 1 <= words.length <= 100
 * 1 <= words[i].length <= 100
 * words[i] consists only of lowercase English letters.",Solutions (1.3K),776
FALSE,0,0,2229,,Maximum Fruits Harvested After at Most K Steps,maximum-fruits-harvested-after-at-most-k-steps,FALSE,8489,24262,2106,FALSE,3,"Can you solve this real interview question? Maximum Fruits Harvested After at Most K Steps - Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique.

You are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.

Return the maximum total number of fruits you can harvest.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/11/21/1.png]


Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
Output: 9
Explanation: 
The optimal way is to:
- Move right to position 6 and harvest 3 fruits
- Move right to position 8 and harvest 6 fruits
You moved 3 steps and harvested 3 + 6 = 9 fruits in total.


Example 2:

[https://assets.leetcode.com/uploads/2021/11/21/2.png]


Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4
Output: 14
Explanation: 
You can move at most k = 4 steps, so you cannot reach position 0 nor 10.
The optimal way is to:
- Harvest the 7 fruits at the starting position 5
- Move left to position 4 and harvest 1 fruit
- Move right to position 6 and harvest 2 fruits
- Move right to position 7 and harvest 4 fruits
You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.


Example 3:

[https://assets.leetcode.com/uploads/2021/11/21/3.png]


Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2
Output: 0
Explanation:
You can move at most k = 2 steps and cannot reach any position with fruits.


 

Constraints:

 * 1 <= fruits.length <= 105
 * fruits[i].length == 2
 * 0 <= startPos, positioni <= 2 * 105
 * positioni-1 < positioni for any i > 0 (0-indexed)
 * 1 <= amounti <= 104
 * 0 <= k <= 2 * 105",Solutions (125),437
FALSE,0,0,2228,,Watering Plants II,watering-plants-ii,FALSE,15255,30856,2105,FALSE,2,"Can you solve this real interview question? Watering Plants II - Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.

Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:

 * Alice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.
 * It takes the same amount of time to water each plant regardless of how much water it needs.
 * Alice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.
 * In case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.

Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.

 

Example 1:


Input: plants = [2,2,3,3], capacityA = 5, capacityB = 5
Output: 1
Explanation:
- Initially, Alice and Bob have 5 units of water each in their watering cans.
- Alice waters plant 0, Bob waters plant 3.
- Alice and Bob now have 3 units and 2 units of water respectively.
- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.
So, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.


Example 2:


Input: plants = [2,2,3,3], capacityA = 3, capacityB = 4
Output: 2
Explanation:
- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.
- Alice waters plant 0, Bob waters plant 3.
- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.
- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.
So, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.


Example 3:


Input: plants = [5], capacityA = 10, capacityB = 8
Output: 0
Explanation:
- There is only one plant.
- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.
So, the total number of times they have to refill is 0.


 

Constraints:

 * n == plants.length
 * 1 <= n <= 105
 * 1 <= plants[i] <= 106
 * max(plants[i]) <= capacityA, capacityB <= 109",Solutions (274),217
FALSE,0,0,2227,sum-of-subarray-ranges,Sum of Subarray Ranges,sum-of-subarray-ranges,FALSE,67098,111268,2104,FALSE,2,"Can you solve this real interview question? Sum of Subarray Ranges - You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.

Return the sum of all subarray ranges of nums.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:


Input: nums = [1,2,3]
Output: 4
Explanation: The 6 subarrays of nums are the following:
[1], range = largest - smallest = 1 - 1 = 0 
[2], range = 2 - 2 = 0
[3], range = 3 - 3 = 0
[1,2], range = 2 - 1 = 1
[2,3], range = 3 - 2 = 1
[1,2,3], range = 3 - 1 = 2
So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.

Example 2:


Input: nums = [1,3,3]
Output: 4
Explanation: The 6 subarrays of nums are the following:
[1], range = largest - smallest = 1 - 1 = 0
[3], range = 3 - 3 = 0
[3], range = 3 - 3 = 0
[1,3], range = 3 - 1 = 2
[3,3], range = 3 - 3 = 0
[1,3,3], range = 3 - 1 = 2
So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.


Example 3:


Input: nums = [4,-2,-3,4,1]
Output: 59
Explanation: The sum of all subarray ranges of nums is 59.


 

Constraints:

 * 1 <= nums.length <= 1000
 * -109 <= nums[i] <= 109

 

Follow-up: Could you find a solution with O(n) time complexity?",Solutions (416),1.7K
FALSE,0,0,2226,,Rings and Rods,rings-and-rods,FALSE,51833,63782,2103,FALSE,1,"Can you solve this real interview question? Rings and Rods - There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.

You are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where:

 * The first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').
 * The second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').

For example, ""R3G2B1"" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.

Return the number of rods that have all three colors of rings on them.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/11/23/ex1final.png]


Input: rings = ""B0B6G0R6R0R6G9""
Output: 1
Explanation: 
- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.
- The rod labeled 6 holds 3 rings, but it only has red and blue.
- The rod labeled 9 holds only a green ring.
Thus, the number of rods with all three colors is 1.


Example 2:

[https://assets.leetcode.com/uploads/2021/11/23/ex2final.png]


Input: rings = ""B0R0G0R9R0B0G0""
Output: 1
Explanation: 
- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.
- The rod labeled 9 holds only a red ring.
Thus, the number of rods with all three colors is 1.


Example 3:


Input: rings = ""G4""
Output: 0
Explanation: 
Only one ring is given. Thus, no rods have all three colors.


 

Constraints:

 * rings.length == 2 * n
 * 1 <= n <= 100
 * rings[i] where i is even is either 'R', 'G', or 'B' (0-indexed).
 * rings[i] where i is odd is a digit from '0' to '9' (0-indexed).",Solutions (1.1K),732
FALSE,0,0,2222,,Abbreviating the Product of a Range,abbreviating-the-product-of-a-range,FALSE,2627,9699,2117,FALSE,3,"Can you solve this real interview question? Abbreviating the Product of a Range - You are given two positive integers left and right with left <= right. Calculate the product of all integers in the inclusive range [left, right].

Since the product may be very large, you will abbreviate it following these steps:

 1. Count all trailing zeros in the product and remove them. Let us denote this count as C.
    * For example, there are 3 trailing zeros in 1000, and there are 0 trailing zeros in 546.
 2. Denote the remaining number of digits in the product as d. If d > 10, then express the product as <pre>...<suf> where <pre> denotes the first 5 digits of the product, and <suf> denotes the last 5 digits of the product after removing all trailing zeros. If d <= 10, we keep it unchanged.
    * For example, we express 1234567654321 as 12345...54321, but 1234567 is represented as 1234567.
 3. Finally, represent the product as a string ""<pre>...<suf>eC"".
    * For example, 12345678987600000 will be represented as ""12345...89876e5"".

Return a string denoting the abbreviated product of all integers in the inclusive range [left, right].

 

Example 1:


Input: left = 1, right = 4
Output: ""24e0""
Explanation: The product is 1 × 2 × 3 × 4 = 24.
There are no trailing zeros, so 24 remains the same. The abbreviation will end with ""e0"".
Since the number of digits is 2, which is less than 10, we do not have to abbreviate it further.
Thus, the final representation is ""24e0"".


Example 2:


Input: left = 2, right = 11
Output: ""399168e2""
Explanation: The product is 39916800.
There are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with ""e2"".
The number of digits after removing the trailing zeros is 6, so we do not abbreviate it further.
Hence, the abbreviated product is ""399168e2"".


Example 3:


Input: left = 371, right = 375
Output: ""7219856259e3""
Explanation: The product is 7219856259000.


 

Constraints:

 * 1 <= left <= right <= 104",Solutions (47),76
FALSE,0,0,2221,,Check if a Parentheses String Can Be Valid,check-if-a-parentheses-string-can-be-valid,FALSE,15083,48574,2116,FALSE,2,"Can you solve this real interview question? Check if a Parentheses String Can Be Valid - A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:

 * It is ().
 * It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.
 * It can be written as (A), where A is a valid parentheses string.

You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked,

 * If locked[i] is '1', you cannot change s[i].
 * But if locked[i] is '0', you can change s[i] to either '(' or ')'.

Return true if you can make s a valid parentheses string. Otherwise, return false.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/11/06/eg1.png]


Input: s = ""))()))"", locked = ""010100""
Output: true
Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].
We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.

Example 2:


Input: s = ""()()"", locked = ""0000""
Output: true
Explanation: We do not need to make any changes because s is already valid.


Example 3:


Input: s = "")"", locked = ""0""
Output: false
Explanation: locked permits us to change s[0]. 
Changing s[0] to either '(' or ')' will not make s valid.


 

Constraints:

 * n == s.length == locked.length
 * 1 <= n <= 105
 * s[i] is either '(' or ')'.
 * locked[i] is either '0' or '1'.",Solutions (175),863
FALSE,0,0,2220,,Find All Possible Recipes from Given Supplies,find-all-possible-recipes-from-given-supplies,FALSE,64206,132565,2115,FALSE,2,"Can you solve this real interview question? Find All Possible Recipes from Given Supplies - You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.

You are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.

Return a list of all the recipes that you can create. You may return the answer in any order.

Note that two recipes may contain each other in their ingredients.

 

Example 1:


Input: recipes = [""bread""], ingredients = [[""yeast"",""flour""]], supplies = [""yeast"",""flour"",""corn""]
Output: [""bread""]
Explanation:
We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".


Example 2:


Input: recipes = [""bread"",""sandwich""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""]], supplies = [""yeast"",""flour"",""meat""]
Output: [""bread"",""sandwich""]
Explanation:
We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".
We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"".


Example 3:


Input: recipes = [""bread"",""sandwich"",""burger""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""],[""sandwich"",""meat"",""bread""]], supplies = [""yeast"",""flour"",""meat""]
Output: [""bread"",""sandwich"",""burger""]
Explanation:
We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".
We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"".
We can create ""burger"" since we have the ingredient ""meat"" and can create the ingredients ""bread"" and ""sandwich"".


 

Constraints:

 * n == recipes.length == ingredients.length
 * 1 <= n <= 100
 * 1 <= ingredients[i].length, supplies.length <= 100
 * 1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10
 * recipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.
 * All the values of recipes and supplies combined are unique.
 * Each ingredients[i] does not contain any duplicate values.",Solutions (668),1.4K
FALSE,0,0,2219,,Maximum Number of Words Found in Sentences,maximum-number-of-words-found-in-sentences,FALSE,170876,195938,2114,FALSE,1,"Can you solve this real interview question? Maximum Number of Words Found in Sentences - A sentence is a list of words that are separated by a single space with no leading or trailing spaces.

You are given an array of strings sentences, where each sentences[i] represents a single sentence.

Return the maximum number of words that appear in a single sentence.

 

Example 1:


Input: sentences = [""alice and bob love leetcode"", ""i think so too"", ""this is great thanks very much""]
Output: 6
Explanation: 
- The first sentence, ""alice and bob love leetcode"", has 5 words in total.
- The second sentence, ""i think so too"", has 4 words in total.
- The third sentence, ""this is great thanks very much"", has 6 words in total.
Thus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words.


Example 2:


Input: sentences = [""please wait"", ""continue to fight"", ""continue to win""]
Output: 3
Explanation: It is possible that multiple sentences contain the same number of words. 
In this example, the second and third sentences (underlined) have the same number of words.


 

Constraints:

 * 1 <= sentences.length <= 100
 * 1 <= sentences[i].length <= 100
 * sentences[i] consists only of lowercase English letters and ' ' only.
 * sentences[i] does not have leading or trailing spaces.
 * All the words in sentences[i] are separated by a single space.",Solutions (2.4K),1.3K
FALSE,0,0,2217,,Step-By-Step Directions From a Binary Tree Node to Another,step-by-step-directions-from-a-binary-tree-node-to-another,FALSE,79746,164697,2096,FALSE,2,"Can you solve this real interview question? Step-By-Step Directions From a Binary Tree Node to Another - You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.

Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:

 * 'L' means to go from a node to its left child node.
 * 'R' means to go from a node to its right child node.
 * 'U' means to go from a node to its parent node.

Return the step-by-step directions of the shortest path from node s to node t.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/11/15/eg1.png]


Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
Output: ""UURL""
Explanation: The shortest path is: 3 → 1 → 5 → 2 → 6.


Example 2:

[https://assets.leetcode.com/uploads/2021/11/15/eg2.png]


Input: root = [2,1], startValue = 2, destValue = 1
Output: ""L""
Explanation: The shortest path is: 2 → 1.


 

Constraints:

 * The number of nodes in the tree is n.
 * 2 <= n <= 105
 * 1 <= Node.val <= n
 * All the values in the tree are unique.
 * 1 <= startValue, destValue <= n
 * startValue != destValue",Solutions (738),2K
FALSE,0,0,2216,delete-the-middle-node-of-a-linked-list,Delete the Middle Node of a Linked List,delete-the-middle-node-of-a-linked-list,FALSE,179156,301111,2095,FALSE,2,"Can you solve this real interview question? Delete the Middle Node of a Linked List - You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.

The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.

 * For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png]


Input: head = [1,3,4,7,1,2,6]
Output: [1,3,4,1,2,6]
Explanation:
The above figure represents the given linked list. The indices of the nodes are written below.
Since n = 7, node 3 with value 7 is the middle node, which is marked in red.
We return the new list after removing this node. 


Example 2:

[https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png]


Input: head = [1,2,3,4]
Output: [1,2,4]
Explanation:
The above figure represents the given linked list.
For n = 4, node 2 with value 3 is the middle node, which is marked in red.


Example 3:

[https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png]


Input: head = [2,1]
Output: [2]
Explanation:
The above figure represents the given linked list.
For n = 2, node 1 with value 1 is the middle node, which is marked in red.
Node 0 with value 2 is the only node remaining after removing node 1.

 

Constraints:

 * The number of nodes in the list is in the range [1, 105].
 * 1 <= Node.val <= 105",Solutions (2.7K),2.8K
FALSE,0,0,2215,,Finding 3-Digit Even Numbers,finding-3-digit-even-numbers,FALSE,22479,38896,2094,FALSE,1,"Can you solve this real interview question? Finding 3-Digit Even Numbers - You are given an integer array digits, where each element is a digit. The array may contain duplicates.

You need to find all the unique integers that follow the given requirements:

 * The integer consists of the concatenation of three elements from digits in any arbitrary order.
 * The integer does not have leading zeros.
 * The integer is even.

For example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements.

Return a sorted array of the unique integers.

 

Example 1:


Input: digits = [2,1,3,0]
Output: [102,120,130,132,210,230,302,310,312,320]
Explanation: All the possible integers that follow the requirements are in the output array. 
Notice that there are no odd integers or integers with leading zeros.


Example 2:


Input: digits = [2,2,8,8,2]
Output: [222,228,282,288,822,828,882]
Explanation: The same digit can be used as many times as it appears in digits. 
In this example, the digit 8 is used twice each time in 288, 828, and 882. 


Example 3:


Input: digits = [3,7,5]
Output: []
Explanation: No even integers can be formed using the given digits.


 

Constraints:

 * 3 <= digits.length <= 100
 * 0 <= digits[i] <= 9",Solutions (330),407
FALSE,0,0,2213,,Find All People With Secret,find-all-people-with-secret,FALSE,20466,59844,2092,FALSE,3,"Can you solve this real interview question? Find All People With Secret - You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.

Person 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.

The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.

Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.

 

Example 1:


Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
Output: [0,1,2,3,5]
Explanation:
At time 0, person 0 shares the secret with person 1.
At time 5, person 1 shares the secret with person 2.
At time 8, person 2 shares the secret with person 3.
At time 10, person 1 shares the secret with person 5.​​​​
Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.


Example 2:


Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
Output: [0,1,3]
Explanation:
At time 0, person 0 shares the secret with person 3.
At time 2, neither person 1 nor person 2 know the secret.
At time 3, person 3 shares the secret with person 0 and person 1.
Thus, people 0, 1, and 3 know the secret after all the meetings.


Example 3:


Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
Output: [0,1,2,3,4]
Explanation:
At time 0, person 0 shares the secret with person 1.
At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.
Note that person 2 can share the secret at the same time as receiving it.
At time 2, person 3 shares the secret with person 4.
Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.


 

Constraints:

 * 2 <= n <= 105
 * 1 <= meetings.length <= 105
 * meetings[i].length == 3
 * 0 <= xi, yi <= n - 1
 * xi != yi
 * 1 <= timei <= 105
 * 1 <= firstPerson <= n - 1",Solutions (276),688
FALSE,0,0,2212,,Removing Minimum and Maximum From Array,removing-minimum-and-maximum-from-array,FALSE,28821,51592,2091,FALSE,2,"Can you solve this real interview question? Removing Minimum and Maximum From Array - You are given a 0-indexed array of distinct integers nums.

There is an element in nums that has the lowest value and an element that has the highest value. We call them the minimum and maximum respectively. Your goal is to remove both these elements from the array.

A deletion is defined as either removing an element from the front of the array or removing an element from the back of the array.

Return the minimum number of deletions it would take to remove both the minimum and maximum element from the array.

 

Example 1:


Input: nums = [2,10,7,5,4,1,8,6]
Output: 5
Explanation: 
The minimum element in the array is nums[5], which is 1.
The maximum element in the array is nums[1], which is 10.
We can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back.
This results in 2 + 3 = 5 deletions, which is the minimum number possible.


Example 2:


Input: nums = [0,-4,19,1,8,-2,-3,5]
Output: 3
Explanation: 
The minimum element in the array is nums[1], which is -4.
The maximum element in the array is nums[2], which is 19.
We can remove both the minimum and maximum by removing 3 elements from the front.
This results in only 3 deletions, which is the minimum number possible.


Example 3:


Input: nums = [101]
Output: 1
Explanation:  
There is only one element in the array, which makes it both the minimum and maximum element.
We can remove it with 1 deletion.


 

Constraints:

 * 1 <= nums.length <= 105
 * -105 <= nums[i] <= 105
 * The integers in nums are distinct.",Solutions (586),711
FALSE,0,0,2211,,K Radius Subarray Averages,k-radius-subarray-averages,FALSE,22934,53744,2090,FALSE,2,"Can you solve this real interview question? K Radius Subarray Averages - You are given a 0-indexed array nums of n integers, and an integer k.

The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1.

Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.

The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.

 * For example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/11/07/eg1.png]


Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
Output: [-1,-1,-1,5,4,4,-1,-1,-1]
Explanation:
- avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.
- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.
  Using integer division, avg[3] = 37 / 7 = 5.
- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.
- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.
- avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.


Example 2:


Input: nums = [100000], k = 0
Output: [100000]
Explanation:
- The sum of the subarray centered at index 0 with radius 0 is: 100000.
  avg[0] = 100000 / 1 = 100000.


Example 3:


Input: nums = [8], k = 100000
Output: [-1]
Explanation: 
- avg[0] is -1 because there are less than k elements before and after index 0.


 

Constraints:

 * n == nums.length
 * 1 <= n <= 105
 * 0 <= nums[i], k <= 105",Solutions (361),483
FALSE,0,0,2210,,Find Target Indices After Sorting Array,find-target-indices-after-sorting-array,FALSE,110515,144729,2089,FALSE,1,"Can you solve this real interview question? Find Target Indices After Sorting Array - You are given a 0-indexed integer array nums and a target element target.

A target index is an index i such that nums[i] == target.

Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.

 

Example 1:


Input: nums = [1,2,5,2,3], target = 2
Output: [1,2]
Explanation: After sorting, nums is [1,2,2,3,5].
The indices where nums[i] == 2 are 1 and 2.


Example 2:


Input: nums = [1,2,5,2,3], target = 3
Output: [3]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 3 is 3.


Example 3:


Input: nums = [1,2,5,2,3], target = 5
Output: [4]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 5 is 4.


 

Constraints:

 * 1 <= nums.length <= 100
 * 1 <= nums[i], target <= 100",Solutions (1.6K),1.3K
FALSE,0,0,2207,,Sequentially Ordinal Rank Tracker,sequentially-ordinal-rank-tracker,FALSE,12130,18456,2102,FALSE,3,"Can you solve this real interview question? Sequentially Ordinal Rank Tracker - A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better.

You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:

 * Adding scenic locations, one at a time.
 * Querying the ith best location of all locations already added, where i is the number of times the system has been queried (including the current query).
   * For example, when the system is queried for the 4th time, it returns the 4th best location of all locations already added.

Note that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system.

Implement the SORTracker class:

 * SORTracker() Initializes the tracker system.
 * void add(string name, int score) Adds a scenic location with name and score to the system.
 * string get() Queries and returns the ith best location, where i is the number of times this method has been invoked (including this invocation).

 

Example 1:


Input
[""SORTracker"", ""add"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""add"", ""get"", ""get""]
[[], [""bradford"", 2], [""branford"", 3], [], [""alps"", 2], [], [""orland"", 2], [], [""orlando"", 3], [], [""alpine"", 2], [], []]
Output
[null, null, null, ""branford"", null, ""alps"", null, ""bradford"", null, ""bradford"", null, ""bradford"", ""orland""]

Explanation
SORTracker tracker = new SORTracker(); // Initialize the tracker system.
tracker.add(""bradford"", 2); // Add location with name=""bradford"" and score=2 to the system.
tracker.add(""branford"", 3); // Add location with name=""branford"" and score=3 to the system.
tracker.get();              // The sorted locations, from best to worst, are: branford, bradford.
                            // Note that branford precedes bradford due to its higher score (3 > 2).
                            // This is the 1st time get() is called, so return the best location: ""branford"".
tracker.add(""alps"", 2);     // Add location with name=""alps"" and score=2 to the system.
tracker.get();              // Sorted locations: branford, alps, bradford.
                            // Note that alps precedes bradford even though they have the same score (2).
                            // This is because ""alps"" is lexicographically smaller than ""bradford"".
                            // Return the 2nd best location ""alps"", as it is the 2nd time get() is called.
tracker.add(""orland"", 2);   // Add location with name=""orland"" and score=2 to the system.
tracker.get();              // Sorted locations: branford, alps, bradford, orland.
                            // Return ""bradford"", as it is the 3rd time get() is called.
tracker.add(""orlando"", 3);  // Add location with name=""orlando"" and score=3 to the system.
tracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.
                            // Return ""bradford"".
tracker.add(""alpine"", 2);   // Add location with name=""alpine"" and score=2 to the system.
tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.
                            // Return ""bradford"".
tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.
                            // Return ""orland"".


 

Constraints:

 * name consists of lowercase English letters, and is unique among all locations.
 * 1 <= name.length <= 10
 * 1 <= score <= 105
 * At any time, the number of calls to get does not exceed the number of calls to add.
 * At most 4 * 104 calls in total will be made to add and get.",Solutions (161),317
FALSE,0,0,2206,,Detonate the Maximum Bombs,detonate-the-maximum-bombs,FALSE,28818,68626,2101,FALSE,2,"Can you solve this real interview question? Detonate the Maximum Bombs - You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.

The bombs are represented by a 0-indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi denote the X-coordinate and Y-coordinate of the location of the ith bomb, whereas ri denotes the radius of its range.

You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.

Given the list of bombs, return the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png]


Input: bombs = [[2,1,3],[6,1,4]]
Output: 2
Explanation:
The above figure shows the positions and ranges of the 2 bombs.
If we detonate the left bomb, the right bomb will not be affected.
But if we detonate the right bomb, both bombs will be detonated.
So the maximum bombs that can be detonated is max(1, 2) = 2.


Example 2:

[https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png]


Input: bombs = [[1,1,5],[10,10,5]]
Output: 1
Explanation:
Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.


Example 3:

[https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png]


Input: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
Output: 5
Explanation:
The best bomb to detonate is bomb 0 because:
- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.
- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.
- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.
Thus all 5 bombs are detonated.


 

Constraints:

 * 1 <= bombs.length <= 100
 * bombs[i].length == 3
 * 1 <= xi, yi, ri <= 105",Solutions (387),1K
FALSE,0,0,2205,,Find Good Days to Rob the Bank,find-good-days-to-rob-the-bank,FALSE,20062,40768,2100,FALSE,2,"Can you solve this real interview question? Find Good Days to Rob the Bank - You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.

The ith day is a good day to rob the bank if:

 * There are at least time days before and after the ith day,
 * The number of guards at the bank for the time days before i are non-increasing, and
 * The number of guards at the bank for the time days after i are non-decreasing.

More formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].

Return a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.

 

Example 1:


Input: security = [5,3,3,3,5,6,2], time = 2
Output: [2,3]
Explanation:
On day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4].
On day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5].
No other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.


Example 2:


Input: security = [1,1,1,1,1], time = 0
Output: [0,1,2,3,4]
Explanation:
Since time equals 0, every day is a good day to rob the bank, so return every day.


Example 3:


Input: security = [1,2,3,4,5,6], time = 2
Output: []
Explanation:
No day has 2 days before it that have a non-increasing number of guards.
Thus, no day is a good day to rob the bank, so return an empty list.


 

Constraints:

 * 1 <= security.length <= 105
 * 0 <= security[i], time <= 105",Solutions (308),699
FALSE,0,0,2204,,Find Subsequence of Length K With the Largest Sum,find-subsequence-of-length-k-with-the-largest-sum,FALSE,32225,75141,2099,FALSE,1,"Can you solve this real interview question? Find Subsequence of Length K With the Largest Sum - You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum.

Return any such subsequence as an integer array of length k.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:


Input: nums = [2,1,3,3], k = 2
Output: [3,3]
Explanation:
The subsequence has the largest sum of 3 + 3 = 6.

Example 2:


Input: nums = [-1,-2,3,4], k = 3
Output: [-1,3,4]
Explanation: 
The subsequence has the largest sum of -1 + 3 + 4 = 6.


Example 3:


Input: nums = [3,4,3,3], k = 2
Output: [3,4]
Explanation:
The subsequence has the largest sum of 3 + 4 = 7. 
Another possible subsequence is [4, 3].


 

Constraints:

 * 1 <= nums.length <= 1000
 * -105 <= nums[i] <= 105
 * 1 <= k <= nums.length",Solutions (586),926
FALSE,0,0,2202,,Sum of k-Mirror Numbers,sum-of-k-mirror-numbers,FALSE,6300,14997,2081,FALSE,3,"Can you solve this real interview question? Sum of k-Mirror Numbers - A k-mirror number is a positive integer without leading zeros that reads the same both forward and backward in base-10 as well as in base-k.

 * For example, 9 is a 2-mirror number. The representation of 9 in base-10 and base-2 are 9 and 1001 respectively, which read the same both forward and backward.
 * On the contrary, 4 is not a 2-mirror number. The representation of 4 in base-2 is 100, which does not read the same both forward and backward.

Given the base k and the number n, return the sum of the n smallest k-mirror numbers.

 

Example 1:


Input: k = 2, n = 5
Output: 25
Explanation:
The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:
  base-10    base-2
    1          1
    3          11
    5          101
    7          111
    9          1001
Their sum = 1 + 3 + 5 + 7 + 9 = 25. 


Example 2:


Input: k = 3, n = 7
Output: 499
Explanation:
The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:
  base-10    base-3
    1          1
    2          2
    4          11
    8          22
    121        11111
    151        12121
    212        21212
Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.


Example 3:


Input: k = 7, n = 17
Output: 20379000
Explanation: The 17 smallest 7-mirror numbers are:
1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596


 

Constraints:

 * 2 <= k <= 9
 * 1 <= n <= 30",Solutions (67),107
FALSE,0,0,2201,,Valid Arrangement of Pairs,valid-arrangement-of-pairs,FALSE,6994,16969,2097,FALSE,3,"Can you solve this real interview question? Valid Arrangement of Pairs - You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.

Return any valid arrangement of pairs.

Note: The inputs will be generated such that there exists a valid arrangement of pairs.

 

Example 1:


Input: pairs = [[5,1],[4,5],[11,9],[9,4]]
Output: [[11,9],[9,4],[4,5],[5,1]]
Explanation:
This is a valid arrangement since endi-1 always equals starti.
end0 = 9 == 9 = start1 
end1 = 4 == 4 = start2
end2 = 5 == 5 = start3


Example 2:


Input: pairs = [[1,3],[3,2],[2,1]]
Output: [[1,3],[3,2],[2,1]]
Explanation:
This is a valid arrangement since endi-1 always equals starti.
end0 = 3 == 3 = start1
end1 = 2 == 2 = start2
The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.


Example 3:


Input: pairs = [[1,2],[1,3],[2,1]]
Output: [[1,2],[2,1],[1,3]]
Explanation:
This is a valid arrangement since endi-1 always equals starti.
end0 = 2 == 2 = start1
end1 = 1 == 1 = start2


 

Constraints:

 * 1 <= pairs.length <= 105
 * pairs[i].length == 2
 * 0 <= starti, endi <= 109
 * starti != endi
 * No two pairs are exactly the same.
 * There exists a valid arrangement of pairs.",Solutions (74),393
FALSE,0,0,2200,,Stamping the Grid,stamping-the-grid,FALSE,5580,17620,2132,FALSE,3,"Can you solve this real interview question? Stamping the Grid - You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).

You are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:

 1. Cover all the empty cells.
 2. Do not cover any of the occupied cells.
 3. We can put as many stamps as we want.
 4. Stamps can overlap with each other.
 5. Stamps are not allowed to be rotated.
 6. Stamps must stay completely inside the grid.

Return true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/11/03/ex1.png]


Input: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3
Output: true
Explanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.


Example 2:

[https://assets.leetcode.com/uploads/2021/11/03/ex2.png]


Input: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 
Output: false 
Explanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.


 

Constraints:

 * m == grid.length
 * n == grid[r].length
 * 1 <= m, n <= 105
 * 1 <= m * n <= 2 * 105
 * grid[r][c] is either 0 or 1.
 * 1 <= stampHeight, stampWidth <= 105",Solutions (67),328
FALSE,0,0,2199,,Two Furthest Houses With Different Colors,two-furthest-houses-with-different-colors,FALSE,39963,59608,2078,FALSE,1,"Can you solve this real interview question? Two Furthest Houses With Different Colors - There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.

Return the maximum distance between two houses with different colors.

The distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/10/31/eg1.png]


Input: colors = [1,1,1,6,1,1,1]
Output: 3
Explanation: In the above image, color 1 is blue, and color 6 is red.
The furthest two houses with different colors are house 0 and house 3.
House 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.
Note that houses 3 and 6 can also produce the optimal answer.


Example 2:

[https://assets.leetcode.com/uploads/2021/10/31/eg2.png]


Input: colors = [1,8,3,8,3]
Output: 4
Explanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.
The furthest two houses with different colors are house 0 and house 4.
House 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.


Example 3:


Input: colors = [0,1]
Output: 1
Explanation: The furthest two houses with different colors are house 0 and house 1.
House 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1.


 

Constraints:

 * n == colors.length
 * 2 <= n <= 100
 * 0 <= colors[i] <= 100
 * Test data are generated such that at least two houses have different colors.",Solutions (536),729
FALSE,0,0,2198,,Process Restricted Friend Requests,process-restricted-friend-requests,FALSE,13424,25230,2076,FALSE,3,"Can you solve this real interview question? Process Restricted Friend Requests - You are given an integer n indicating the number of people in a network. Each person is labeled from 0 to n - 1.

You are also given a 0-indexed 2D integer array restrictions, where restrictions[i] = [xi, yi] means that person xi and person yi cannot become friends, either directly or indirectly through other people.

Initially, no one is friends with each other. You are given a list of friend requests as a 0-indexed 2D integer array requests, where requests[j] = [uj, vj] is a friend request between person uj and person vj.

A friend request is successful if uj and vj can be friends. Each friend request is processed in the given order (i.e., requests[j] occurs before requests[j + 1]), and upon a successful request, uj and vj become direct friends for all future friend requests.

Return a boolean array result, where each result[j] is true if the jth friend request is successful or false if it is not.

Note: If uj and vj are already direct friends, the request is still successful.

 

Example 1:


Input: n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]
Output: [true,false]
Explanation:
Request 0: Person 0 and person 2 can be friends, so they become direct friends. 
Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).


Example 2:


Input: n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]
Output: [true,false]
Explanation:
Request 0: Person 1 and person 2 can be friends, so they become direct friends.
Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).


Example 3:


Input: n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]
Output: [true,false,true,false]
Explanation:
Request 0: Person 0 and person 4 can be friends, so they become direct friends.
Request 1: Person 1 and person 2 cannot be friends since they are directly restricted.
Request 2: Person 3 and person 1 can be friends, so they become direct friends.
Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).


 

Constraints:

 * 2 <= n <= 1000
 * 0 <= restrictions.length <= 1000
 * restrictions[i].length == 2
 * 0 <= xi, yi <= n - 1
 * xi != yi
 * 1 <= requests.length <= 1000
 * requests[j].length == 2
 * 0 <= uj, vj <= n - 1
 * uj != vj",Solutions (172),508
FALSE,0,0,2197,,Decode the Slanted Ciphertext,decode-the-slanted-ciphertext,FALSE,10844,21571,2075,FALSE,2,"Can you solve this real interview question? Decode the Slanted Ciphertext - A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.

originalText is placed first in a top-left to bottom-right manner.

[https://assets.leetcode.com/uploads/2021/11/07/exa11.png]

The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.

encodedText is then formed by appending all characters of the matrix in a row-wise fashion.

[https://assets.leetcode.com/uploads/2021/11/07/exa12.png]

The characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.

For example, if originalText = ""cipher"" and rows = 3, then we encode it in the following manner:

[https://assets.leetcode.com/uploads/2021/10/25/desc2.png]

The blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = ""ch ie pr"".

Given the encoded string encodedText and number of rows rows, return the original string originalText.

Note: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.

 

Example 1:


Input: encodedText = ""ch   ie   pr"", rows = 3
Output: ""cipher""
Explanation: This is the same example described in the problem description.


Example 2:

[https://assets.leetcode.com/uploads/2021/10/26/exam1.png]


Input: encodedText = ""iveo    eed   l te   olc"", rows = 4
Output: ""i love leetcode""
Explanation: The figure above denotes the matrix that was used to encode originalText. 
The blue arrows show how we can find originalText from encodedText.


Example 3:

[https://assets.leetcode.com/uploads/2021/10/26/eg2.png]


Input: encodedText = ""coding"", rows = 1
Output: ""coding""
Explanation: Since there is only 1 row, both originalText and encodedText are the same.


 

Constraints:

 * 0 <= encodedText.length <= 106
 * encodedText consists of lowercase English letters and ' ' only.
 * encodedText is a valid encoding of some originalText that does not have trailing spaces.
 * 1 <= rows <= 1000
 * The testcases are generated such that there is only one possible originalText.",Solutions (182),214
FALSE,0,0,2196,,Reverse Nodes in Even Length Groups,reverse-nodes-in-even-length-groups,FALSE,15637,29245,2074,FALSE,2,"Can you solve this real interview question? Reverse Nodes in Even Length Groups - You are given the head of a linked list.

The nodes in the linked list are sequentially assigned to non-empty groups whose lengths form the sequence of the natural numbers (1, 2, 3, 4, ...). The length of a group is the number of nodes assigned to it. In other words,

 * The 1st node is assigned to the first group.
 * The 2nd and the 3rd nodes are assigned to the second group.
 * The 4th, 5th, and 6th nodes are assigned to the third group, and so on.

Note that the length of the last group may be less than or equal to 1 + the length of the second to last group.

Reverse the nodes in each group with an even length, and return the head of the modified linked list.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/10/25/eg1.png]


Input: head = [5,2,6,3,9,1,7,3,8,4]
Output: [5,6,2,3,9,1,4,8,3,7]
Explanation:
- The length of the first group is 1, which is odd, hence no reversal occurs.
- The length of the second group is 2, which is even, hence the nodes are reversed.
- The length of the third group is 3, which is odd, hence no reversal occurs.
- The length of the last group is 4, which is even, hence the nodes are reversed.


Example 2:

[https://assets.leetcode.com/uploads/2021/10/25/eg2.png]


Input: head = [1,1,0,6]
Output: [1,0,1,6]
Explanation:
- The length of the first group is 1. No reversal occurs.
- The length of the second group is 2. The nodes are reversed.
- The length of the last group is 1. No reversal occurs.


Example 3:

[https://assets.leetcode.com/uploads/2021/11/17/ex3.png]


Input: head = [1,1,0,6,5]
Output: [1,0,1,5,6]
Explanation:
- The length of the first group is 1. No reversal occurs.
- The length of the second group is 2. The nodes are reversed.
- The length of the last group is 2. The nodes are reversed.


 

Constraints:

 * The number of nodes in the list is in the range [1, 105].
 * 0 <= Node.val <= 105",Solutions (315),462
FALSE,0,0,2195,,Time Needed to Buy Tickets,time-needed-to-buy-tickets,FALSE,39465,63302,2073,FALSE,1,"Can you solve this real interview question? Time Needed to Buy Tickets - There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.

You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].

Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.

Return the time taken for the person at position k (0-indexed) to finish buying tickets.

 

Example 1:


Input: tickets = [2,3,2], k = 2
Output: 6
Explanation: 
- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].
- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].
The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.


Example 2:


Input: tickets = [5,1,1,1], k = 0
Output: 8
Explanation:
- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].
- In the next 4 passes, only the person in position 0 is buying tickets.
The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.


 

Constraints:

 * n == tickets.length
 * 1 <= n <= 100
 * 1 <= tickets[i] <= 100
 * 0 <= k < n",Solutions (689),668
FALSE,0,0,2193,,Count Fertile Pyramids in a Land,count-fertile-pyramids-in-a-land,FALSE,5758,9063,2088,FALSE,3,"Can you solve this real interview question? Count Fertile Pyramids in a Land - A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren.

A pyramidal plot of land can be defined as a set of cells with the following criteria:

 1. The number of cells in the set has to be greater than 1 and all cells must be fertile.
 2. The apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).

An inverse pyramidal plot of land can be defined as a set of cells with similar criteria:

 1. The number of cells in the set has to be greater than 1 and all cells must be fertile.
 2. The apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).

Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.

[https://assets.leetcode.com/uploads/2021/11/08/image.png]

Given a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid.

 

Example 1:

[https://assets.leetcode.com/uploads/2021/12/22/1.JPG]


Input: grid = [[0,1,1,0],[1,1,1,1]]
Output: 2
Explanation: The 2 possible pyramidal plots are shown in blue and red respectively.
There are no inverse pyramidal plots in this grid. 
Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.


Example 2:

[https://assets.leetcode.com/uploads/2021/12/22/2.JPG]


Input: grid = [[1,1,1],[1,1,1]]
Output: 2
Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. 
Hence the total number of plots is 1 + 1 = 2.


Example 3:

[https://assets.leetcode.com/uploads/2021/12/22/3.JPG]


Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]
Output: 13
Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.
There are 6 inverse pyramidal plots, 2 of which are shown in the last figure.
The total number of plots is 7 + 6 = 13.


 

Constraints:

 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 1000
 * 1 <= m * n <= 105
 * grid[i][j] is either 0 or 1.",Solutions (120),277